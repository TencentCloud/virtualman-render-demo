!(function (t, e) {
  "object" == typeof exports && "undefined" != typeof module
    ? (module.exports = e())
    : "function" == typeof define && define.amd
    ? define(e)
    : ((t = "undefined" != typeof globalThis ? globalThis : t || self).IVH =
        e());
})(this, function () {
  "use strict";
  var t = Object.defineProperty,
    e = Object.defineProperties,
    n = Object.getOwnPropertyDescriptors,
    i = Object.getOwnPropertySymbols,
    r = Object.prototype.hasOwnProperty,
    s = Object.prototype.propertyIsEnumerable,
    a = Math.pow,
    o = (e, n, i) =>
      n in e
        ? t(e, n, { enumerable: !0, configurable: !0, writable: !0, value: i })
        : (e[n] = i),
    l = (t, e) => {
      for (var n in e || (e = {})) r.call(e, n) && o(t, n, e[n]);
      if (i) for (var n of i(e)) s.call(e, n) && o(t, n, e[n]);
      return t;
    },
    c = (t, e, n) =>
      new Promise((i, r) => {
        var s = (t) => {
            try {
              o(n.next(t));
            } catch (e) {
              r(e);
            }
          },
          a = (t) => {
            try {
              o(n.throw(t));
            } catch (e) {
              r(e);
            }
          },
          o = (t) =>
            t.done ? i(t.value) : Promise.resolve(t.value).then(s, a);
        o((n = n.apply(t, e)).next());
      });
  const h = d;
  function u() {
    const t = [
      "模型配置错误",
      "3041272Ugtjbq",
      "toString",
      "播放未结束",
      "generateUUID",
      "模型皮肤纹理错误",
      "floor",
      "2232830iKVkDl",
      "http error",
      "now",
      "wsOrigin",
      "加载组件错误",
      "load action error",
      "1419324tzdFly",
      "socket连接错误",
      "4093866YKHWUh",
      "2whHwje",
      "模型数据为空",
      "httpOrigin",
      "socket error",
      "model skin texture error",
      "获取解压数据错误",
      "container element is null",
      "请先初始化",
      "https://xiaowei.cloud.tencent.com",
      "please initialize first",
      "uuid",
      "model configuration error",
      "3.7.1",
      "model data is null",
      "980601kOyxyc",
      "audioContext not initialized",
      "default_action_idle",
      "模型容器元素的宽高为0",
      "cloudFuncOrigin",
      "number",
      "default_action_idle has conflicts",
      "getTime",
      "replace",
      "defaultActionName",
      "https://gw-sg.tvs.qq.com",
      "解压初始化错误",
      "getError",
      "unzip initialize error",
      "8EHKwai",
      "action data is null",
      "apply",
      "virtualmanProjectId is null",
      "localStorage",
      "sign is null",
      "isNumber",
      "https://gw.tvs.qq.com",
      "setItem",
      "1396530xdpAxt",
      "getItem",
      "wss://gw-sg.tvs.qq.com",
      "the width and height of the model container element is 0",
      "3725008gmdcom",
      "undefined",
      "setIntl",
      "load component error",
      "version",
      "opening_action_once has conflicts",
      "sign为空",
      "(((.+)+)+)+$",
      "language",
      "virtualmanProjectId为空",
      "流式文本的streamId为空",
      "default_action_idle存在冲突",
      "socket connection error",
      "randomUUID",
      "errorMap",
      "zh-CN",
      "加载动作错误",
      "openingActionName",
      "getDeviceID",
      "search",
      "play not ended",
      "动作数据为空",
      "audioContext未初始化",
    ];
    return (u = function () {
      return t;
    })();
  }
  function d(t, e) {
    const n = u();
    return (d = function (t, e) {
      return n[(t -= 300)];
    })(t, e);
  }
  !(function (t, e) {
    const n = d,
      i = t();
    for (;;)
      try {
        if (
          597057 ===
          (-parseInt(n(332)) / 1) * (-parseInt(n(318)) / 2) +
            parseInt(n(315)) / 3 +
            (-parseInt(n(346)) / 4) * (-parseInt(n(309)) / 5) +
            -parseInt(n(317)) / 6 +
            -parseInt(n(359)) / 7 +
            -parseInt(n(303)) / 8 +
            -parseInt(n(355)) / 9
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(u);
  const p = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n[d(348)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    f = p(globalThis, function () {
      const t = d;
      return f[t(304)]()
        [t(378)]("(((.+)+)+)+$")
        [t(304)]()
        .constructor(f)
        [t(378)](t(366));
    });
  f();
  class m {
    static [h(377)]() {
      const t = h,
        e = "IVH_UUID";
      return this[t(328)]
        ? this.uuid
        : ((this[t(328)] = window[t(350)][t(356)](e)),
          this[t(328)] ||
            ((this[t(328)] = this[t(306)]()),
            window[t(350)][t(354)](e, this[t(328)])),
          this[t(328)]);
    }
    static [h(306)]() {
      const t = h;
      let e;
      crypto && crypto[t(372)] && (e = crypto.randomUUID());
      let n = new Date()[t(339)](),
        i =
          (typeof performance !== t(360) &&
            performance.now &&
            1e3 * performance[t(311)]()) ||
          0;
      return (
        (e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"[t(340)](
          /[xy]/g,
          function (e) {
            const r = t;
            let s = 16 * Math.random();
            return (
              n > 0
                ? ((s = (n + s) % 16 | 0), (n = Math[r(308)](n / 16)))
                : ((s = (i + s) % 16 | 0), (i = Math[r(308)](i / 16))),
              ("x" === e ? s : (3 & s) | 8)[r(304)](16)
            );
          },
        )),
        e[t(340)](/-/g, "")
      );
    }
    static [h(352)](t) {
      return typeof t === h(337);
    }
    static [h(361)](t) {
      const e = h;
      t &&
        ((this.httpOrigin = e(342)),
        (this[e(312)] = e(357)),
        (this[e(336)] = "https://xiaowei.tencentcloud.com"),
        (this.language = "en-US"));
    }
    static [h(344)](t) {
      const e = h;
      return this.errorMap[this[e(367)]][t];
    }
  }
  (m[h(363)] = h(330)),
    (m.isCanReport = !0),
    (m[h(320)] = h(353)),
    (m[h(312)] = "wss://gw.tvs.qq.com"),
    (m.cloudFuncOrigin = h(326)),
    (m[h(341)] = h(334)),
    (m[h(376)] = "opening_action_once"),
    (m.uuid = ""),
    (m[h(367)] = h(374)),
    (m[h(373)] = {
      "en-US": {
        1001: h(324),
        1002: h(351),
        1003: h(331),
        1004: h(347),
        1005: h(333),
        1006: h(314),
        1007: h(379),
        1008: h(349),
        1009: "the streamId of the streaming text is null",
        1010: h(329),
        1011: h(327),
        1012: h(345),
        1013: "get unzip data error",
        1014: h(362),
        1015: h(338),
        1016: h(364),
        2001: h(371),
        2002: h(321),
        2003: h(310),
        3001: h(358),
        3002: h(331),
        3003: h(322),
        3004: "action does not match the blendshape of the model",
      },
      "zh-CN": {
        1001: "容器元素为空",
        1002: h(365),
        1003: "模型数据为空",
        1004: h(300),
        1005: h(301),
        1006: h(375),
        1007: h(305),
        1008: h(368),
        1009: h(369),
        1010: h(302),
        1011: h(325),
        1012: h(343),
        1013: h(323),
        1014: h(313),
        1015: h(370),
        1016: "opening_action_once存在冲突",
        2001: h(316),
        2002: "socket请求异常",
        2003: "http请求异常",
        3001: h(335),
        3002: h(319),
        3003: h(307),
        3004: "动作不匹配模型的blendshape",
      },
    });
  const g = x;
  !(function (t, e) {
    const n = x,
      i = t();
    for (;;)
      try {
        if (
          584297 ===
          -parseInt(n(328)) / 1 +
            (-parseInt(n(319)) / 2) * (-parseInt(n(322)) / 3) +
            parseInt(n(344)) / 4 +
            (-parseInt(n(320)) / 5) * (-parseInt(n(342)) / 6) +
            (parseInt(n(336)) / 7) * (-parseInt(n(335)) / 8) +
            -parseInt(n(326)) / 9 +
            parseInt(n(346)) / 10
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(y);
  const v = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    _ = v(globalThis, function () {
      const t = x;
      return _[t(332)]()
        .search("(((.+)+)+)+$")
        [t(332)]()
        .constructor(_)
        [t(341)](t(339));
    });
  function y() {
    const t = [
      "89757sSvVKv",
      "result",
      "now",
      "model_download",
      "6674157xSqgIa",
      "application/json;charset=UTF-8",
      "617781byoUEP",
      "https://otheve.beacon.qq.com/analytics/v2_upload",
      "then",
      "POST",
      "toString",
      "report",
      "isCanReport",
      "7815608XMtEUz",
      "7JDYDCw",
      "getDeviceID",
      "stringify",
      "(((.+)+)+)+$",
      "is_unzip",
      "search",
      "3424002CJXNOE",
      "client",
      "284296YEUciV",
      "model_size",
      "19796710DwlZvd",
      "model",
      "20CeTsLM",
      "5ZNoDYA",
      "model_init",
    ];
    return (y = function () {
      return t;
    })();
  }
  function x(t, e) {
    const n = y();
    return (x = function (t, e) {
      return n[(t -= 318)];
    })(t, e);
  }
  _();
  class M {
    static [g(333)](t) {
      return c(this, null, function* () {
        const e = g;
        if (!m[e(334)]) return !1;
        const {
            virtualmanKey: n,
            eventCode: i,
            modelDownload: r,
            modelInit: s,
            modelSize: a,
            isUnzip: o,
          } = t,
          l = { virtualmanKey: n, client_ua: "" + navigator.userAgent };
        if (i === e(318))
          (l[e(325)] = "" + r),
            (l[e(321)] = "" + s),
            (l[e(345)] = "" + a),
            (l[e(340)] = "" + o);
        return yield fetch(e(329), {
          method: e(331),
          body: JSON[e(338)]({
            appVersion: e(343),
            sdkId: "js",
            sdkVersion: m.version,
            mainAppKey: "0WEB05R3DC13DQME",
            platformId: 3,
            common: { A2: m[e(337)]() },
            events: [
              { eventCode: i, eventTime: "" + Date[e(324)](), mapValue: l },
            ],
          }),
          headers: { "Content-Type": e(327) },
        })
          [e(330)]((t) => t.json())
          [e(330)]((t) => 200 === (null == t ? void 0 : t[e(323)]));
      });
    }
  }
  var S =
    "undefined" != typeof globalThis
      ? globalThis
      : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : {};
  function b(t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, "default")
      ? t.default
      : t;
  }
  function T(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if ("function" == typeof e) {
      var n = function t() {
        return this instanceof t
          ? Reflect.construct(e, arguments, this.constructor)
          : e.apply(this, arguments);
      };
      n.prototype = e.prototype;
    } else n = {};
    return (
      Object.defineProperty(n, "__esModule", { value: !0 }),
      Object.keys(t).forEach(function (e) {
        var i = Object.getOwnPropertyDescriptor(t, e);
        Object.defineProperty(
          n,
          e,
          i.get
            ? i
            : {
                enumerable: !0,
                get: function () {
                  return t[e];
                },
              },
        );
      }),
      n
    );
  }
  var w = { exports: {} };
  var E = { exports: {} };
  const A = T(
    Object.freeze(
      Object.defineProperty(
        { __proto__: null, default: {} },
        Symbol.toStringTag,
        { value: "Module" },
      ),
    ),
  );
  var R;
  function C() {
    return (
      R ||
        ((R = 1),
        (E.exports =
          ((t =
            t ||
            (function (t, e) {
              var n;
              if (
                ("undefined" != typeof window &&
                  window.crypto &&
                  (n = window.crypto),
                "undefined" != typeof self && self.crypto && (n = self.crypto),
                "undefined" != typeof globalThis &&
                  globalThis.crypto &&
                  (n = globalThis.crypto),
                !n &&
                  "undefined" != typeof window &&
                  window.msCrypto &&
                  (n = window.msCrypto),
                !n && void 0 !== S && S.crypto && (n = S.crypto),
                !n)
              )
                try {
                  n = A;
                } catch (m) {}
              var i = function () {
                  if (n) {
                    if ("function" == typeof n.getRandomValues)
                      try {
                        return n.getRandomValues(new Uint32Array(1))[0];
                      } catch (m) {}
                    if ("function" == typeof n.randomBytes)
                      try {
                        return n.randomBytes(4).readInt32LE();
                      } catch (m) {}
                  }
                  throw new Error(
                    "Native crypto module could not be used to get secure random number.",
                  );
                },
                r =
                  Object.create ||
                  (function () {
                    function t() {}
                    return function (e) {
                      var n;
                      return (
                        (t.prototype = e),
                        (n = new t()),
                        (t.prototype = null),
                        n
                      );
                    };
                  })(),
                s = {},
                a = (s.lib = {}),
                o = (a.Base = {
                  extend: function (t) {
                    var e = r(this);
                    return (
                      t && e.mixIn(t),
                      (e.hasOwnProperty("init") && this.init !== e.init) ||
                        (e.init = function () {
                          e.$super.init.apply(this, arguments);
                        }),
                      (e.init.prototype = e),
                      (e.$super = this),
                      e
                    );
                  },
                  create: function () {
                    var t = this.extend();
                    return t.init.apply(t, arguments), t;
                  },
                  init: function () {},
                  mixIn: function (t) {
                    for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
                    t.hasOwnProperty("toString") &&
                      (this.toString = t.toString);
                  },
                  clone: function () {
                    return this.init.prototype.extend(this);
                  },
                }),
                l = (a.WordArray = o.extend({
                  init: function (t, n) {
                    (t = this.words = t || []),
                      (this.sigBytes = n != e ? n : 4 * t.length);
                  },
                  toString: function (t) {
                    return (t || h).stringify(this);
                  },
                  concat: function (t) {
                    var e = this.words,
                      n = t.words,
                      i = this.sigBytes,
                      r = t.sigBytes;
                    if ((this.clamp(), i % 4))
                      for (var s = 0; s < r; s++) {
                        var a = (n[s >>> 2] >>> (24 - (s % 4) * 8)) & 255;
                        e[(i + s) >>> 2] |= a << (24 - ((i + s) % 4) * 8);
                      }
                    else
                      for (var o = 0; o < r; o += 4)
                        e[(i + o) >>> 2] = n[o >>> 2];
                    return (this.sigBytes += r), this;
                  },
                  clamp: function () {
                    var e = this.words,
                      n = this.sigBytes;
                    (e[n >>> 2] &= 4294967295 << (32 - (n % 4) * 8)),
                      (e.length = t.ceil(n / 4));
                  },
                  clone: function () {
                    var t = o.clone.call(this);
                    return (t.words = this.words.slice(0)), t;
                  },
                  random: function (t) {
                    for (var e = [], n = 0; n < t; n += 4) e.push(i());
                    return new l.init(e, t);
                  },
                })),
                c = (s.enc = {}),
                h = (c.Hex = {
                  stringify: function (t) {
                    for (
                      var e = t.words, n = t.sigBytes, i = [], r = 0;
                      r < n;
                      r++
                    ) {
                      var s = (e[r >>> 2] >>> (24 - (r % 4) * 8)) & 255;
                      i.push((s >>> 4).toString(16)),
                        i.push((15 & s).toString(16));
                    }
                    return i.join("");
                  },
                  parse: function (t) {
                    for (var e = t.length, n = [], i = 0; i < e; i += 2)
                      n[i >>> 3] |=
                        parseInt(t.substr(i, 2), 16) << (24 - (i % 8) * 4);
                    return new l.init(n, e / 2);
                  },
                }),
                u = (c.Latin1 = {
                  stringify: function (t) {
                    for (
                      var e = t.words, n = t.sigBytes, i = [], r = 0;
                      r < n;
                      r++
                    ) {
                      var s = (e[r >>> 2] >>> (24 - (r % 4) * 8)) & 255;
                      i.push(String.fromCharCode(s));
                    }
                    return i.join("");
                  },
                  parse: function (t) {
                    for (var e = t.length, n = [], i = 0; i < e; i++)
                      n[i >>> 2] |=
                        (255 & t.charCodeAt(i)) << (24 - (i % 4) * 8);
                    return new l.init(n, e);
                  },
                }),
                d = (c.Utf8 = {
                  stringify: function (t) {
                    try {
                      return decodeURIComponent(escape(u.stringify(t)));
                    } catch (e) {
                      throw new Error("Malformed UTF-8 data");
                    }
                  },
                  parse: function (t) {
                    return u.parse(unescape(encodeURIComponent(t)));
                  },
                }),
                p = (a.BufferedBlockAlgorithm = o.extend({
                  reset: function () {
                    (this._data = new l.init()), (this._nDataBytes = 0);
                  },
                  _append: function (t) {
                    "string" == typeof t && (t = d.parse(t)),
                      this._data.concat(t),
                      (this._nDataBytes += t.sigBytes);
                  },
                  _process: function (e) {
                    var n,
                      i = this._data,
                      r = i.words,
                      s = i.sigBytes,
                      a = this.blockSize,
                      o = s / (4 * a),
                      c =
                        (o = e
                          ? t.ceil(o)
                          : t.max((0 | o) - this._minBufferSize, 0)) * a,
                      h = t.min(4 * c, s);
                    if (c) {
                      for (var u = 0; u < c; u += a) this._doProcessBlock(r, u);
                      (n = r.splice(0, c)), (i.sigBytes -= h);
                    }
                    return new l.init(n, h);
                  },
                  clone: function () {
                    var t = o.clone.call(this);
                    return (t._data = this._data.clone()), t;
                  },
                  _minBufferSize: 0,
                }));
              a.Hasher = p.extend({
                cfg: o.extend(),
                init: function (t) {
                  (this.cfg = this.cfg.extend(t)), this.reset();
                },
                reset: function () {
                  p.reset.call(this), this._doReset();
                },
                update: function (t) {
                  return this._append(t), this._process(), this;
                },
                finalize: function (t) {
                  return t && this._append(t), this._doFinalize();
                },
                blockSize: 16,
                _createHelper: function (t) {
                  return function (e, n) {
                    return new t.init(n).finalize(e);
                  };
                },
                _createHmacHelper: function (t) {
                  return function (e, n) {
                    return new f.HMAC.init(t, n).finalize(e);
                  };
                },
              });
              var f = (s.algo = {});
              return s;
            })(Math)),
          t))),
      E.exports
    );
    var t;
  }
  var L,
    I = { exports: {} };
  function P() {
    return (
      L ||
        ((L = 1),
        (I.exports =
          ((t = C()),
          (function (e) {
            var n = t,
              i = n.lib,
              r = i.WordArray,
              s = i.Hasher,
              a = n.algo,
              o = [],
              l = [];
            !(function () {
              function t(t) {
                for (var n = e.sqrt(t), i = 2; i <= n; i++)
                  if (!(t % i)) return !1;
                return !0;
              }
              function n(t) {
                return (4294967296 * (t - (0 | t))) | 0;
              }
              for (var i = 2, r = 0; r < 64; )
                t(i) &&
                  (r < 8 && (o[r] = n(e.pow(i, 0.5))),
                  (l[r] = n(e.pow(i, 1 / 3))),
                  r++),
                  i++;
            })();
            var c = [],
              h = (a.SHA256 = s.extend({
                _doReset: function () {
                  this._hash = new r.init(o.slice(0));
                },
                _doProcessBlock: function (t, e) {
                  for (
                    var n = this._hash.words,
                      i = n[0],
                      r = n[1],
                      s = n[2],
                      a = n[3],
                      o = n[4],
                      h = n[5],
                      u = n[6],
                      d = n[7],
                      p = 0;
                    p < 64;
                    p++
                  ) {
                    if (p < 16) c[p] = 0 | t[e + p];
                    else {
                      var f = c[p - 15],
                        m =
                          ((f << 25) | (f >>> 7)) ^
                          ((f << 14) | (f >>> 18)) ^
                          (f >>> 3),
                        g = c[p - 2],
                        v =
                          ((g << 15) | (g >>> 17)) ^
                          ((g << 13) | (g >>> 19)) ^
                          (g >>> 10);
                      c[p] = m + c[p - 7] + v + c[p - 16];
                    }
                    var _ = (i & r) ^ (i & s) ^ (r & s),
                      y =
                        ((i << 30) | (i >>> 2)) ^
                        ((i << 19) | (i >>> 13)) ^
                        ((i << 10) | (i >>> 22)),
                      x =
                        d +
                        (((o << 26) | (o >>> 6)) ^
                          ((o << 21) | (o >>> 11)) ^
                          ((o << 7) | (o >>> 25))) +
                        ((o & h) ^ (~o & u)) +
                        l[p] +
                        c[p];
                    (d = u),
                      (u = h),
                      (h = o),
                      (o = (a + x) | 0),
                      (a = s),
                      (s = r),
                      (r = i),
                      (i = (x + (y + _)) | 0);
                  }
                  (n[0] = (n[0] + i) | 0),
                    (n[1] = (n[1] + r) | 0),
                    (n[2] = (n[2] + s) | 0),
                    (n[3] = (n[3] + a) | 0),
                    (n[4] = (n[4] + o) | 0),
                    (n[5] = (n[5] + h) | 0),
                    (n[6] = (n[6] + u) | 0),
                    (n[7] = (n[7] + d) | 0);
                },
                _doFinalize: function () {
                  var t = this._data,
                    n = t.words,
                    i = 8 * this._nDataBytes,
                    r = 8 * t.sigBytes;
                  return (
                    (n[r >>> 5] |= 128 << (24 - (r % 32))),
                    (n[14 + (((r + 64) >>> 9) << 4)] = e.floor(i / 4294967296)),
                    (n[15 + (((r + 64) >>> 9) << 4)] = i),
                    (t.sigBytes = 4 * n.length),
                    this._process(),
                    this._hash
                  );
                },
                clone: function () {
                  var t = s.clone.call(this);
                  return (t._hash = this._hash.clone()), t;
                },
              }));
            (n.SHA256 = s._createHelper(h)),
              (n.HmacSHA256 = s._createHmacHelper(h));
          })(Math),
          t.SHA256))),
      I.exports
    );
    var t;
  }
  var U,
    N,
    O,
    D,
    F,
    B = { exports: {} };
  w.exports = (function (t) {
    return t.HmacSHA256;
  })(
    C(),
    P(),
    U ||
      ((U = 1),
      (B.exports =
        ((N = C()),
        (D = (O = N).lib.Base),
        (F = O.enc.Utf8),
        void (O.algo.HMAC = D.extend({
          init: function (t, e) {
            (t = this._hasher = new t.init()),
              "string" == typeof e && (e = F.parse(e));
            var n = t.blockSize,
              i = 4 * n;
            e.sigBytes > i && (e = t.finalize(e)), e.clamp();
            for (
              var r = (this._oKey = e.clone()),
                s = (this._iKey = e.clone()),
                a = r.words,
                o = s.words,
                l = 0;
              l < n;
              l++
            )
              (a[l] ^= 1549556828), (o[l] ^= 909522486);
            (r.sigBytes = s.sigBytes = i), this.reset();
          },
          reset: function () {
            var t = this._hasher;
            t.reset(), t.update(this._iKey);
          },
          update: function (t) {
            return this._hasher.update(t), this;
          },
          finalize: function (t) {
            var e = this._hasher,
              n = e.finalize(t);
            return e.reset(), e.finalize(this._oKey.clone().concat(n));
          },
        }))))),
  );
  const z = b(w.exports);
  var k = { exports: {} };
  !(function (t, e) {
    t.exports = (function (t) {
      return (
        (function () {
          var e = t,
            n = e.lib.WordArray;
          function i(t, e, i) {
            for (var r = [], s = 0, a = 0; a < e; a++)
              if (a % 4) {
                var o =
                  (i[t.charCodeAt(a - 1)] << ((a % 4) * 2)) |
                  (i[t.charCodeAt(a)] >>> (6 - (a % 4) * 2));
                (r[s >>> 2] |= o << (24 - (s % 4) * 8)), s++;
              }
            return n.create(r, s);
          }
          e.enc.Base64 = {
            stringify: function (t) {
              var e = t.words,
                n = t.sigBytes,
                i = this._map;
              t.clamp();
              for (var r = [], s = 0; s < n; s += 3)
                for (
                  var a =
                      (((e[s >>> 2] >>> (24 - (s % 4) * 8)) & 255) << 16) |
                      (((e[(s + 1) >>> 2] >>> (24 - ((s + 1) % 4) * 8)) &
                        255) <<
                        8) |
                      ((e[(s + 2) >>> 2] >>> (24 - ((s + 2) % 4) * 8)) & 255),
                    o = 0;
                  o < 4 && s + 0.75 * o < n;
                  o++
                )
                  r.push(i.charAt((a >>> (6 * (3 - o))) & 63));
              var l = i.charAt(64);
              if (l) for (; r.length % 4; ) r.push(l);
              return r.join("");
            },
            parse: function (t) {
              var e = t.length,
                n = this._map,
                r = this._reverseMap;
              if (!r) {
                r = this._reverseMap = [];
                for (var s = 0; s < n.length; s++) r[n.charCodeAt(s)] = s;
              }
              var a = n.charAt(64);
              if (a) {
                var o = t.indexOf(a);
                -1 !== o && (e = o);
              }
              return i(t, e, r);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          };
        })(),
        t.enc.Base64
      );
    })(C());
  })(k);
  const H = b(k.exports),
    G = j;
  !(function (t, e) {
    const n = j,
      i = t();
    for (;;)
      try {
        if (
          784208 ===
          -parseInt(n(490)) / 1 +
            (-parseInt(n(514)) / 2) * (parseInt(n(424)) / 3) +
            (-parseInt(n(478)) / 4) * (-parseInt(n(417)) / 5) +
            (-parseInt(n(432)) / 6) * (-parseInt(n(454)) / 7) +
            -parseInt(n(494)) / 8 +
            (parseInt(n(515)) / 9) * (parseInt(n(469)) / 10) +
            parseInt(n(437)) / 11
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(q);
  const V = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n[j(450)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    W = V(globalThis, function () {
      const t = j;
      return W[t(471)]()
        .search("(((.+)+)+)+$")
        .toString()
        [t(399)](W)
        [t(456)](t(472));
    });
  function j(t, e) {
    const n = q();
    return (j = function (t, e) {
      return n[(t -= 394)];
    })(t, e);
  }
  W();
  class X {
    constructor(t) {
      const e = j;
      (this[e(445)] = ""),
        (this[e(434)] = ""),
        (this[e(463)] = { actionConfigPath: e(441), gptPath: e(413) }),
        (this[e(475)] = ""),
        (this.chatId = m[e(420)]()),
        (this[e(396)] = "close"),
        (this[e(458)] = new Map()),
        (this[e(395)] = ""),
        (this.signatureMap = new Map()),
        (this.signatureValidTime = 27e4),
        (this[e(510)] = { txtArr: [] }),
        (this[e(426)] = ""),
        (this[e(488)] = null == t ? void 0 : t[e(488)]),
        (this[e(482)] = null == t ? void 0 : t[e(482)]);
    }
    [G(444)](t, e = "") {
      return c(this, null, function* () {
        const n = G;
        if (this.signatureMap[n(412)](t)) {
          const { signatureStr: e, timestamp: i } = this[n(436)][n(435)](t);
          if (Date[n(479)]() - i < this.signatureValidTime) return e;
        }
        const i = Date[n(479)](),
          r = Math[n(512)](i * Math.random()),
          s = "55aa6ea7-ddd2-4c02-a1c2-fd3fbacf2310"[n(480)]("");
        return yield fetch(m.cloudFuncOrigin + "/vmapi/web/signature", {
          method: n(460),
          body: JSON[n(491)]({
            Header: {},
            Payload: { Path: t, MessageStr: this[n(488)], SearchStr: e },
          }),
          headers: {
            "Content-Type": n(508),
            web: window[n(414)](
              i - r + "_" + s[(i - r) % s[n(457)]] + s[r % s[n(457)]] + "_" + r,
            ),
          },
        })
          [n(468)]((t) => t.json())
          [n(468)]((t) => {
            const e = n;
            try {
              const { Path: n, SearchStr: i } = t[e(431)],
                r = /appkey=([^&]+)/i.exec(i);
              !this[e(502)] && r && (this[e(502)] = r[1]);
              const s = n + "?" + i;
              return (
                this[e(436)][e(518)](n, {
                  signatureStr: s,
                  timestamp: Date[e(479)](),
                }),
                s
              );
            } catch (i) {
              return "";
            }
          });
      });
    }
    [G(505)](t = "") {
      const e = G,
        n = e(505);
      try {
        const i = new URLSearchParams(t);
        i.delete(n),
          i.append(e(402), this[e(502)]),
          i[e(473)](e(398), Math[e(507)](Date[e(479)]() / 1e3) + ""),
          i.sort();
        const r = z(i[e(471)](), this[e(481)])[e(471)](H);
        return i[e(473)](n, r), i[e(471)]();
      } catch (i) {
        return console[e(465)](e(452), i), "";
      }
    }
    [G(440)](t) {
      const e = G;
      if (t) {
        const n = window.atob(t),
          i = n[e(457)],
          r = new Uint8Array(i);
        for (let t = 0; t < i; t++) r[t] = n[e(448)](t);
        return r[e(451)];
      }
      return null;
    }
    post(t) {
      return c(this, null, function* () {
        const e = G,
          { url: n, bodyStr: i } = t;
        return yield fetch(n, {
          method: e(460),
          body: i,
          headers: { "Content-Type": e(508) },
        })
          [e(468)]((t) => t[e(433)]())
          [e(468)]((t) => {
            const i = e;
            return t[i(400)][i(495)] > 0
              ? (this[i(458)][i(412)](i(465)) &&
                  this.eventMap[i(435)](i(465))({
                    code: 2003,
                    message: n + ": " + t[i(400)].Message,
                  }),
                null)
              : this[i(466)](t);
          })
          [e(470)]((t) => {
            const i = e;
            return (
              this.eventMap[i(412)](i(465)) &&
                this[i(458)][i(435)]("error")({
                  code: 2003,
                  message: n + ": " + t[i(471)](),
                }),
              null
            );
          });
      });
    }
    [G(466)](t) {
      const e = G;
      if (typeof t !== e(447) || null === t) return t;
      if (Array[e(439)](t)) return t[e(394)]((t) => this[e(466)](t));
      const n = {};
      for (let i in t)
        if (t[e(484)](i)) {
          n[i[e(419)](0)[e(497)]() + i.slice(1)] = this[e(466)](t[i]);
        }
      return n;
    }
    [G(408)]() {
      return c(this, null, function* () {
        const t = G,
          e = this[t(463)][t(407)];
        let n;
        const i = this[t(434)] || m[t(434)],
          r = t(487) + m[t(420)]() + "&Language=" + m[t(474)];
        return (
          (n = this.accessToken
            ? "" + i + e + "?" + this[t(505)](r)
            : "" + i + (yield this[t(444)](e, r))),
          yield new Promise((e) => {
            const i = t;
            (this.ws = new WebSocket(n)),
              (this.ws.onmessage = (t) => {
                const e = j;
                this.socketResult(t[e(406)]);
              }),
              (this.ws.onerror = function (t) {
                const e = j;
                console.error(e(462), t);
              }),
              (this.ws[i(453)] = () => {
                var t, n;
                const r = i;
                (this.wsStatus = r(430)),
                  e(!0),
                  (null ==
                  (n =
                    null ==
                    (t =
                      this[r(510)].txtArr[this.streamObj[r(405)][r(457)] - 1])
                      ? void 0
                      : t[r(517)])
                    ? void 0
                    : n.isFinal) && this[r(513)]("");
              }),
              (this.ws[i(467)] = () => {
                const t = i;
                (this[t(396)] = t(404)), e(!1);
              });
          })
            [t(468)]((t) => !0)
            [t(470)]((e) => {
              const n = t;
              return console.error(n(462), e), Promise.resolve(!1);
            })
        );
      });
    }
    [G(428)](t) {
      const e = G;
      try {
        const n = this[e(466)](JSON.parse(t));
        if (0 !== n[e(464)][e(477)]) {
          if (n[e(464)][e(422)] === e(516)) return;
          return (
            this.eventMap.has("error") &&
            this[e(458)].get(e(465))({ code: 2002, message: n[e(464)].message })
          );
        }
        const { errorCode: i, errorMessage: r, reqId: s } = n[e(509)];
        if (0 !== i)
          return (
            this[e(458)][e(412)]("error") &&
            this[e(458)][e(435)](e(465))({ code: 2002, message: r })
          );
        if (s !== this[e(475)]) return;
        switch (n[e(509)][e(446)]) {
          case "SPEECH": {
            let {
              action: t,
              audio: s,
              thFeat: a,
              thDim: o,
              final: l,
              thFeatFinal: c,
              seqNo: h,
            } = n[e(509)][e(504)];
            void 0 !== i &&
              0 !== i &&
              (this[e(458)][e(412)](e(465)) &&
                this.eventMap[e(435)](e(465))({ code: 2002, message: r }),
              (s = null),
              (l = !0)),
              this[e(458)][e(412)](e(416)) &&
                this.eventMap[e(435)]("tts_bs")({
                  code: 0,
                  data: {
                    featArr: a,
                    actionArr: t,
                    featDim: o,
                    featFinal: c,
                    seqNo: h,
                  },
                }),
              this[e(458)].has(e(423)) &&
                this[e(458)][e(435)](e(423))({
                  code: 0,
                  data: { audioData: this.base64ToArrayBuffer(s), final: l },
                });
            break;
          }
          case e(486):
            n[e(509)][e(443)][e(511)] != e(496) &&
              (this[e(395)] += n[e(509)].replyRsp[e(499)]),
              this[e(458)][e(412)](e(455)) &&
                this[e(458)][e(435)](e(455))({
                  code: 0,
                  data: l({}, n[e(509)].replyRsp),
                });
        }
      } catch (n) {
        this[e(458)].has(e(465)) &&
          this[e(458)][e(435)](e(465))({ code: 2002, message: n[e(471)]() });
      }
    }
    [G(410)](t) {
      return t ? t[G(411)](/<([^>]+)>/gi, () => "") : "";
    }
    on(t, e) {
      const n = G;
      if (e)
        switch (t) {
          case "tts_audio":
          case n(416):
          case n(455):
          case n(465):
            this.eventMap[n(518)](t, (...t) => {
              try {
                e(...t);
              } catch (n) {}
            });
        }
    }
    [G(425)](t) {
      return c(this, null, function* () {
        const e = G;
        let n;
        const i = this[e(445)] || m[e(445)];
        n = this[e(481)]
          ? "" +
            i +
            this.pathObj[e(449)] +
            "?" +
            this.signature(e(487) + m.generateUUID())
          : "" +
            i +
            (yield this.getSignatureStr(
              this.pathObj[e(449)],
              "requestid=" + m.generateUUID(),
            ));
        return yield this[e(438)]({
          url: n,
          bodyStr: JSON[e(491)]({
            Header: {},
            Payload: { VirtualmanKey: this[e(482)], Type: e(409), Reply: t },
          }),
        });
      });
    }
    [G(513)](t, e) {
      return c(this, null, function* () {
        const n = G;
        if (null == e ? void 0 : e[n(476)])
          if (1 === (null == e ? void 0 : e.seqNo))
            (this[n(510)][n(405)] = []),
              (this[n(475)] = null == e ? void 0 : e[n(421)]);
          else if (this[n(475)] !== (null == e ? void 0 : e.streamId)) return;
        if (this[n(396)] !== n(430)) {
          if (null == e ? void 0 : e[n(476)])
            return (
              1 === (null == e ? void 0 : e[n(501)]) && this.initSocket(),
              void this[n(510)][n(405)][n(415)]({ txt: t, opt: e })
            );
          yield this[n(408)]();
        }
        if ("close" === this[n(396)])
          return (
            this[n(458)][n(412)](n(465)) &&
            this[n(458)][n(435)](n(465))({
              code: 2001,
              message: m[n(397)](n(498)),
            })
          );
        for (
          (null == e ? void 0 : e[n(476)])
            ? (this[n(426)] = n(503))
            : (this[n(426)] = "text");
          this[n(510)].txtArr[n(457)];

        ) {
          const t = this[n(510)][n(405)].shift();
          this[n(520)](t[n(442)], t[n(517)]);
        }
        (t || (null == e ? void 0 : e[n(476)])) && this[n(520)](t, e);
      });
    }
    [G(520)](t, e) {
      var n;
      const i = G;
      !(null == e ? void 0 : e[i(476)]) && (this[i(475)] = m[i(420)]());
      const r = {
        Header: {},
        Payload: {
          VirtualmanProjectId: this.virtualmanKey,
          InputText: t,
          ReqId: this[i(475)],
          StreamId: this[i(493)],
          DriverType: (null == e ? void 0 : e[i(476)]) ? i(418) : "TEXT",
          InputTextType: (null == e ? void 0 : e[i(476)]) ? i(506) : i(519),
          Seq: (null == e ? void 0 : e[i(476)]) ? e.seqNo : 0,
          IsFinal: !!(null == e ? void 0 : e[i(476)]) && e[i(401)],
          SpeechParam: {
            SmartActionEnabled: null == e[i(500)] || e.smartActionEnabled,
          },
        },
      };
      null == (n = this.ws) || n[i(461)](JSON[i(491)](r)),
        (!(null == e ? void 0 : e[i(476)]) ||
          ((null == e ? void 0 : e[i(476)]) &&
            1 === (null == e ? void 0 : e.seqNo))) &&
          (this[i(395)] = "");
    }
    [G(455)](t, e) {
      return c(this, null, function* () {
        var n;
        const i = G;
        if (
          ("open" !== this[i(396)] && (yield this[i(408)]()),
          this.wsStatus === i(404))
        )
          return (
            this.eventMap[i(412)]("error") &&
            this[i(458)][i(435)](i(465))({
              code: 2001,
              message: m[i(397)](i(498)),
            })
          );
        (this.sendStatus = i(485)),
          e[i(429)] && (this[i(493)] = m[i(420)]()),
          (this[i(475)] = m.generateUUID());
        const r = {
          Header: {},
          Payload: {
            VirtualmanProjectId: this[i(482)],
            InputText: t,
            ReqId: this.sessionId,
            StreamId: e[i(403)] ? e[i(403)] : this.chatId,
            DriverType: i(483),
            SpeechParam: {
              SmartActionEnabled:
                null == e.smartActionEnabled || e.smartActionEnabled,
            },
          },
        };
        null == (n = this.ws) || n[i(461)](JSON.stringify(r)),
          (this.ttsTxt = "");
      });
    }
    [G(427)](t) {
      var e, n;
      const i = G;
      (this[i(502)] =
        null == (e = null == t ? void 0 : t.appKey) ? void 0 : e[i(492)]()),
        (this.accessToken =
          null == (n = null == t ? void 0 : t.accessToken)
            ? void 0
            : n[i(492)]()),
        (null == t ? void 0 : t[i(445)]) &&
          (this[i(445)] = t.httpOrigin[i(492)]()),
        (null == t ? void 0 : t.wsOrigin) &&
          (this[i(434)] = t[i(434)][i(492)]());
    }
    stop() {
      var t, e;
      const n = G;
      this[n(396)] === n(430) &&
        (this[n(426)] === n(485)
          ? null == (t = this.ws) ||
            t[n(461)](
              JSON[n(491)]({
                Header: {},
                Payload: {
                  VirtualmanProjectId: this[n(482)],
                  InputText: "",
                  ReqId: this[n(475)],
                  StreamId: this[n(493)],
                  DriverType: n(483),
                  ChatCommand: n(489),
                },
              }),
            )
          : this[n(426)] === n(503) &&
            (null == (e = this.ws) ||
              e.send(
                JSON[n(491)]({
                  Header: {},
                  Payload: {
                    VirtualmanProjectId: this.virtualmanKey,
                    InputText: n(459),
                    ReqId: this[n(475)],
                    StreamId: this[n(493)],
                    DriverType: n(418),
                    Seq: 9999,
                    IsFinal: !0,
                  },
                }),
              ))),
        (this[n(426)] = ""),
        (this[n(475)] = m[n(420)]());
    }
  }
  function q() {
    const t = [
      "initSocket",
      "command",
      "extractText",
      "replace",
      "has",
      "/v2/ws/ivh/interactdriver/interactdriverservice/driverengine",
      "btoa",
      "push",
      "tts_bs",
      "167035wGjzTY",
      "STREAM_TEXT",
      "charAt",
      "generateUUID",
      "streamId",
      "message",
      "tts_audio",
      "82509xRVfGF",
      "getActionConfig",
      "sendStatus",
      "setPrivatization",
      "socketResult",
      "isNew",
      "open",
      "Payload",
      "600gKzrlF",
      "json",
      "wsOrigin",
      "get",
      "signatureMap",
      "7222996cLKMLl",
      "post",
      "isArray",
      "base64ToArrayBuffer",
      "/v2/ivh/virtualmanconfig/virtualmanconfigopen/describeactionconfigcommanddetail",
      "txt",
      "replyRsp",
      "getSignatureStr",
      "httpOrigin",
      "driverRspType",
      "object",
      "charCodeAt",
      "actionConfigPath",
      "apply",
      "buffer",
      "加密错误:",
      "onopen",
      "30205PFaCcr",
      "nlp",
      "search",
      "length",
      "eventMap",
      "end",
      "POST",
      "send",
      "socket error:",
      "pathObj",
      "header",
      "error",
      "convertObjectKeysToLowercase",
      "onclose",
      "then",
      "410JcFTNj",
      "catch",
      "toString",
      "(((.+)+)+)+$",
      "append",
      "language",
      "sessionId",
      "isStream",
      "code",
      "148XBCUXY",
      "now",
      "split",
      "accessToken",
      "virtualmanKey",
      "CHAT",
      "hasOwnProperty",
      "chat",
      "REPLY",
      "requestid=",
      "sign",
      "STOP_CHAT",
      "1354838dvJNoJ",
      "stringify",
      "trim",
      "chatId",
      "4661520UpOdXy",
      "Code",
      "cloudAiWaiting",
      "toLowerCase",
      "2001",
      "replyDisplay",
      "smartActionEnabled",
      "seqNo",
      "appKey",
      "text_stream",
      "speechRsp",
      "signature",
      "MARKDOWN",
      "ceil",
      "application/json",
      "payload",
      "streamObj",
      "replyType",
      "round",
      "tts",
      "32tdpLuv",
      "183861AHVBbh",
      "pong frame",
      "opt",
      "set",
      "SSML",
      "ttsSend",
      "map",
      "ttsTxt",
      "wsStatus",
      "getError",
      "timestamp",
      "constructor",
      "Header",
      "isFinal",
      "appkey",
      "userId",
      "close",
      "txtArr",
      "data",
      "gptPath",
    ];
    return (q = function () {
      return t;
    })();
  }
  function Y(t, e) {
    const n = $();
    return (Y = function (t, e) {
      return n[(t -= 437)];
    })(t, e);
  }
  const K = Y;
  !(function (t, e) {
    const n = Y,
      i = t();
    for (;;)
      try {
        if (
          529758 ===
          (parseInt(n(522)) / 1) * (parseInt(n(513)) / 2) +
            parseInt(n(503)) / 3 +
            (parseInt(n(498)) / 4) * (-parseInt(n(459)) / 5) +
            -parseInt(n(440)) / 6 +
            -parseInt(n(523)) / 7 +
            -parseInt(n(484)) / 8 +
            parseInt(n(526)) / 9
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })($);
  const Z = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    J = Z(globalThis, function () {
      const t = Y;
      return J.toString()
        .search("(((.+)+)+)+$")
        [t(506)]()
        .constructor(J)
        [t(497)](t(517));
    });
  function $() {
    const t = [
      "destinationNode",
      "AudioContext",
      "clear",
      "currentTime",
      "init",
      "channels",
      "flushThreshold",
      "gain",
      "max",
      "mergeSamples",
      "maxTimeDrift",
      "continue",
      "add",
      "destroy",
      "feed",
      "close",
      "typedArray",
      "getRecordAudioStream",
      "7794288wfvogP",
      "disconnect",
      "sampleRate",
      "bindAudioContextEvent",
      "setStartFunc",
      "webkitAudioContext",
      "value",
      "activeSources",
      "function",
      "createBuffer",
      "triggerPlaybackEnd",
      "duration",
      "error",
      "search",
      "20zivRFY",
      "Int16",
      "createAudioBuffer",
      "Unsupported codec",
      "flush",
      "561231IVaqZW",
      "getTypedArray",
      "getFormatedValue",
      "toString",
      "stream",
      "flushPending",
      "length",
      "getConvertValue",
      "assign",
      "suspended",
      "2vSuUVE",
      "isLastBuffer",
      "ensureAudioContextActive",
      "getChannelData",
      "(((.+)+)+)+$",
      "catch",
      "onended",
      "isEnd",
      "shouldFlush",
      "81179SKMMKI",
      "7310282gfnvYy",
      "endSignaled",
      "inputCodec",
      "26872092gkNqeI",
      "convertValue",
      "byteLength",
      "createGain",
      "onstarted",
      "lastFlushTime",
      "2167794hvplLF",
      "isTypedArray",
      "suspend",
      "forEach",
      "playback",
      "option",
      "onstatechange",
      "不支持的数据格式",
      "playEndFunc",
      "volume",
      "destination",
      "initAudioContext",
      "samples",
      "size",
      "now",
      "gainNode",
      "buffer",
      "resume",
      "connect",
      "344375RFVFKo",
      "createBufferSource",
      "start",
      "startTime",
      "audioCtx",
      "set",
      "isSupported",
    ];
    return ($ = function () {
      return t;
    })();
  }
  J();
  class Q {
    constructor(t) {
      const e = Y;
      (this[e(466)] = null),
        (this.activeSources = new Set()),
        (this.flushPending = !1),
        (this[e(439)] = 0),
        (this[e(524)] = !1),
        this[e(470)](t);
    }
    [K(470)](t) {
      const e = K,
        n = {
          inputCodec: e(499),
          channels: 1,
          sampleRate: 8e3,
          flushThreshold: 0.5,
          maxTimeDrift: 0.8,
        };
      (this[e(445)] = Object[e(511)]({}, n, t)),
        (this.samples = new Float32Array()),
        (this[e(527)] = this[e(510)]()),
        (this[e(482)] = this[e(504)]()),
        this[e(451)](),
        this.bindAudioContextEvent();
    }
    [K(480)](t, e) {
      const n = K;
      if (this[n(463)] && ((this[n(520)] = e), t)) {
        this[n(465)](t);
        const e = this[n(505)](t);
        this[n(475)](e), this[n(521)]() && this[n(502)]();
      }
    }
    mergeSamples(t) {
      const e = K,
        n = new Float32Array(this[e(452)].length + t[e(509)]);
      n.set(this[e(452)]),
        n[e(464)](t, this[e(452)][e(509)]),
        (this[e(452)] = n);
    }
    shouldFlush() {
      const t = K,
        e = this[t(445)][t(486)] * this.option[t(471)] * this[t(445)][t(472)],
        n = (performance[t(454)]() - this[t(439)]) / 1e3 > this[t(445)][t(476)];
      return (
        this[t(452)][t(509)] >= e ||
        this[t(520)] ||
        (n && this[t(452)].length > 0)
      );
    }
    [K(502)]() {
      return c(this, null, function* () {
        const t = K;
        try {
          if (!this[t(452)][t(509)]) return;
          if (this[t(508)]) return;
          this.flushPending = !0;
          const e = this[t(452)];
          (this[t(452)] = new Float32Array()), yield this[t(515)]();
          const n = this[t(463)][t(460)]();
          this[t(491)][t(478)](n),
            (n[t(519)] = () => {
              const e = t;
              n[e(485)](),
                this[e(491)].delete(n),
                this[e(514)]() && !this.endSignaled && this[e(494)]();
            });
          const i = this[t(500)](e);
          (n[t(456)] = i), n[t(458)](this.gainNode);
          const r = this[t(463)][t(469)];
          (this.startTime = Math[t(474)](r, this[t(462)])),
            n[t(461)](this.startTime),
            (this[t(462)] += i[t(495)]),
            (this[t(439)] = performance[t(454)]());
        } catch (e) {
          yield this.recoverFromError();
        } finally {
          (this[t(508)] = !1),
            this[t(521)]() &&
              requestAnimationFrame(() => {
                this[t(502)]();
              });
        }
      });
    }
    [K(514)]() {
      const t = K;
      return (
        this.isEnd && 0 === this[t(452)][t(509)] && 0 === this[t(491)][t(453)]
      );
    }
    [K(494)]() {
      var t, e;
      const n = K;
      (this[n(524)] = !0),
        null == (e = (t = this[n(445)])[n(519)]) || e.call(t);
    }
    [K(500)](t) {
      const e = K,
        n = t.length / this[e(445)][e(471)],
        i = this[e(463)][e(493)](
          this[e(445)][e(471)],
          n,
          this[e(445)].sampleRate,
        );
      for (let r = 0; r < this[e(445)][e(471)]; r++) {
        const s = i[e(516)](r);
        for (let i = 0; i < n; i++) s[i] = t[i * this[e(445)][e(471)] + r];
      }
      return i;
    }
    ensureAudioContextActive() {
      return c(this, null, function* () {
        const t = K;
        this.audioCtx.state === t(512) && (yield this[t(463)][t(457)]());
      });
    }
    recoverFromError() {
      return c(this, null, function* () {
        const t = K;
        this[t(479)](),
          yield new Promise((t) => setTimeout(t, 500)),
          this[t(470)](this.option);
      });
    }
    [K(510)]() {
      const t = K,
        e = { Int8: 128, Int16: 32768, Int32: 2147483648, Float32: 1 };
      if (!e[this[t(445)][t(525)]]) throw new Error(t(501));
      return e[this[t(445)][t(525)]];
    }
    [K(504)]() {
      const t = K,
        e = {
          Int8: Int8Array,
          Int16: Int16Array,
          Int32: Int32Array,
          Float32: Float32Array,
        };
      if (!e[this[t(445)][t(525)]]) throw new Error(t(501));
      return e[this.option[t(525)]];
    }
    [K(451)]() {
      var t;
      const e = K;
      try {
        this[e(463)] = new (window[e(467)] || window[e(489)])({
          latencyHint: e(444),
          sampleRate: this[e(445)][e(486)],
        });
      } catch (n) {
        throw n;
      }
      (this[e(455)] = this[e(463)][e(437)]()),
        (this[e(455)][e(473)].value = 1),
        (null == (t = this[e(445)]) ? void 0 : t.isRecord)
          ? ((this[e(466)] = this[e(463)].createMediaStreamDestination()),
            this[e(455)].connect(this[e(466)]))
          : this.gainNode[e(458)](this[e(463)][e(450)]),
        (this.startTime = this[e(463)][e(469)]);
    }
    [K(479)]() {
      const t = K;
      this.activeSources[t(443)]((e) => {
        const n = t;
        e.stop(), e[n(485)]();
      }),
        this[t(491)][t(468)](),
        this[t(463)] &&
          this.audioCtx[t(481)]()[t(518)]((e) => {
            console[t(496)]("关闭AudioContext失败:", e);
          });
    }
    [K(465)](t) {
      const e = K;
      if (!Q[e(441)](t)) throw new Error(e(447));
    }
    [K(505)](t) {
      const e = K,
        n =
          t instanceof ArrayBuffer
            ? new this[e(482)](t)
            : new this[e(482)](t.buffer),
        i = new Float32Array(n[e(509)]);
      for (let r = 0; r < n[e(509)]; r++) i[r] = n[r] / this[e(527)];
      return i;
    }
    [K(449)](t) {
      const e = K;
      this[e(455)][e(473)][e(490)] = t;
    }
    [K(483)]() {
      var t;
      const e = K;
      return null == (t = this[e(466)]) ? void 0 : t[e(507)];
    }
    static [K(441)](t) {
      return (
        (t[K(528)] && t.buffer instanceof ArrayBuffer) ||
        t instanceof ArrayBuffer
      );
    }
    [K(487)]() {
      const t = K;
      typeof this[t(445)][t(446)] === t(492) &&
        (this[t(463)][t(446)] = (e) => {
          const n = t;
          this[n(445)].onstatechange(this[n(463)], e, this[n(463)].state);
        });
    }
    pause() {
      return c(this, null, function* () {
        const t = K;
        yield this[t(463)][t(442)]();
      });
    }
    [K(477)]() {
      return c(this, null, function* () {
        const t = K;
        yield this.audioCtx[t(457)]();
      });
    }
    setEndFunc(t) {
      const e = K;
      this[e(445)][e(519)] = t;
    }
    [K(488)](t) {
      const e = K;
      this[e(445)][e(438)] = t;
    }
    [K(448)]() {
      var t, e;
      const n = K;
      null == (e = (t = this.option)[n(519)]) || e.call(t);
    }
  }
  const tt = "155",
    et = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
    nt = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
    it = 1,
    rt = 2,
    st = 3,
    at = 0,
    ot = 1,
    lt = 100,
    ct = 0,
    ht = 1,
    ut = 2,
    dt = 0,
    pt = 1,
    ft = 2,
    mt = 3,
    gt = 4,
    vt = 5,
    _t = 300,
    yt = 301,
    xt = 302,
    Mt = 303,
    St = 304,
    bt = 306,
    Tt = 1e3,
    wt = 1001,
    Et = 1002,
    At = 1003,
    Rt = 1004,
    Ct = 1005,
    Lt = 1006,
    It = 1007,
    Pt = 1008,
    Ut = 1009,
    Nt = 1012,
    Ot = 1013,
    Dt = 1014,
    Ft = 1015,
    Bt = 1016,
    zt = 1017,
    kt = 1018,
    Ht = 1020,
    Gt = 1023,
    Vt = 1026,
    Wt = 1027,
    jt = 1029,
    Xt = 1031,
    qt = 1033,
    Yt = 33776,
    Kt = 33777,
    Zt = 33778,
    Jt = 33779,
    $t = 35840,
    Qt = 35841,
    te = 35842,
    ee = 35843,
    ne = 37492,
    ie = 37496,
    re = 37808,
    se = 37809,
    ae = 37810,
    oe = 37811,
    le = 37812,
    ce = 37813,
    he = 37814,
    ue = 37815,
    de = 37816,
    pe = 37817,
    fe = 37818,
    me = 37819,
    ge = 37820,
    ve = 37821,
    _e = 36492,
    ye = 36284,
    xe = 36285,
    Me = 36286,
    Se = 2200,
    be = 2300,
    Te = 2301,
    we = 2302,
    Ee = 2400,
    Ae = 2401,
    Re = 2402,
    Ce = 2500,
    Le = 2501,
    Ie = 3e3,
    Pe = 3001,
    Ue = "",
    Ne = "srgb",
    Oe = "srgb-linear",
    De = "display-p3",
    Fe = 7680,
    Be = 35044,
    ze = "300 es",
    ke = 1035,
    He = 2e3,
    Ge = 2001;
  class Ve {
    addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});
      const n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    }
    hasEventListener(t, e) {
      if (void 0 === this._listeners) return !1;
      const n = this._listeners;
      return void 0 !== n[t] && -1 !== n[t].indexOf(e);
    }
    removeEventListener(t, e) {
      if (void 0 === this._listeners) return;
      const n = this._listeners[t];
      if (void 0 !== n) {
        const t = n.indexOf(e);
        -1 !== t && n.splice(t, 1);
      }
    }
    dispatchEvent(t) {
      if (void 0 === this._listeners) return;
      const e = this._listeners[t.type];
      if (void 0 !== e) {
        t.target = this;
        const n = e.slice(0);
        for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
        t.target = null;
      }
    }
  }
  const We = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ];
  let je = 1234567;
  const Xe = Math.PI / 180,
    qe = 180 / Math.PI;
  function Ye() {
    const t = (4294967295 * Math.random()) | 0,
      e = (4294967295 * Math.random()) | 0,
      n = (4294967295 * Math.random()) | 0,
      i = (4294967295 * Math.random()) | 0;
    return (
      We[255 & t] +
      We[(t >> 8) & 255] +
      We[(t >> 16) & 255] +
      We[(t >> 24) & 255] +
      "-" +
      We[255 & e] +
      We[(e >> 8) & 255] +
      "-" +
      We[((e >> 16) & 15) | 64] +
      We[(e >> 24) & 255] +
      "-" +
      We[(63 & n) | 128] +
      We[(n >> 8) & 255] +
      "-" +
      We[(n >> 16) & 255] +
      We[(n >> 24) & 255] +
      We[255 & i] +
      We[(i >> 8) & 255] +
      We[(i >> 16) & 255] +
      We[(i >> 24) & 255]
    ).toLowerCase();
  }
  function Ke(t, e, n) {
    return Math.max(e, Math.min(n, t));
  }
  function Ze(t, e) {
    return ((t % e) + e) % e;
  }
  function Je(t, e, n) {
    return (1 - n) * t + n * e;
  }
  function $e(t) {
    return 0 == (t & (t - 1)) && 0 !== t;
  }
  function Qe(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
  }
  function tn(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
  }
  function en(t, e) {
    switch (e.constructor) {
      case Float32Array:
        return t;
      case Uint32Array:
        return t / 4294967295;
      case Uint16Array:
        return t / 65535;
      case Uint8Array:
        return t / 255;
      case Int32Array:
        return Math.max(t / 2147483647, -1);
      case Int16Array:
        return Math.max(t / 32767, -1);
      case Int8Array:
        return Math.max(t / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function nn(t, e) {
    switch (e.constructor) {
      case Float32Array:
        return t;
      case Uint32Array:
        return Math.round(4294967295 * t);
      case Uint16Array:
        return Math.round(65535 * t);
      case Uint8Array:
        return Math.round(255 * t);
      case Int32Array:
        return Math.round(2147483647 * t);
      case Int16Array:
        return Math.round(32767 * t);
      case Int8Array:
        return Math.round(127 * t);
      default:
        throw new Error("Invalid component type.");
    }
  }
  const rn = {
    DEG2RAD: Xe,
    RAD2DEG: qe,
    generateUUID: Ye,
    clamp: Ke,
    euclideanModulo: Ze,
    mapLinear: function (t, e, n, i, r) {
      return i + ((t - e) * (r - i)) / (n - e);
    },
    inverseLerp: function (t, e, n) {
      return t !== e ? (n - t) / (e - t) : 0;
    },
    lerp: Je,
    damp: function (t, e, n, i) {
      return Je(t, e, 1 - Math.exp(-n * i));
    },
    pingpong: function (t, e = 1) {
      return e - Math.abs(Ze(t, 2 * e) - e);
    },
    smoothstep: function (t, e, n) {
      return t <= e
        ? 0
        : t >= n
        ? 1
        : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
    },
    smootherstep: function (t, e, n) {
      return t <= e
        ? 0
        : t >= n
        ? 1
        : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
    },
    randInt: function (t, e) {
      return t + Math.floor(Math.random() * (e - t + 1));
    },
    randFloat: function (t, e) {
      return t + Math.random() * (e - t);
    },
    randFloatSpread: function (t) {
      return t * (0.5 - Math.random());
    },
    seededRandom: function (t) {
      void 0 !== t && (je = t);
      let e = (je += 1831565813);
      return (
        (e = Math.imul(e ^ (e >>> 15), 1 | e)),
        (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
        ((e ^ (e >>> 14)) >>> 0) / 4294967296
      );
    },
    degToRad: function (t) {
      return t * Xe;
    },
    radToDeg: function (t) {
      return t * qe;
    },
    isPowerOfTwo: $e,
    ceilPowerOfTwo: Qe,
    floorPowerOfTwo: tn,
    setQuaternionFromProperEuler: function (t, e, n, i, r) {
      const s = Math.cos,
        a = Math.sin,
        o = s(n / 2),
        l = a(n / 2),
        c = s((e + i) / 2),
        h = a((e + i) / 2),
        u = s((e - i) / 2),
        d = a((e - i) / 2),
        p = s((i - e) / 2),
        f = a((i - e) / 2);
      switch (r) {
        case "XYX":
          t.set(o * h, l * u, l * d, o * c);
          break;
        case "YZY":
          t.set(l * d, o * h, l * u, o * c);
          break;
        case "ZXZ":
          t.set(l * u, l * d, o * h, o * c);
          break;
        case "XZX":
          t.set(o * h, l * f, l * p, o * c);
          break;
        case "YXY":
          t.set(l * p, o * h, l * f, o * c);
          break;
        case "ZYZ":
          t.set(l * f, l * p, o * h, o * c);
          break;
        default:
          console.warn(
            "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
              r,
          );
      }
    },
    normalize: nn,
    denormalize: en,
  };
  class sn {
    constructor(t = 0, e = 0) {
      (sn.prototype.isVector2 = !0), (this.x = t), (this.y = e);
    }
    get width() {
      return this.x;
    }
    set width(t) {
      this.x = t;
    }
    get height() {
      return this.y;
    }
    set height(t) {
      this.y = t;
    }
    set(t, e) {
      return (this.x = t), (this.y = e), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), this;
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), this;
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), this;
    }
    addVectors(t, e) {
      return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
    }
    addScaledVector(t, e) {
      return (this.x += t.x * e), (this.y += t.y * e), this;
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), this;
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), this;
    }
    subVectors(t, e) {
      return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), this;
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), this;
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    applyMatrix3(t) {
      const e = this.x,
        n = this.y,
        i = t.elements;
      return (
        (this.x = i[0] * e + i[3] * n + i[6]),
        (this.y = i[1] * e + i[4] * n + i[7]),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n)),
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y;
    }
    cross(t) {
      return this.x * t.y - this.y * t.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(Ke(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        n = this.y - t.y;
      return e * e + n * n;
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
      );
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), t;
    }
    fromBufferAttribute(t, e) {
      return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
    }
    rotateAround(t, e) {
      const n = Math.cos(e),
        i = Math.sin(e),
        r = this.x - t.x,
        s = this.y - t.y;
      return (
        (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class an {
    constructor(t, e, n, i, r, s, a, o, l) {
      (an.prototype.isMatrix3 = !0),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        void 0 !== t && this.set(t, e, n, i, r, s, a, o, l);
    }
    set(t, e, n, i, r, s, a, o, l) {
      const c = this.elements;
      return (
        (c[0] = t),
        (c[1] = i),
        (c[2] = a),
        (c[3] = e),
        (c[4] = r),
        (c[5] = o),
        (c[6] = n),
        (c[7] = s),
        (c[8] = l),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t) {
      const e = this.elements,
        n = t.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[1]),
        (e[2] = n[2]),
        (e[3] = n[3]),
        (e[4] = n[4]),
        (e[5] = n[5]),
        (e[6] = n[6]),
        (e[7] = n[7]),
        (e[8] = n[8]),
        this
      );
    }
    extractBasis(t, e, n) {
      return (
        t.setFromMatrix3Column(this, 0),
        e.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(t) {
      const e = t.elements;
      return (
        this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
      );
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        a = n[3],
        o = n[6],
        l = n[1],
        c = n[4],
        h = n[7],
        u = n[2],
        d = n[5],
        p = n[8],
        f = i[0],
        m = i[3],
        g = i[6],
        v = i[1],
        _ = i[4],
        y = i[7],
        x = i[2],
        M = i[5],
        S = i[8];
      return (
        (r[0] = s * f + a * v + o * x),
        (r[3] = s * m + a * _ + o * M),
        (r[6] = s * g + a * y + o * S),
        (r[1] = l * f + c * v + h * x),
        (r[4] = l * m + c * _ + h * M),
        (r[7] = l * g + c * y + h * S),
        (r[2] = u * f + d * v + p * x),
        (r[5] = u * m + d * _ + p * M),
        (r[8] = u * g + d * y + p * S),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[3] *= t),
        (e[6] *= t),
        (e[1] *= t),
        (e[4] *= t),
        (e[7] *= t),
        (e[2] *= t),
        (e[5] *= t),
        (e[8] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8];
      return (
        e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8],
        h = c * s - a * l,
        u = a * o - c * r,
        d = l * r - s * o,
        p = e * h + n * u + i * d;
      if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / p;
      return (
        (t[0] = h * f),
        (t[1] = (i * l - c * n) * f),
        (t[2] = (a * n - i * s) * f),
        (t[3] = u * f),
        (t[4] = (c * e - i * o) * f),
        (t[5] = (i * r - a * e) * f),
        (t[6] = d * f),
        (t[7] = (n * o - l * e) * f),
        (t[8] = (s * e - n * r) * f),
        this
      );
    }
    transpose() {
      let t;
      const e = this.elements;
      return (
        (t = e[1]),
        (e[1] = e[3]),
        (e[3] = t),
        (t = e[2]),
        (e[2] = e[6]),
        (e[6] = t),
        (t = e[5]),
        (e[5] = e[7]),
        (e[7] = t),
        this
      );
    }
    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose();
    }
    transposeIntoArray(t) {
      const e = this.elements;
      return (
        (t[0] = e[0]),
        (t[1] = e[3]),
        (t[2] = e[6]),
        (t[3] = e[1]),
        (t[4] = e[4]),
        (t[5] = e[7]),
        (t[6] = e[2]),
        (t[7] = e[5]),
        (t[8] = e[8]),
        this
      );
    }
    setUvTransform(t, e, n, i, r, s, a) {
      const o = Math.cos(r),
        l = Math.sin(r);
      return (
        this.set(
          n * o,
          n * l,
          -n * (o * s + l * a) + s + t,
          -i * l,
          i * o,
          -i * (-l * s + o * a) + a + e,
          0,
          0,
          1,
        ),
        this
      );
    }
    scale(t, e) {
      return this.premultiply(on.makeScale(t, e)), this;
    }
    rotate(t) {
      return this.premultiply(on.makeRotation(-t)), this;
    }
    translate(t, e) {
      return this.premultiply(on.makeTranslation(t, e)), this;
    }
    makeTranslation(t, e) {
      return (
        t.isVector2
          ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
          : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
        this
      );
    }
    makeRotation(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
    }
    makeScale(t, e) {
      return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
    }
    equals(t) {
      const e = this.elements,
        n = t.elements;
      for (let i = 0; i < 9; i++) if (e[i] !== n[i]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return (
        (t[e] = n[0]),
        (t[e + 1] = n[1]),
        (t[e + 2] = n[2]),
        (t[e + 3] = n[3]),
        (t[e + 4] = n[4]),
        (t[e + 5] = n[5]),
        (t[e + 6] = n[6]),
        (t[e + 7] = n[7]),
        (t[e + 8] = n[8]),
        t
      );
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const on = new an();
  function ln(t) {
    for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
    return !1;
  }
  const cn = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: Uint8ClampedArray,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array,
  };
  function hn(t, e) {
    return new cn[t](e);
  }
  function un(t) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t);
  }
  const dn = {};
  function pn(t) {
    t in dn || ((dn[t] = !0), console.warn(t));
  }
  function fn(t) {
    return t < 0.04045
      ? 0.0773993808 * t
      : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
  }
  function mn(t) {
    return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
  }
  const gn = new an().fromArray([
      0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
      1e-7, 0.9105199,
    ]),
    vn = new an().fromArray([
      1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361,
      1e-7, 0, 1.0982735,
    ]);
  const _n = {
      [Oe]: (t) => t,
      [Ne]: (t) => t.convertSRGBToLinear(),
      [De]: function (t) {
        return t.convertSRGBToLinear().applyMatrix3(vn);
      },
    },
    yn = {
      [Oe]: (t) => t,
      [Ne]: (t) => t.convertLinearToSRGB(),
      [De]: function (t) {
        return t.applyMatrix3(gn).convertLinearToSRGB();
      },
    },
    xn = {
      enabled: !0,
      get legacyMode() {
        return (
          console.warn(
            "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.",
          ),
          !this.enabled
        );
      },
      set legacyMode(t) {
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.",
        ),
          (this.enabled = !t);
      },
      get workingColorSpace() {
        return Oe;
      },
      set workingColorSpace(t) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
      },
      convert: function (t, e, n) {
        if (!1 === this.enabled || e === n || !e || !n) return t;
        const i = _n[e],
          r = yn[n];
        if (void 0 === i || void 0 === r)
          throw new Error(
            `Unsupported color space conversion, "${e}" to "${n}".`,
          );
        return r(i(t));
      },
      fromWorkingColorSpace: function (t, e) {
        return this.convert(t, this.workingColorSpace, e);
      },
      toWorkingColorSpace: function (t, e) {
        return this.convert(t, e, this.workingColorSpace);
      },
    };
  let Mn;
  class Sn {
    static getDataURL(t) {
      if (/^data:/i.test(t.src)) return t.src;
      if ("undefined" == typeof HTMLCanvasElement) return t.src;
      let e;
      if (t instanceof HTMLCanvasElement) e = t;
      else {
        void 0 === Mn && (Mn = un("canvas")),
          (Mn.width = t.width),
          (Mn.height = t.height);
        const n = Mn.getContext("2d");
        t instanceof ImageData
          ? n.putImageData(t, 0, 0)
          : n.drawImage(t, 0, 0, t.width, t.height),
          (e = Mn);
      }
      return e.width > 2048 || e.height > 2048
        ? (console.warn(
            "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
            t,
          ),
          e.toDataURL("image/jpeg", 0.6))
        : e.toDataURL("image/png");
    }
    static sRGBToLinear(t) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          t instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ) {
        const e = un("canvas");
        (e.width = t.width), (e.height = t.height);
        const n = e.getContext("2d");
        n.drawImage(t, 0, 0, t.width, t.height);
        const i = n.getImageData(0, 0, t.width, t.height),
          r = i.data;
        for (let t = 0; t < r.length; t++) r[t] = 255 * fn(r[t] / 255);
        return n.putImageData(i, 0, 0), e;
      }
      if (t.data) {
        const e = t.data.slice(0);
        for (let t = 0; t < e.length; t++)
          e instanceof Uint8Array || e instanceof Uint8ClampedArray
            ? (e[t] = Math.floor(255 * fn(e[t] / 255)))
            : (e[t] = fn(e[t]));
        return { data: e, width: t.width, height: t.height };
      }
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
        ),
        t
      );
    }
  }
  let bn = 0;
  class Tn {
    constructor(t = null) {
      (this.isSource = !0),
        Object.defineProperty(this, "id", { value: bn++ }),
        (this.uuid = Ye()),
        (this.data = t),
        (this.version = 0);
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
      const n = { uuid: this.uuid, url: "" },
        i = this.data;
      if (null !== i) {
        let t;
        if (Array.isArray(i)) {
          t = [];
          for (let e = 0, n = i.length; e < n; e++)
            i[e].isDataTexture ? t.push(wn(i[e].image)) : t.push(wn(i[e]));
        } else t = wn(i);
        n.url = t;
      }
      return e || (t.images[this.uuid] = n), n;
    }
  }
  function wn(t) {
    return ("undefined" != typeof HTMLImageElement &&
      t instanceof HTMLImageElement) ||
      ("undefined" != typeof HTMLCanvasElement &&
        t instanceof HTMLCanvasElement) ||
      ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ? Sn.getDataURL(t)
      : t.data
      ? {
          data: Array.from(t.data),
          width: t.width,
          height: t.height,
          type: t.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let En = 0;
  class An extends Ve {
    constructor(
      t = An.DEFAULT_IMAGE,
      e = An.DEFAULT_MAPPING,
      n = 1001,
      i = 1001,
      r = 1006,
      s = 1008,
      a = 1023,
      o = 1009,
      l = An.DEFAULT_ANISOTROPY,
      c = "",
    ) {
      super(),
        (this.isTexture = !0),
        Object.defineProperty(this, "id", { value: En++ }),
        (this.uuid = Ye()),
        (this.name = ""),
        (this.source = new Tn(t)),
        (this.mipmaps = []),
        (this.mapping = e),
        (this.channel = 0),
        (this.wrapS = n),
        (this.wrapT = i),
        (this.magFilter = r),
        (this.minFilter = s),
        (this.anisotropy = l),
        (this.format = a),
        (this.internalFormat = null),
        (this.type = o),
        (this.offset = new sn(0, 0)),
        (this.repeat = new sn(1, 1)),
        (this.center = new sn(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new an()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        "string" == typeof c
          ? (this.colorSpace = c)
          : (pn(
              "THREE.Texture: Property .encoding has been replaced by .colorSpace.",
            ),
            (this.colorSpace = c === Pe ? Ne : Ue)),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.needsPMREMUpdate = !1);
    }
    get image() {
      return this.source.data;
    }
    set image(t = null) {
      this.source.data = t;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y,
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.source = t.source),
        (this.mipmaps = t.mipmaps.slice(0)),
        (this.mapping = t.mapping),
        (this.channel = t.channel),
        (this.wrapS = t.wrapS),
        (this.wrapT = t.wrapT),
        (this.magFilter = t.magFilter),
        (this.minFilter = t.minFilter),
        (this.anisotropy = t.anisotropy),
        (this.format = t.format),
        (this.internalFormat = t.internalFormat),
        (this.type = t.type),
        this.offset.copy(t.offset),
        this.repeat.copy(t.repeat),
        this.center.copy(t.center),
        (this.rotation = t.rotation),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this.matrix.copy(t.matrix),
        (this.generateMipmaps = t.generateMipmaps),
        (this.premultiplyAlpha = t.premultiplyAlpha),
        (this.flipY = t.flipY),
        (this.unpackAlignment = t.unpackAlignment),
        (this.colorSpace = t.colorSpace),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        (this.needsUpdate = !0),
        this
      );
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(t).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return (
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        e || (t.textures[this.uuid] = n),
        n
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(t) {
      if (this.mapping !== _t) return t;
      if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
        switch (this.wrapS) {
          case Tt:
            t.x = t.x - Math.floor(t.x);
            break;
          case wt:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case Et:
            1 === Math.abs(Math.floor(t.x) % 2)
              ? (t.x = Math.ceil(t.x) - t.x)
              : (t.x = t.x - Math.floor(t.x));
        }
      if (t.y < 0 || t.y > 1)
        switch (this.wrapT) {
          case Tt:
            t.y = t.y - Math.floor(t.y);
            break;
          case wt:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case Et:
            1 === Math.abs(Math.floor(t.y) % 2)
              ? (t.y = Math.ceil(t.y) - t.y)
              : (t.y = t.y - Math.floor(t.y));
        }
      return this.flipY && (t.y = 1 - t.y), t;
    }
    set needsUpdate(t) {
      !0 === t && (this.version++, (this.source.needsUpdate = !0));
    }
    get encoding() {
      return (
        pn(
          "THREE.Texture: Property .encoding has been replaced by .colorSpace.",
        ),
        this.colorSpace === Ne ? Pe : Ie
      );
    }
    set encoding(t) {
      pn("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        (this.colorSpace = t === Pe ? Ne : Ue);
    }
  }
  (An.DEFAULT_IMAGE = null),
    (An.DEFAULT_MAPPING = _t),
    (An.DEFAULT_ANISOTROPY = 1);
  class Rn {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      (Rn.prototype.isVector4 = !0),
        (this.x = t),
        (this.y = e),
        (this.z = n),
        (this.w = i);
    }
    get width() {
      return this.z;
    }
    set width(t) {
      this.z = t;
    }
    get height() {
      return this.w;
    }
    set height(t) {
      this.w = t;
    }
    set(t, e, n, i) {
      return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setW(t) {
      return (this.w = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t) {
      return (
        (this.x = t.x),
        (this.y = t.y),
        (this.z = t.z),
        (this.w = void 0 !== t.w ? t.w : 1),
        this
      );
    }
    add(t) {
      return (
        (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this
      );
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x),
        (this.y = t.y + e.y),
        (this.z = t.z + e.z),
        (this.w = t.w + e.w),
        this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e),
        (this.y += t.y * e),
        (this.z += t.z * e),
        (this.w += t.w * e),
        this
      );
    }
    sub(t) {
      return (
        (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this
      );
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x),
        (this.y = t.y - e.y),
        (this.z = t.z - e.z),
        (this.w = t.w - e.w),
        this
      );
    }
    multiply(t) {
      return (
        (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
      );
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
    }
    applyMatrix4(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = this.w,
        s = t.elements;
      return (
        (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
        (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
        (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
        (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
        this
      );
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      const e = Math.sqrt(1 - t.w * t.w);
      return (
        e < 1e-4
          ? ((this.x = 1), (this.y = 0), (this.z = 0))
          : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
        this
      );
    }
    setAxisAngleFromRotationMatrix(t) {
      let e, n, i, r;
      const s = 0.01,
        a = 0.1,
        o = t.elements,
        l = o[0],
        c = o[4],
        h = o[8],
        u = o[1],
        d = o[5],
        p = o[9],
        f = o[2],
        m = o[6],
        g = o[10];
      if (Math.abs(c - u) < s && Math.abs(h - f) < s && Math.abs(p - m) < s) {
        if (
          Math.abs(c + u) < a &&
          Math.abs(h + f) < a &&
          Math.abs(p + m) < a &&
          Math.abs(l + d + g - 3) < a
        )
          return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        const t = (l + 1) / 2,
          o = (d + 1) / 2,
          v = (g + 1) / 2,
          _ = (c + u) / 4,
          y = (h + f) / 4,
          x = (p + m) / 4;
        return (
          t > o && t > v
            ? t < s
              ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
              : ((n = Math.sqrt(t)), (i = _ / n), (r = y / n))
            : o > v
            ? o < s
              ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
              : ((i = Math.sqrt(o)), (n = _ / i), (r = x / i))
            : v < s
            ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
            : ((r = Math.sqrt(v)), (n = y / r), (i = x / r)),
          this.set(n, i, r, e),
          this
        );
      }
      let v = Math.sqrt(
        (m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c),
      );
      return (
        Math.abs(v) < 0.001 && (v = 1),
        (this.x = (m - p) / v),
        (this.y = (h - f) / v),
        (this.z = (u - c) / v),
        (this.w = Math.acos((l + d + g - 1) / 2)),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        (this.w = Math.min(this.w, t.w)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        (this.w = Math.max(this.w, t.w)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        (this.w = Math.max(t.w, Math.min(e.w, this.w))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        (this.w = Math.max(t, Math.min(e, this.w))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n)),
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        (this.w = Math.floor(this.w)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        (this.w = Math.ceil(this.w)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        (this.w = Math.round(this.w)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
        this
      );
    }
    negate() {
      return (
        (this.x = -this.x),
        (this.y = -this.y),
        (this.z = -this.z),
        (this.w = -this.w),
        this
      );
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
    lengthSq() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
      );
    }
    manhattanLength() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      );
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        (this.w += (t.w - this.w) * e),
        this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n),
        (this.y = t.y + (e.y - t.y) * n),
        (this.z = t.z + (e.z - t.z) * n),
        (this.w = t.w + (e.w - t.w) * n),
        this
      );
    }
    equals(t) {
      return (
        t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this.x = t[e]),
        (this.y = t[e + 1]),
        (this.z = t[e + 2]),
        (this.w = t[e + 3]),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this.x),
        (t[e + 1] = this.y),
        (t[e + 2] = this.z),
        (t[e + 3] = this.w),
        t
      );
    }
    fromBufferAttribute(t, e) {
      return (
        (this.x = t.getX(e)),
        (this.y = t.getY(e)),
        (this.z = t.getZ(e)),
        (this.w = t.getW(e)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        (this.w = Math.random()),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class Cn extends Ve {
    constructor(t = 1, e = 1, n = {}) {
      super(),
        (this.isRenderTarget = !0),
        (this.width = t),
        (this.height = e),
        (this.depth = 1),
        (this.scissor = new Rn(0, 0, t, e)),
        (this.scissorTest = !1),
        (this.viewport = new Rn(0, 0, t, e));
      const i = { width: t, height: e, depth: 1 };
      void 0 !== n.encoding &&
        (pn(
          "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.",
        ),
        (n.colorSpace = n.encoding === Pe ? Ne : Ue)),
        (this.texture = new An(
          i,
          n.mapping,
          n.wrapS,
          n.wrapT,
          n.magFilter,
          n.minFilter,
          n.format,
          n.type,
          n.anisotropy,
          n.colorSpace,
        )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.flipY = !1),
        (this.texture.generateMipmaps =
          void 0 !== n.generateMipmaps && n.generateMipmaps),
        (this.texture.internalFormat =
          void 0 !== n.internalFormat ? n.internalFormat : null),
        (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Lt),
        (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
        (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
        (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null),
        (this.samples = void 0 !== n.samples ? n.samples : 0);
    }
    setSize(t, e, n = 1) {
      (this.width === t && this.height === e && this.depth === n) ||
        ((this.width = t),
        (this.height = e),
        (this.depth = n),
        (this.texture.image.width = t),
        (this.texture.image.height = e),
        (this.texture.image.depth = n),
        this.dispose()),
        this.viewport.set(0, 0, t, e),
        this.scissor.set(0, 0, t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.width = t.width),
        (this.height = t.height),
        (this.depth = t.depth),
        this.scissor.copy(t.scissor),
        (this.scissorTest = t.scissorTest),
        this.viewport.copy(t.viewport),
        (this.texture = t.texture.clone()),
        (this.texture.isRenderTargetTexture = !0);
      const e = Object.assign({}, t.texture.image);
      return (
        (this.texture.source = new Tn(e)),
        (this.depthBuffer = t.depthBuffer),
        (this.stencilBuffer = t.stencilBuffer),
        null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
        (this.samples = t.samples),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class Ln extends Cn {
    constructor(t = 1, e = 1, n = {}) {
      super(t, e, n), (this.isWebGLRenderTarget = !0);
    }
  }
  class In extends An {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null),
        (this.isDataArrayTexture = !0),
        (this.image = { data: t, width: e, height: n, depth: i }),
        (this.magFilter = At),
        (this.minFilter = At),
        (this.wrapR = wt),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class Pn extends An {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null),
        (this.isData3DTexture = !0),
        (this.image = { data: t, width: e, height: n, depth: i }),
        (this.magFilter = At),
        (this.minFilter = At),
        (this.wrapR = wt),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class Un {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      (this.isQuaternion = !0),
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._w = i);
    }
    static slerpFlat(t, e, n, i, r, s, a) {
      let o = n[i + 0],
        l = n[i + 1],
        c = n[i + 2],
        h = n[i + 3];
      const u = r[s + 0],
        d = r[s + 1],
        p = r[s + 2],
        f = r[s + 3];
      if (0 === a)
        return (
          (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h)
        );
      if (1 === a)
        return (
          (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = f)
        );
      if (h !== f || o !== u || l !== d || c !== p) {
        let t = 1 - a;
        const e = o * u + l * d + c * p + h * f,
          n = e >= 0 ? 1 : -1,
          i = 1 - e * e;
        if (i > Number.EPSILON) {
          const r = Math.sqrt(i),
            s = Math.atan2(r, e * n);
          (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);
        }
        const r = a * n;
        if (
          ((o = o * t + u * r),
          (l = l * t + d * r),
          (c = c * t + p * r),
          (h = h * t + f * r),
          t === 1 - a)
        ) {
          const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
          (o *= t), (l *= t), (c *= t), (h *= t);
        }
      }
      (t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h);
    }
    static multiplyQuaternionsFlat(t, e, n, i, r, s) {
      const a = n[i],
        o = n[i + 1],
        l = n[i + 2],
        c = n[i + 3],
        h = r[s],
        u = r[s + 1],
        d = r[s + 2],
        p = r[s + 3];
      return (
        (t[e] = a * p + c * h + o * d - l * u),
        (t[e + 1] = o * p + c * u + l * h - a * d),
        (t[e + 2] = l * p + c * d + a * u - o * h),
        (t[e + 3] = c * p - a * h - o * u - l * d),
        t
      );
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t) {
      (this._w = t), this._onChangeCallback();
    }
    set(t, e, n, i) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._w = i),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t) {
      return (
        (this._x = t.x),
        (this._y = t.y),
        (this._z = t.z),
        (this._w = t.w),
        this._onChangeCallback(),
        this
      );
    }
    setFromEuler(t, e) {
      const n = t._x,
        i = t._y,
        r = t._z,
        s = t._order,
        a = Math.cos,
        o = Math.sin,
        l = a(n / 2),
        c = a(i / 2),
        h = a(r / 2),
        u = o(n / 2),
        d = o(i / 2),
        p = o(r / 2);
      switch (s) {
        case "XYZ":
          (this._x = u * c * h + l * d * p),
            (this._y = l * d * h - u * c * p),
            (this._z = l * c * p + u * d * h),
            (this._w = l * c * h - u * d * p);
          break;
        case "YXZ":
          (this._x = u * c * h + l * d * p),
            (this._y = l * d * h - u * c * p),
            (this._z = l * c * p - u * d * h),
            (this._w = l * c * h + u * d * p);
          break;
        case "ZXY":
          (this._x = u * c * h - l * d * p),
            (this._y = l * d * h + u * c * p),
            (this._z = l * c * p + u * d * h),
            (this._w = l * c * h - u * d * p);
          break;
        case "ZYX":
          (this._x = u * c * h - l * d * p),
            (this._y = l * d * h + u * c * p),
            (this._z = l * c * p - u * d * h),
            (this._w = l * c * h + u * d * p);
          break;
        case "YZX":
          (this._x = u * c * h + l * d * p),
            (this._y = l * d * h + u * c * p),
            (this._z = l * c * p - u * d * h),
            (this._w = l * c * h - u * d * p);
          break;
        case "XZY":
          (this._x = u * c * h - l * d * p),
            (this._y = l * d * h - u * c * p),
            (this._z = l * c * p + u * d * h),
            (this._w = l * c * h + u * d * p);
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              s,
          );
      }
      return !1 !== e && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t, e) {
      const n = e / 2,
        i = Math.sin(n);
      return (
        (this._x = t.x * i),
        (this._y = t.y * i),
        (this._z = t.z * i),
        (this._w = Math.cos(n)),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t) {
      const e = t.elements,
        n = e[0],
        i = e[4],
        r = e[8],
        s = e[1],
        a = e[5],
        o = e[9],
        l = e[2],
        c = e[6],
        h = e[10],
        u = n + a + h;
      if (u > 0) {
        const t = 0.5 / Math.sqrt(u + 1);
        (this._w = 0.25 / t),
          (this._x = (c - o) * t),
          (this._y = (r - l) * t),
          (this._z = (s - i) * t);
      } else if (n > a && n > h) {
        const t = 2 * Math.sqrt(1 + n - a - h);
        (this._w = (c - o) / t),
          (this._x = 0.25 * t),
          (this._y = (i + s) / t),
          (this._z = (r + l) / t);
      } else if (a > h) {
        const t = 2 * Math.sqrt(1 + a - n - h);
        (this._w = (r - l) / t),
          (this._x = (i + s) / t),
          (this._y = 0.25 * t),
          (this._z = (o + c) / t);
      } else {
        const t = 2 * Math.sqrt(1 + h - n - a);
        (this._w = (s - i) / t),
          (this._x = (r + l) / t),
          (this._y = (o + c) / t),
          (this._z = 0.25 * t);
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t, e) {
      let n = t.dot(e) + 1;
      return (
        n < Number.EPSILON
          ? ((n = 0),
            Math.abs(t.x) > Math.abs(t.z)
              ? ((this._x = -t.y),
                (this._y = t.x),
                (this._z = 0),
                (this._w = n))
              : ((this._x = 0),
                (this._y = -t.z),
                (this._z = t.y),
                (this._w = n)))
          : ((this._x = t.y * e.z - t.z * e.y),
            (this._y = t.z * e.x - t.x * e.z),
            (this._z = t.x * e.y - t.y * e.x),
            (this._w = n)),
        this.normalize()
      );
    }
    angleTo(t) {
      return 2 * Math.acos(Math.abs(Ke(this.dot(t), -1, 1)));
    }
    rotateTowards(t, e) {
      const n = this.angleTo(t);
      if (0 === n) return this;
      const i = Math.min(1, e / n);
      return this.slerp(t, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return (
        (this._x *= -1),
        (this._y *= -1),
        (this._z *= -1),
        this._onChangeCallback(),
        this
      );
    }
    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
    lengthSq() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      );
    }
    length() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w,
      );
    }
    normalize() {
      let t = this.length();
      return (
        0 === t
          ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
          : ((t = 1 / t),
            (this._x = this._x * t),
            (this._y = this._y * t),
            (this._z = this._z * t),
            (this._w = this._w * t)),
        this._onChangeCallback(),
        this
      );
    }
    multiply(t) {
      return this.multiplyQuaternions(this, t);
    }
    premultiply(t) {
      return this.multiplyQuaternions(t, this);
    }
    multiplyQuaternions(t, e) {
      const n = t._x,
        i = t._y,
        r = t._z,
        s = t._w,
        a = e._x,
        o = e._y,
        l = e._z,
        c = e._w;
      return (
        (this._x = n * c + s * a + i * l - r * o),
        (this._y = i * c + s * o + r * a - n * l),
        (this._z = r * c + s * l + n * o - i * a),
        (this._w = s * c - n * a - i * o - r * l),
        this._onChangeCallback(),
        this
      );
    }
    slerp(t, e) {
      if (0 === e) return this;
      if (1 === e) return this.copy(t);
      const n = this._x,
        i = this._y,
        r = this._z,
        s = this._w;
      let a = s * t._w + n * t._x + i * t._y + r * t._z;
      if (
        (a < 0
          ? ((this._w = -t._w),
            (this._x = -t._x),
            (this._y = -t._y),
            (this._z = -t._z),
            (a = -a))
          : this.copy(t),
        a >= 1)
      )
        return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this;
      const o = 1 - a * a;
      if (o <= Number.EPSILON) {
        const t = 1 - e;
        return (
          (this._w = t * s + e * this._w),
          (this._x = t * n + e * this._x),
          (this._y = t * i + e * this._y),
          (this._z = t * r + e * this._z),
          this.normalize(),
          this._onChangeCallback(),
          this
        );
      }
      const l = Math.sqrt(o),
        c = Math.atan2(l, a),
        h = Math.sin((1 - e) * c) / l,
        u = Math.sin(e * c) / l;
      return (
        (this._w = s * h + this._w * u),
        (this._x = n * h + this._x * u),
        (this._y = i * h + this._y * u),
        (this._z = r * h + this._z * u),
        this._onChangeCallback(),
        this
      );
    }
    slerpQuaternions(t, e, n) {
      return this.copy(t).slerp(e, n);
    }
    random() {
      const t = Math.random(),
        e = Math.sqrt(1 - t),
        n = Math.sqrt(t),
        i = 2 * Math.PI * Math.random(),
        r = 2 * Math.PI * Math.random();
      return this.set(
        e * Math.cos(i),
        n * Math.sin(r),
        n * Math.cos(r),
        e * Math.sin(i),
      );
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._w === this._w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this._x = t[e]),
        (this._y = t[e + 1]),
        (this._z = t[e + 2]),
        (this._w = t[e + 3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._w),
        t
      );
    }
    fromBufferAttribute(t, e) {
      return (
        (this._x = t.getX(e)),
        (this._y = t.getY(e)),
        (this._z = t.getZ(e)),
        (this._w = t.getW(e)),
        this
      );
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class Nn {
    constructor(t = 0, e = 0, n = 0) {
      (Nn.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n);
    }
    set(t, e, n) {
      return (
        void 0 === n && (n = this.z),
        (this.x = t),
        (this.y = e),
        (this.z = n),
        this
      );
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
      );
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
      );
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), this;
    }
    multiplyVectors(t, e) {
      return (
        (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
      );
    }
    applyEuler(t) {
      return this.applyQuaternion(Dn.setFromEuler(t));
    }
    applyAxisAngle(t, e) {
      return this.applyQuaternion(Dn.setFromAxisAngle(t, e));
    }
    applyMatrix3(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[3] * n + r[6] * i),
        (this.y = r[1] * e + r[4] * n + r[7] * i),
        (this.z = r[2] * e + r[5] * n + r[8] * i),
        this
      );
    }
    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize();
    }
    applyMatrix4(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements,
        s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
      return (
        (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
        (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
        (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
        this
      );
    }
    applyQuaternion(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.x,
        s = t.y,
        a = t.z,
        o = t.w,
        l = o * e + s * i - a * n,
        c = o * n + a * e - r * i,
        h = o * i + r * n - s * e,
        u = -r * e - s * n - a * i;
      return (
        (this.x = l * o + u * -r + c * -a - h * -s),
        (this.y = c * o + u * -s + h * -r - l * -a),
        (this.z = h * o + u * -a + l * -s - c * -r),
        this
      );
    }
    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix,
      );
    }
    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
        t.matrixWorld,
      );
    }
    transformDirection(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[4] * n + r[8] * i),
        (this.y = r[1] * e + r[5] * n + r[9] * i),
        (this.z = r[2] * e + r[6] * n + r[10] * i),
        this.normalize()
      );
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n)),
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n),
        (this.y = t.y + (e.y - t.y) * n),
        (this.z = t.z + (e.z - t.z) * n),
        this
      );
    }
    cross(t) {
      return this.crossVectors(this, t);
    }
    crossVectors(t, e) {
      const n = t.x,
        i = t.y,
        r = t.z,
        s = e.x,
        a = e.y,
        o = e.z;
      return (
        (this.x = i * o - r * a),
        (this.y = r * s - n * o),
        (this.z = n * a - i * s),
        this
      );
    }
    projectOnVector(t) {
      const e = t.lengthSq();
      if (0 === e) return this.set(0, 0, 0);
      const n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n);
    }
    projectOnPlane(t) {
      return On.copy(this).projectOnVector(t), this.sub(On);
    }
    reflect(t) {
      return this.sub(On.copy(t).multiplyScalar(2 * this.dot(t)));
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(Ke(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        n = this.y - t.y,
        i = this.z - t.z;
      return e * e + n * n + i * i;
    }
    manhattanDistanceTo(t) {
      return (
        Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
      );
    }
    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
    setFromSphericalCoords(t, e, n) {
      const i = Math.sin(e) * t;
      return (
        (this.x = i * Math.sin(n)),
        (this.y = Math.cos(e) * t),
        (this.z = i * Math.cos(n)),
        this
      );
    }
    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
    setFromCylindricalCoords(t, e, n) {
      return (
        (this.x = t * Math.sin(e)),
        (this.y = n),
        (this.z = t * Math.cos(e)),
        this
      );
    }
    setFromMatrixPosition(t) {
      const e = t.elements;
      return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
    }
    setFromMatrixScale(t) {
      const e = this.setFromMatrixColumn(t, 0).length(),
        n = this.setFromMatrixColumn(t, 1).length(),
        i = this.setFromMatrixColumn(t, 2).length();
      return (this.x = e), (this.y = n), (this.z = i), this;
    }
    setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, 4 * e);
    }
    setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, 3 * e);
    }
    setFromEuler(t) {
      return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
    }
    setFromColor(t) {
      return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
    }
    fromBufferAttribute(t, e) {
      return (
        (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        this
      );
    }
    randomDirection() {
      const t = 2 * (Math.random() - 0.5),
        e = Math.random() * Math.PI * 2,
        n = Math.sqrt(1 - a(t, 2));
      return (
        (this.x = n * Math.cos(e)),
        (this.y = n * Math.sin(e)),
        (this.z = t),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const On = new Nn(),
    Dn = new Un();
  class Fn {
    constructor(
      t = new Nn(1 / 0, 1 / 0, 1 / 0),
      e = new Nn(-1 / 0, -1 / 0, -1 / 0),
    ) {
      (this.isBox3 = !0), (this.min = t), (this.max = e);
    }
    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
    setFromArray(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e += 3)
        this.expandByPoint(zn.fromArray(t, e));
      return this;
    }
    setFromBufferAttribute(t) {
      this.makeEmpty();
      for (let e = 0, n = t.count; e < n; e++)
        this.expandByPoint(zn.fromBufferAttribute(t, e));
      return this;
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this;
    }
    setFromCenterAndSize(t, e) {
      const n = zn.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
    setFromObject(t, e = !1) {
      return this.makeEmpty(), this.expandByObject(t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      );
    }
    isEmpty() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    }
    getCenter(t) {
      return this.isEmpty()
        ? t.set(0, 0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
    expandByObject(t, e = !1) {
      if ((t.updateWorldMatrix(!1, !1), void 0 !== t.boundingBox))
        null === t.boundingBox && t.computeBoundingBox(),
          kn.copy(t.boundingBox),
          kn.applyMatrix4(t.matrixWorld),
          this.union(kn);
      else {
        const n = t.geometry;
        if (void 0 !== n)
          if (
            e &&
            void 0 !== n.attributes &&
            void 0 !== n.attributes.position
          ) {
            const e = n.attributes.position;
            for (let n = 0, i = e.count; n < i; n++)
              zn.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld),
                this.expandByPoint(zn);
          } else
            null === n.boundingBox && n.computeBoundingBox(),
              kn.copy(n.boundingBox),
              kn.applyMatrix4(t.matrixWorld),
              this.union(kn);
      }
      const n = t.children;
      for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i], e);
      return this;
    }
    containsPoint(t) {
      return !(
        t.x < this.min.x ||
        t.x > this.max.x ||
        t.y < this.min.y ||
        t.y > this.max.y ||
        t.z < this.min.z ||
        t.z > this.max.z
      );
    }
    containsBox(t) {
      return (
        this.min.x <= t.min.x &&
        t.max.x <= this.max.x &&
        this.min.y <= t.min.y &&
        t.max.y <= this.max.y &&
        this.min.z <= t.min.z &&
        t.max.z <= this.max.z
      );
    }
    getParameter(t, e) {
      return e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z),
      );
    }
    intersectsBox(t) {
      return !(
        t.max.x < this.min.x ||
        t.min.x > this.max.x ||
        t.max.y < this.min.y ||
        t.min.y > this.max.y ||
        t.max.z < this.min.z ||
        t.min.z > this.max.z
      );
    }
    intersectsSphere(t) {
      return (
        this.clampPoint(t.center, zn),
        zn.distanceToSquared(t.center) <= t.radius * t.radius
      );
    }
    intersectsPlane(t) {
      let e, n;
      return (
        t.normal.x > 0
          ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
          : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
        t.normal.y > 0
          ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
          : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
        t.normal.z > 0
          ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
          : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
        e <= -t.constant && n >= -t.constant
      );
    }
    intersectsTriangle(t) {
      if (this.isEmpty()) return !1;
      this.getCenter(qn),
        Yn.subVectors(this.max, qn),
        Hn.subVectors(t.a, qn),
        Gn.subVectors(t.b, qn),
        Vn.subVectors(t.c, qn),
        Wn.subVectors(Gn, Hn),
        jn.subVectors(Vn, Gn),
        Xn.subVectors(Hn, Vn);
      let e = [
        0,
        -Wn.z,
        Wn.y,
        0,
        -jn.z,
        jn.y,
        0,
        -Xn.z,
        Xn.y,
        Wn.z,
        0,
        -Wn.x,
        jn.z,
        0,
        -jn.x,
        Xn.z,
        0,
        -Xn.x,
        -Wn.y,
        Wn.x,
        0,
        -jn.y,
        jn.x,
        0,
        -Xn.y,
        Xn.x,
        0,
      ];
      return (
        !!Jn(e, Hn, Gn, Vn, Yn) &&
        ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        !!Jn(e, Hn, Gn, Vn, Yn) &&
          (Kn.crossVectors(Wn, jn),
          (e = [Kn.x, Kn.y, Kn.z]),
          Jn(e, Hn, Gn, Vn, Yn)))
      );
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
    distanceToPoint(t) {
      return this.clampPoint(t, zn).distanceTo(t);
    }
    getBoundingSphere(t) {
      return (
        this.isEmpty()
          ? t.makeEmpty()
          : (this.getCenter(t.center),
            (t.radius = 0.5 * this.getSize(zn).length())),
        t
      );
    }
    intersect(t) {
      return (
        this.min.max(t.min),
        this.max.min(t.max),
        this.isEmpty() && this.makeEmpty(),
        this
      );
    }
    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
    applyMatrix4(t) {
      return (
        this.isEmpty() ||
          (Bn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
          Bn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
          Bn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
          Bn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
          Bn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
          Bn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
          Bn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
          Bn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
          this.setFromPoints(Bn)),
        this
      );
    }
    translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }
  const Bn = [
      new Nn(),
      new Nn(),
      new Nn(),
      new Nn(),
      new Nn(),
      new Nn(),
      new Nn(),
      new Nn(),
    ],
    zn = new Nn(),
    kn = new Fn(),
    Hn = new Nn(),
    Gn = new Nn(),
    Vn = new Nn(),
    Wn = new Nn(),
    jn = new Nn(),
    Xn = new Nn(),
    qn = new Nn(),
    Yn = new Nn(),
    Kn = new Nn(),
    Zn = new Nn();
  function Jn(t, e, n, i, r) {
    for (let s = 0, a = t.length - 3; s <= a; s += 3) {
      Zn.fromArray(t, s);
      const a =
          r.x * Math.abs(Zn.x) + r.y * Math.abs(Zn.y) + r.z * Math.abs(Zn.z),
        o = e.dot(Zn),
        l = n.dot(Zn),
        c = i.dot(Zn);
      if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
    }
    return !0;
  }
  const $n = new Fn(),
    Qn = new Nn(),
    ti = new Nn();
  class ei {
    constructor(t = new Nn(), e = -1) {
      (this.center = t), (this.radius = e);
    }
    set(t, e) {
      return this.center.copy(t), (this.radius = e), this;
    }
    setFromPoints(t, e) {
      const n = this.center;
      void 0 !== e ? n.copy(e) : $n.setFromPoints(t).getCenter(n);
      let i = 0;
      for (let r = 0, s = t.length; r < s; r++)
        i = Math.max(i, n.distanceToSquared(t[r]));
      return (this.radius = Math.sqrt(i)), this;
    }
    copy(t) {
      return this.center.copy(t.center), (this.radius = t.radius), this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t) {
      const e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    }
    intersectsBox(t) {
      return t.intersectsSphere(this);
    }
    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t, e) {
      const n = this.center.distanceToSquared(t);
      return (
        e.copy(t),
        n > this.radius * this.radius &&
          (e.sub(this.center).normalize(),
          e.multiplyScalar(this.radius).add(this.center)),
        e
      );
    }
    getBoundingBox(t) {
      return this.isEmpty()
        ? (t.makeEmpty(), t)
        : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
    applyMatrix4(t) {
      return (
        this.center.applyMatrix4(t),
        (this.radius = this.radius * t.getMaxScaleOnAxis()),
        this
      );
    }
    translate(t) {
      return this.center.add(t), this;
    }
    expandByPoint(t) {
      if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this;
      Qn.subVectors(t, this.center);
      const e = Qn.lengthSq();
      if (e > this.radius * this.radius) {
        const t = Math.sqrt(e),
          n = 0.5 * (t - this.radius);
        this.center.addScaledVector(Qn, n / t), (this.radius += n);
      }
      return this;
    }
    union(t) {
      return t.isEmpty()
        ? this
        : this.isEmpty()
        ? (this.copy(t), this)
        : (!0 === this.center.equals(t.center)
            ? (this.radius = Math.max(this.radius, t.radius))
            : (ti.subVectors(t.center, this.center).setLength(t.radius),
              this.expandByPoint(Qn.copy(t.center).add(ti)),
              this.expandByPoint(Qn.copy(t.center).sub(ti))),
          this);
    }
    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const ni = new Nn(),
    ii = new Nn(),
    ri = new Nn(),
    si = new Nn(),
    ai = new Nn(),
    oi = new Nn(),
    li = new Nn();
  class ci {
    constructor(t = new Nn(), e = new Nn(0, 0, -1)) {
      (this.origin = t), (this.direction = e);
    }
    set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }
    copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
    at(t, e) {
      return e.copy(this.origin).addScaledVector(this.direction, t);
    }
    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
    recast(t) {
      return this.origin.copy(this.at(t, ni)), this;
    }
    closestPointToPoint(t, e) {
      e.subVectors(t, this.origin);
      const n = e.dot(this.direction);
      return n < 0
        ? e.copy(this.origin)
        : e.copy(this.origin).addScaledVector(this.direction, n);
    }
    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }
    distanceSqToPoint(t) {
      const e = ni.subVectors(t, this.origin).dot(this.direction);
      return e < 0
        ? this.origin.distanceToSquared(t)
        : (ni.copy(this.origin).addScaledVector(this.direction, e),
          ni.distanceToSquared(t));
    }
    distanceSqToSegment(t, e, n, i) {
      ii.copy(t).add(e).multiplyScalar(0.5),
        ri.copy(e).sub(t).normalize(),
        si.copy(this.origin).sub(ii);
      const r = 0.5 * t.distanceTo(e),
        s = -this.direction.dot(ri),
        a = si.dot(this.direction),
        o = -si.dot(ri),
        l = si.lengthSq(),
        c = Math.abs(1 - s * s);
      let h, u, d, p;
      if (c > 0)
        if (((h = s * o - a), (u = s * a - o), (p = r * c), h >= 0))
          if (u >= -p)
            if (u <= p) {
              const t = 1 / c;
              (h *= t),
                (u *= t),
                (d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l);
            } else
              (u = r),
                (h = Math.max(0, -(s * u + a))),
                (d = -h * h + u * (u + 2 * o) + l);
          else
            (u = -r),
              (h = Math.max(0, -(s * u + a))),
              (d = -h * h + u * (u + 2 * o) + l);
        else
          u <= -p
            ? ((h = Math.max(0, -(-s * r + a))),
              (u = h > 0 ? -r : Math.min(Math.max(-r, -o), r)),
              (d = -h * h + u * (u + 2 * o) + l))
            : u <= p
            ? ((h = 0),
              (u = Math.min(Math.max(-r, -o), r)),
              (d = u * (u + 2 * o) + l))
            : ((h = Math.max(0, -(s * r + a))),
              (u = h > 0 ? r : Math.min(Math.max(-r, -o), r)),
              (d = -h * h + u * (u + 2 * o) + l));
      else
        (u = s > 0 ? -r : r),
          (h = Math.max(0, -(s * u + a))),
          (d = -h * h + u * (u + 2 * o) + l);
      return (
        n && n.copy(this.origin).addScaledVector(this.direction, h),
        i && i.copy(ii).addScaledVector(ri, u),
        d
      );
    }
    intersectSphere(t, e) {
      ni.subVectors(t.center, this.origin);
      const n = ni.dot(this.direction),
        i = ni.dot(ni) - n * n,
        r = t.radius * t.radius;
      if (i > r) return null;
      const s = Math.sqrt(r - i),
        a = n - s,
        o = n + s;
      return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
    }
    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
    distanceToPlane(t) {
      const e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      const n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null;
    }
    intersectPlane(t, e) {
      const n = this.distanceToPlane(t);
      return null === n ? null : this.at(n, e);
    }
    intersectsPlane(t) {
      const e = t.distanceToPoint(this.origin);
      if (0 === e) return !0;
      return t.normal.dot(this.direction) * e < 0;
    }
    intersectBox(t, e) {
      let n, i, r, s, a, o;
      const l = 1 / this.direction.x,
        c = 1 / this.direction.y,
        h = 1 / this.direction.z,
        u = this.origin;
      return (
        l >= 0
          ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))
          : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),
        c >= 0
          ? ((r = (t.min.y - u.y) * c), (s = (t.max.y - u.y) * c))
          : ((r = (t.max.y - u.y) * c), (s = (t.min.y - u.y) * c)),
        n > s || r > i
          ? null
          : ((r > n || isNaN(n)) && (n = r),
            (s < i || isNaN(i)) && (i = s),
            h >= 0
              ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h))
              : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)),
            n > o || a > i
              ? null
              : ((a > n || n != n) && (n = a),
                (o < i || i != i) && (i = o),
                i < 0 ? null : this.at(n >= 0 ? n : i, e)))
      );
    }
    intersectsBox(t) {
      return null !== this.intersectBox(t, ni);
    }
    intersectTriangle(t, e, n, i, r) {
      ai.subVectors(e, t), oi.subVectors(n, t), li.crossVectors(ai, oi);
      let s,
        a = this.direction.dot(li);
      if (a > 0) {
        if (i) return null;
        s = 1;
      } else {
        if (!(a < 0)) return null;
        (s = -1), (a = -a);
      }
      si.subVectors(this.origin, t);
      const o = s * this.direction.dot(oi.crossVectors(si, oi));
      if (o < 0) return null;
      const l = s * this.direction.dot(ai.cross(si));
      if (l < 0) return null;
      if (o + l > a) return null;
      const c = -s * si.dot(li);
      return c < 0 ? null : this.at(c / a, r);
    }
    applyMatrix4(t) {
      return (
        this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
      );
    }
    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class hi {
    constructor(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
      (hi.prototype.isMatrix4 = !0),
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        void 0 !== t &&
          this.set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m);
    }
    set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
      const g = this.elements;
      return (
        (g[0] = t),
        (g[4] = e),
        (g[8] = n),
        (g[12] = i),
        (g[1] = r),
        (g[5] = s),
        (g[9] = a),
        (g[13] = o),
        (g[2] = l),
        (g[6] = c),
        (g[10] = h),
        (g[14] = u),
        (g[3] = d),
        (g[7] = p),
        (g[11] = f),
        (g[15] = m),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new hi().fromArray(this.elements);
    }
    copy(t) {
      const e = this.elements,
        n = t.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[1]),
        (e[2] = n[2]),
        (e[3] = n[3]),
        (e[4] = n[4]),
        (e[5] = n[5]),
        (e[6] = n[6]),
        (e[7] = n[7]),
        (e[8] = n[8]),
        (e[9] = n[9]),
        (e[10] = n[10]),
        (e[11] = n[11]),
        (e[12] = n[12]),
        (e[13] = n[13]),
        (e[14] = n[14]),
        (e[15] = n[15]),
        this
      );
    }
    copyPosition(t) {
      const e = this.elements,
        n = t.elements;
      return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
    }
    setFromMatrix3(t) {
      const e = t.elements;
      return (
        this.set(
          e[0],
          e[3],
          e[6],
          0,
          e[1],
          e[4],
          e[7],
          0,
          e[2],
          e[5],
          e[8],
          0,
          0,
          0,
          0,
          1,
        ),
        this
      );
    }
    extractBasis(t, e, n) {
      return (
        t.setFromMatrixColumn(this, 0),
        e.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
      );
    }
    makeBasis(t, e, n) {
      return (
        this.set(
          t.x,
          e.x,
          n.x,
          0,
          t.y,
          e.y,
          n.y,
          0,
          t.z,
          e.z,
          n.z,
          0,
          0,
          0,
          0,
          1,
        ),
        this
      );
    }
    extractRotation(t) {
      const e = this.elements,
        n = t.elements,
        i = 1 / ui.setFromMatrixColumn(t, 0).length(),
        r = 1 / ui.setFromMatrixColumn(t, 1).length(),
        s = 1 / ui.setFromMatrixColumn(t, 2).length();
      return (
        (e[0] = n[0] * i),
        (e[1] = n[1] * i),
        (e[2] = n[2] * i),
        (e[3] = 0),
        (e[4] = n[4] * r),
        (e[5] = n[5] * r),
        (e[6] = n[6] * r),
        (e[7] = 0),
        (e[8] = n[8] * s),
        (e[9] = n[9] * s),
        (e[10] = n[10] * s),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromEuler(t) {
      const e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z,
        s = Math.cos(n),
        a = Math.sin(n),
        o = Math.cos(i),
        l = Math.sin(i),
        c = Math.cos(r),
        h = Math.sin(r);
      if ("XYZ" === t.order) {
        const t = s * c,
          n = s * h,
          i = a * c,
          r = a * h;
        (e[0] = o * c),
          (e[4] = -o * h),
          (e[8] = l),
          (e[1] = n + i * l),
          (e[5] = t - r * l),
          (e[9] = -a * o),
          (e[2] = r - t * l),
          (e[6] = i + n * l),
          (e[10] = s * o);
      } else if ("YXZ" === t.order) {
        const t = o * c,
          n = o * h,
          i = l * c,
          r = l * h;
        (e[0] = t + r * a),
          (e[4] = i * a - n),
          (e[8] = s * l),
          (e[1] = s * h),
          (e[5] = s * c),
          (e[9] = -a),
          (e[2] = n * a - i),
          (e[6] = r + t * a),
          (e[10] = s * o);
      } else if ("ZXY" === t.order) {
        const t = o * c,
          n = o * h,
          i = l * c,
          r = l * h;
        (e[0] = t - r * a),
          (e[4] = -s * h),
          (e[8] = i + n * a),
          (e[1] = n + i * a),
          (e[5] = s * c),
          (e[9] = r - t * a),
          (e[2] = -s * l),
          (e[6] = a),
          (e[10] = s * o);
      } else if ("ZYX" === t.order) {
        const t = s * c,
          n = s * h,
          i = a * c,
          r = a * h;
        (e[0] = o * c),
          (e[4] = i * l - n),
          (e[8] = t * l + r),
          (e[1] = o * h),
          (e[5] = r * l + t),
          (e[9] = n * l - i),
          (e[2] = -l),
          (e[6] = a * o),
          (e[10] = s * o);
      } else if ("YZX" === t.order) {
        const t = s * o,
          n = s * l,
          i = a * o,
          r = a * l;
        (e[0] = o * c),
          (e[4] = r - t * h),
          (e[8] = i * h + n),
          (e[1] = h),
          (e[5] = s * c),
          (e[9] = -a * c),
          (e[2] = -l * c),
          (e[6] = n * h + i),
          (e[10] = t - r * h);
      } else if ("XZY" === t.order) {
        const t = s * o,
          n = s * l,
          i = a * o,
          r = a * l;
        (e[0] = o * c),
          (e[4] = -h),
          (e[8] = l * c),
          (e[1] = t * h + r),
          (e[5] = s * c),
          (e[9] = n * h - i),
          (e[2] = i * h - n),
          (e[6] = a * c),
          (e[10] = r * h + t);
      }
      return (
        (e[3] = 0),
        (e[7] = 0),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromQuaternion(t) {
      return this.compose(pi, t, fi);
    }
    lookAt(t, e, n) {
      const i = this.elements;
      return (
        vi.subVectors(t, e),
        0 === vi.lengthSq() && (vi.z = 1),
        vi.normalize(),
        mi.crossVectors(n, vi),
        0 === mi.lengthSq() &&
          (1 === Math.abs(n.z) ? (vi.x += 1e-4) : (vi.z += 1e-4),
          vi.normalize(),
          mi.crossVectors(n, vi)),
        mi.normalize(),
        gi.crossVectors(vi, mi),
        (i[0] = mi.x),
        (i[4] = gi.x),
        (i[8] = vi.x),
        (i[1] = mi.y),
        (i[5] = gi.y),
        (i[9] = vi.y),
        (i[2] = mi.z),
        (i[6] = gi.z),
        (i[10] = vi.z),
        this
      );
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        a = n[4],
        o = n[8],
        l = n[12],
        c = n[1],
        h = n[5],
        u = n[9],
        d = n[13],
        p = n[2],
        f = n[6],
        m = n[10],
        g = n[14],
        v = n[3],
        _ = n[7],
        y = n[11],
        x = n[15],
        M = i[0],
        S = i[4],
        b = i[8],
        T = i[12],
        w = i[1],
        E = i[5],
        A = i[9],
        R = i[13],
        C = i[2],
        L = i[6],
        I = i[10],
        P = i[14],
        U = i[3],
        N = i[7],
        O = i[11],
        D = i[15];
      return (
        (r[0] = s * M + a * w + o * C + l * U),
        (r[4] = s * S + a * E + o * L + l * N),
        (r[8] = s * b + a * A + o * I + l * O),
        (r[12] = s * T + a * R + o * P + l * D),
        (r[1] = c * M + h * w + u * C + d * U),
        (r[5] = c * S + h * E + u * L + d * N),
        (r[9] = c * b + h * A + u * I + d * O),
        (r[13] = c * T + h * R + u * P + d * D),
        (r[2] = p * M + f * w + m * C + g * U),
        (r[6] = p * S + f * E + m * L + g * N),
        (r[10] = p * b + f * A + m * I + g * O),
        (r[14] = p * T + f * R + m * P + g * D),
        (r[3] = v * M + _ * w + y * C + x * U),
        (r[7] = v * S + _ * E + y * L + x * N),
        (r[11] = v * b + _ * A + y * I + x * O),
        (r[15] = v * T + _ * R + y * P + x * D),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[4] *= t),
        (e[8] *= t),
        (e[12] *= t),
        (e[1] *= t),
        (e[5] *= t),
        (e[9] *= t),
        (e[13] *= t),
        (e[2] *= t),
        (e[6] *= t),
        (e[10] *= t),
        (e[14] *= t),
        (e[3] *= t),
        (e[7] *= t),
        (e[11] *= t),
        (e[15] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        n = t[4],
        i = t[8],
        r = t[12],
        s = t[1],
        a = t[5],
        o = t[9],
        l = t[13],
        c = t[2],
        h = t[6],
        u = t[10],
        d = t[14];
      return (
        t[3] *
          (+r * o * h -
            i * l * h -
            r * a * u +
            n * l * u +
            i * a * d -
            n * o * d) +
        t[7] *
          (+e * o * d -
            e * l * u +
            r * s * u -
            i * s * d +
            i * l * c -
            r * o * c) +
        t[11] *
          (+e * l * h -
            e * a * d -
            r * s * h +
            n * s * d +
            r * a * c -
            n * l * c) +
        t[15] *
          (-i * a * c -
            e * o * h +
            e * a * u +
            i * s * h -
            n * s * u +
            n * o * c)
      );
    }
    transpose() {
      const t = this.elements;
      let e;
      return (
        (e = t[1]),
        (t[1] = t[4]),
        (t[4] = e),
        (e = t[2]),
        (t[2] = t[8]),
        (t[8] = e),
        (e = t[6]),
        (t[6] = t[9]),
        (t[9] = e),
        (e = t[3]),
        (t[3] = t[12]),
        (t[12] = e),
        (e = t[7]),
        (t[7] = t[13]),
        (t[13] = e),
        (e = t[11]),
        (t[11] = t[14]),
        (t[14] = e),
        this
      );
    }
    setPosition(t, e, n) {
      const i = this.elements;
      return (
        t.isVector3
          ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
          : ((i[12] = t), (i[13] = e), (i[14] = n)),
        this
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8],
        h = t[9],
        u = t[10],
        d = t[11],
        p = t[12],
        f = t[13],
        m = t[14],
        g = t[15],
        v =
          h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g,
        _ =
          p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g,
        y =
          c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g,
        x =
          p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m,
        M = e * v + n * _ + i * y + r * x;
      if (0 === M)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const S = 1 / M;
      return (
        (t[0] = v * S),
        (t[1] =
          (f * u * r -
            h * m * r -
            f * i * d +
            n * m * d +
            h * i * g -
            n * u * g) *
          S),
        (t[2] =
          (a * m * r -
            f * o * r +
            f * i * l -
            n * m * l -
            a * i * g +
            n * o * g) *
          S),
        (t[3] =
          (h * o * r -
            a * u * r -
            h * i * l +
            n * u * l +
            a * i * d -
            n * o * d) *
          S),
        (t[4] = _ * S),
        (t[5] =
          (c * m * r -
            p * u * r +
            p * i * d -
            e * m * d -
            c * i * g +
            e * u * g) *
          S),
        (t[6] =
          (p * o * r -
            s * m * r -
            p * i * l +
            e * m * l +
            s * i * g -
            e * o * g) *
          S),
        (t[7] =
          (s * u * r -
            c * o * r +
            c * i * l -
            e * u * l -
            s * i * d +
            e * o * d) *
          S),
        (t[8] = y * S),
        (t[9] =
          (p * h * r -
            c * f * r -
            p * n * d +
            e * f * d +
            c * n * g -
            e * h * g) *
          S),
        (t[10] =
          (s * f * r -
            p * a * r +
            p * n * l -
            e * f * l -
            s * n * g +
            e * a * g) *
          S),
        (t[11] =
          (c * a * r -
            s * h * r -
            c * n * l +
            e * h * l +
            s * n * d -
            e * a * d) *
          S),
        (t[12] = x * S),
        (t[13] =
          (c * f * i -
            p * h * i +
            p * n * u -
            e * f * u -
            c * n * m +
            e * h * m) *
          S),
        (t[14] =
          (p * a * i -
            s * f * i -
            p * n * o +
            e * f * o +
            s * n * m -
            e * a * m) *
          S),
        (t[15] =
          (s * h * i -
            c * a * i +
            c * n * o -
            e * h * o -
            s * n * u +
            e * a * u) *
          S),
        this
      );
    }
    scale(t) {
      const e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z;
      return (
        (e[0] *= n),
        (e[4] *= i),
        (e[8] *= r),
        (e[1] *= n),
        (e[5] *= i),
        (e[9] *= r),
        (e[2] *= n),
        (e[6] *= i),
        (e[10] *= r),
        (e[3] *= n),
        (e[7] *= i),
        (e[11] *= r),
        this
      );
    }
    getMaxScaleOnAxis() {
      const t = this.elements,
        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, i));
    }
    makeTranslation(t, e, n) {
      return (
        t.isVector3
          ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
          : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
        this
      );
    }
    makeRotationX(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t, e) {
      const n = Math.cos(e),
        i = Math.sin(e),
        r = 1 - n,
        s = t.x,
        a = t.y,
        o = t.z,
        l = r * s,
        c = r * a;
      return (
        this.set(
          l * s + n,
          l * a - i * o,
          l * o + i * a,
          0,
          l * a + i * o,
          c * a + n,
          c * o - i * s,
          0,
          l * o - i * a,
          c * o + i * s,
          r * o * o + n,
          0,
          0,
          0,
          0,
          1,
        ),
        this
      );
    }
    makeScale(t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(t, e, n, i, r, s) {
      return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t, e, n) {
      const i = this.elements,
        r = e._x,
        s = e._y,
        a = e._z,
        o = e._w,
        l = r + r,
        c = s + s,
        h = a + a,
        u = r * l,
        d = r * c,
        p = r * h,
        f = s * c,
        m = s * h,
        g = a * h,
        v = o * l,
        _ = o * c,
        y = o * h,
        x = n.x,
        M = n.y,
        S = n.z;
      return (
        (i[0] = (1 - (f + g)) * x),
        (i[1] = (d + y) * x),
        (i[2] = (p - _) * x),
        (i[3] = 0),
        (i[4] = (d - y) * M),
        (i[5] = (1 - (u + g)) * M),
        (i[6] = (m + v) * M),
        (i[7] = 0),
        (i[8] = (p + _) * S),
        (i[9] = (m - v) * S),
        (i[10] = (1 - (u + f)) * S),
        (i[11] = 0),
        (i[12] = t.x),
        (i[13] = t.y),
        (i[14] = t.z),
        (i[15] = 1),
        this
      );
    }
    decompose(t, e, n) {
      const i = this.elements;
      let r = ui.set(i[0], i[1], i[2]).length();
      const s = ui.set(i[4], i[5], i[6]).length(),
        a = ui.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r),
        (t.x = i[12]),
        (t.y = i[13]),
        (t.z = i[14]),
        di.copy(this);
      const o = 1 / r,
        l = 1 / s,
        c = 1 / a;
      return (
        (di.elements[0] *= o),
        (di.elements[1] *= o),
        (di.elements[2] *= o),
        (di.elements[4] *= l),
        (di.elements[5] *= l),
        (di.elements[6] *= l),
        (di.elements[8] *= c),
        (di.elements[9] *= c),
        (di.elements[10] *= c),
        e.setFromRotationMatrix(di),
        (n.x = r),
        (n.y = s),
        (n.z = a),
        this
      );
    }
    makePerspective(t, e, n, i, r, s, a = 2e3) {
      const o = this.elements,
        l = (2 * r) / (e - t),
        c = (2 * r) / (n - i),
        h = (e + t) / (e - t),
        u = (n + i) / (n - i);
      let d, p;
      if (a === He) (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
      else {
        if (a !== Ge)
          throw new Error(
            "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a,
          );
        (d = -s / (s - r)), (p = (-s * r) / (s - r));
      }
      return (
        (o[0] = l),
        (o[4] = 0),
        (o[8] = h),
        (o[12] = 0),
        (o[1] = 0),
        (o[5] = c),
        (o[9] = u),
        (o[13] = 0),
        (o[2] = 0),
        (o[6] = 0),
        (o[10] = d),
        (o[14] = p),
        (o[3] = 0),
        (o[7] = 0),
        (o[11] = -1),
        (o[15] = 0),
        this
      );
    }
    makeOrthographic(t, e, n, i, r, s, a = 2e3) {
      const o = this.elements,
        l = 1 / (e - t),
        c = 1 / (n - i),
        h = 1 / (s - r),
        u = (e + t) * l,
        d = (n + i) * c;
      let p, f;
      if (a === He) (p = (s + r) * h), (f = -2 * h);
      else {
        if (a !== Ge)
          throw new Error(
            "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a,
          );
        (p = r * h), (f = -1 * h);
      }
      return (
        (o[0] = 2 * l),
        (o[4] = 0),
        (o[8] = 0),
        (o[12] = -u),
        (o[1] = 0),
        (o[5] = 2 * c),
        (o[9] = 0),
        (o[13] = -d),
        (o[2] = 0),
        (o[6] = 0),
        (o[10] = f),
        (o[14] = -p),
        (o[3] = 0),
        (o[7] = 0),
        (o[11] = 0),
        (o[15] = 1),
        this
      );
    }
    equals(t) {
      const e = this.elements,
        n = t.elements;
      for (let i = 0; i < 16; i++) if (e[i] !== n[i]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return (
        (t[e] = n[0]),
        (t[e + 1] = n[1]),
        (t[e + 2] = n[2]),
        (t[e + 3] = n[3]),
        (t[e + 4] = n[4]),
        (t[e + 5] = n[5]),
        (t[e + 6] = n[6]),
        (t[e + 7] = n[7]),
        (t[e + 8] = n[8]),
        (t[e + 9] = n[9]),
        (t[e + 10] = n[10]),
        (t[e + 11] = n[11]),
        (t[e + 12] = n[12]),
        (t[e + 13] = n[13]),
        (t[e + 14] = n[14]),
        (t[e + 15] = n[15]),
        t
      );
    }
  }
  const ui = new Nn(),
    di = new hi(),
    pi = new Nn(0, 0, 0),
    fi = new Nn(1, 1, 1),
    mi = new Nn(),
    gi = new Nn(),
    vi = new Nn(),
    _i = new hi(),
    yi = new Un();
  class xi {
    constructor(t = 0, e = 0, n = 0, i = xi.DEFAULT_ORDER) {
      (this.isEuler = !0),
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._order = i);
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t) {
      (this._order = t), this._onChangeCallback();
    }
    set(t, e, n, i = this._order) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._order = i),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t) {
      return (
        (this._x = t._x),
        (this._y = t._y),
        (this._z = t._z),
        (this._order = t._order),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t, e = this._order, n = !0) {
      const i = t.elements,
        r = i[0],
        s = i[4],
        a = i[8],
        o = i[1],
        l = i[5],
        c = i[9],
        h = i[2],
        u = i[6],
        d = i[10];
      switch (e) {
        case "XYZ":
          (this._y = Math.asin(Ke(a, -1, 1))),
            Math.abs(a) < 0.9999999
              ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
              : ((this._x = Math.atan2(u, l)), (this._z = 0));
          break;
        case "YXZ":
          (this._x = Math.asin(-Ke(c, -1, 1))),
            Math.abs(c) < 0.9999999
              ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
              : ((this._y = Math.atan2(-h, r)), (this._z = 0));
          break;
        case "ZXY":
          (this._x = Math.asin(Ke(u, -1, 1))),
            Math.abs(u) < 0.9999999
              ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-s, l)))
              : ((this._y = 0), (this._z = Math.atan2(o, r)));
          break;
        case "ZYX":
          (this._y = Math.asin(-Ke(h, -1, 1))),
            Math.abs(h) < 0.9999999
              ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))
              : ((this._x = 0), (this._z = Math.atan2(-s, l)));
          break;
        case "YZX":
          (this._z = Math.asin(Ke(o, -1, 1))),
            Math.abs(o) < 0.9999999
              ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, r)))
              : ((this._x = 0), (this._y = Math.atan2(a, d)));
          break;
        case "XZY":
          (this._z = Math.asin(-Ke(s, -1, 1))),
            Math.abs(s) < 0.9999999
              ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))
              : ((this._x = Math.atan2(-c, d)), (this._y = 0));
          break;
        default:
          console.warn(
            "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
              e,
          );
      }
      return (this._order = e), !0 === n && this._onChangeCallback(), this;
    }
    setFromQuaternion(t, e, n) {
      return (
        _i.makeRotationFromQuaternion(t), this.setFromRotationMatrix(_i, e, n)
      );
    }
    setFromVector3(t, e = this._order) {
      return this.set(t.x, t.y, t.z, e);
    }
    reorder(t) {
      return yi.setFromEuler(this), this.setFromQuaternion(yi, t);
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._order === this._order
      );
    }
    fromArray(t) {
      return (
        (this._x = t[0]),
        (this._y = t[1]),
        (this._z = t[2]),
        void 0 !== t[3] && (this._order = t[3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._order),
        t
      );
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  }
  xi.DEFAULT_ORDER = "XYZ";
  class Mi {
    constructor() {
      this.mask = 1;
    }
    set(t) {
      this.mask = ((1 << t) | 0) >>> 0;
    }
    enable(t) {
      this.mask |= (1 << t) | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t) {
      this.mask ^= (1 << t) | 0;
    }
    disable(t) {
      this.mask &= ~((1 << t) | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t) {
      return 0 != (this.mask & t.mask);
    }
    isEnabled(t) {
      return 0 != (this.mask & ((1 << t) | 0));
    }
  }
  let Si = 0;
  const bi = new Nn(),
    Ti = new Un(),
    wi = new hi(),
    Ei = new Nn(),
    Ai = new Nn(),
    Ri = new Nn(),
    Ci = new Un(),
    Li = new Nn(1, 0, 0),
    Ii = new Nn(0, 1, 0),
    Pi = new Nn(0, 0, 1),
    Ui = { type: "added" },
    Ni = { type: "removed" };
  class Oi extends Ve {
    constructor() {
      super(),
        (this.isObject3D = !0),
        Object.defineProperty(this, "id", { value: Si++ }),
        (this.uuid = Ye()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = Oi.DEFAULT_UP.clone());
      const t = new Nn(),
        e = new xi(),
        n = new Un(),
        i = new Nn(1, 1, 1);
      e._onChange(function () {
        n.setFromEuler(e, !1);
      }),
        n._onChange(function () {
          e.setFromQuaternion(n, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: e },
          quaternion: { configurable: !0, enumerable: !0, value: n },
          scale: { configurable: !0, enumerable: !0, value: i },
          modelViewMatrix: { value: new hi() },
          normalMatrix: { value: new an() },
        }),
        (this.matrix = new hi()),
        (this.matrixWorld = new hi()),
        (this.matrixAutoUpdate = Oi.DEFAULT_MATRIX_AUTO_UPDATE),
        (this.matrixWorldNeedsUpdate = !1),
        (this.matrixWorldAutoUpdate = Oi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
        (this.layers = new Mi()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.animations = []),
        (this.userData = {});
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0);
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
    rotateOnAxis(t, e) {
      return Ti.setFromAxisAngle(t, e), this.quaternion.multiply(Ti), this;
    }
    rotateOnWorldAxis(t, e) {
      return Ti.setFromAxisAngle(t, e), this.quaternion.premultiply(Ti), this;
    }
    rotateX(t) {
      return this.rotateOnAxis(Li, t);
    }
    rotateY(t) {
      return this.rotateOnAxis(Ii, t);
    }
    rotateZ(t) {
      return this.rotateOnAxis(Pi, t);
    }
    translateOnAxis(t, e) {
      return (
        bi.copy(t).applyQuaternion(this.quaternion),
        this.position.add(bi.multiplyScalar(e)),
        this
      );
    }
    translateX(t) {
      return this.translateOnAxis(Li, t);
    }
    translateY(t) {
      return this.translateOnAxis(Ii, t);
    }
    translateZ(t) {
      return this.translateOnAxis(Pi, t);
    }
    localToWorld(t) {
      return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.applyMatrix4(wi.copy(this.matrixWorld).invert())
      );
    }
    lookAt(t, e, n) {
      t.isVector3 ? Ei.copy(t) : Ei.set(t, e, n);
      const i = this.parent;
      this.updateWorldMatrix(!0, !1),
        Ai.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? wi.lookAt(Ai, Ei, this.up)
          : wi.lookAt(Ei, Ai, this.up),
        this.quaternion.setFromRotationMatrix(wi),
        i &&
          (wi.extractRotation(i.matrixWorld),
          Ti.setFromRotationMatrix(wi),
          this.quaternion.premultiply(Ti.invert()));
    }
    add(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return t === this
        ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            t,
          ),
          this)
        : (t && t.isObject3D
            ? (null !== t.parent && t.parent.remove(t),
              (t.parent = this),
              this.children.push(t),
              t.dispatchEvent(Ui))
            : console.error(
                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                t,
              ),
          this);
    }
    remove(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
        return this;
      }
      const e = this.children.indexOf(t);
      return (
        -1 !== e &&
          ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(Ni)),
        this
      );
    }
    removeFromParent() {
      const t = this.parent;
      return null !== t && t.remove(this), this;
    }
    clear() {
      for (let t = 0; t < this.children.length; t++) {
        const e = this.children[t];
        (e.parent = null), e.dispatchEvent(Ni);
      }
      return (this.children.length = 0), this;
    }
    attach(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        wi.copy(this.matrixWorld).invert(),
        null !== t.parent &&
          (t.parent.updateWorldMatrix(!0, !1),
          wi.multiply(t.parent.matrixWorld)),
        t.applyMatrix4(wi),
        this.add(t),
        t.updateWorldMatrix(!1, !0),
        this
      );
    }
    getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
    getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
    getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (let n = 0, i = this.children.length; n < i; n++) {
        const i = this.children[n].getObjectByProperty(t, e);
        if (void 0 !== i) return i;
      }
    }
    getObjectsByProperty(t, e) {
      let n = [];
      this[t] === e && n.push(this);
      for (let i = 0, r = this.children.length; i < r; i++) {
        const r = this.children[i].getObjectsByProperty(t, e);
        r.length > 0 && (n = n.concat(r));
      }
      return n;
    }
    getWorldPosition(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.setFromMatrixPosition(this.matrixWorld)
      );
    }
    getWorldQuaternion(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ai, t, Ri), t
      );
    }
    getWorldScale(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ai, Ci, t), t
      );
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {}
    traverse(t) {
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
    }
    traverseVisible(t) {
      if (!1 === this.visible) return;
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
    }
    traverseAncestors(t) {
      const e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (t = !0));
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) {
        const i = e[n];
        (!0 !== i.matrixWorldAutoUpdate && !0 !== t) || i.updateMatrixWorld(t);
      }
    }
    updateWorldMatrix(t, e) {
      const n = this.parent;
      if (
        (!0 === t &&
          null !== n &&
          !0 === n.matrixWorldAutoUpdate &&
          n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            ),
        !0 === e)
      ) {
        const t = this.children;
        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e];
          !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0);
        }
      }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t,
        n = {};
      e &&
        ((t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {},
        }),
        (n.metadata = {
          version: 4.6,
          type: "Object",
          generator: "Object3D.toJSON",
        }));
      const i = {};
      function r(e, n) {
        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
      }
      if (
        ((i.uuid = this.uuid),
        (i.type = this.type),
        "" !== this.name && (i.name = this.name),
        !0 === this.castShadow && (i.castShadow = !0),
        !0 === this.receiveShadow && (i.receiveShadow = !0),
        !1 === this.visible && (i.visible = !1),
        !1 === this.frustumCulled && (i.frustumCulled = !1),
        0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        (i.layers = this.layers.mask),
        (i.matrix = this.matrix.toArray()),
        (i.up = this.up.toArray()),
        !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((i.type = "InstancedMesh"),
          (i.count = this.count),
          (i.instanceMatrix = this.instanceMatrix.toJSON()),
          null !== this.instanceColor &&
            (i.instanceColor = this.instanceColor.toJSON())),
        this.isScene)
      )
        this.background &&
          (this.background.isColor
            ? (i.background = this.background.toJSON())
            : this.background.isTexture &&
              (i.background = this.background.toJSON(t).uuid)),
          this.environment &&
            this.environment.isTexture &&
            !0 !== this.environment.isRenderTargetTexture &&
            (i.environment = this.environment.toJSON(t).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = r(t.geometries, this.geometry);
        const e = this.geometry.parameters;
        if (void 0 !== e && void 0 !== e.shapes) {
          const n = e.shapes;
          if (Array.isArray(n))
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              r(t.shapes, i);
            }
          else r(t.shapes, n);
        }
      }
      if (
        (this.isSkinnedMesh &&
          ((i.bindMode = this.bindMode),
          (i.bindMatrix = this.bindMatrix.toArray()),
          void 0 !== this.skeleton &&
            (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
        void 0 !== this.material)
      )
        if (Array.isArray(this.material)) {
          const e = [];
          for (let n = 0, i = this.material.length; n < i; n++)
            e.push(r(t.materials, this.material[n]));
          i.material = e;
        } else i.material = r(t.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (let e = 0; e < this.children.length; e++)
          i.children.push(this.children[e].toJSON(t).object);
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (let e = 0; e < this.animations.length; e++) {
          const n = this.animations[e];
          i.animations.push(r(t.animations, n));
        }
      }
      if (e) {
        const e = s(t.geometries),
          i = s(t.materials),
          r = s(t.textures),
          a = s(t.images),
          o = s(t.shapes),
          l = s(t.skeletons),
          c = s(t.animations),
          h = s(t.nodes);
        e.length > 0 && (n.geometries = e),
          i.length > 0 && (n.materials = i),
          r.length > 0 && (n.textures = r),
          a.length > 0 && (n.images = a),
          o.length > 0 && (n.shapes = o),
          l.length > 0 && (n.skeletons = l),
          c.length > 0 && (n.animations = c),
          h.length > 0 && (n.nodes = h);
      }
      return (n.object = i), n;
      function s(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
    }
    clone(t) {
      return new this.constructor().copy(this, t);
    }
    copy(t, e = !0) {
      if (
        ((this.name = t.name),
        this.up.copy(t.up),
        this.position.copy(t.position),
        (this.rotation.order = t.rotation.order),
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
        (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
        (this.layers.mask = t.layers.mask),
        (this.visible = t.visible),
        (this.castShadow = t.castShadow),
        (this.receiveShadow = t.receiveShadow),
        (this.frustumCulled = t.frustumCulled),
        (this.renderOrder = t.renderOrder),
        (this.animations = t.animations.slice()),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        !0 === e)
      )
        for (let n = 0; n < t.children.length; n++) {
          const e = t.children[n];
          this.add(e.clone());
        }
      return this;
    }
  }
  (Oi.DEFAULT_UP = new Nn(0, 1, 0)),
    (Oi.DEFAULT_MATRIX_AUTO_UPDATE = !0),
    (Oi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
  const Di = new Nn(),
    Fi = new Nn(),
    Bi = new Nn(),
    zi = new Nn(),
    ki = new Nn(),
    Hi = new Nn(),
    Gi = new Nn(),
    Vi = new Nn(),
    Wi = new Nn(),
    ji = new Nn();
  let Xi = !1;
  class qi {
    constructor(t = new Nn(), e = new Nn(), n = new Nn()) {
      (this.a = t), (this.b = e), (this.c = n);
    }
    static getNormal(t, e, n, i) {
      i.subVectors(n, e), Di.subVectors(t, e), i.cross(Di);
      const r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    }
    static getBarycoord(t, e, n, i, r) {
      Di.subVectors(i, e), Fi.subVectors(n, e), Bi.subVectors(t, e);
      const s = Di.dot(Di),
        a = Di.dot(Fi),
        o = Di.dot(Bi),
        l = Fi.dot(Fi),
        c = Fi.dot(Bi),
        h = s * l - a * a;
      if (0 === h) return r.set(-2, -1, -1);
      const u = 1 / h,
        d = (l * o - a * c) * u,
        p = (s * c - a * o) * u;
      return r.set(1 - d - p, p, d);
    }
    static containsPoint(t, e, n, i) {
      return (
        this.getBarycoord(t, e, n, i, zi),
        zi.x >= 0 && zi.y >= 0 && zi.x + zi.y <= 1
      );
    }
    static getUV(t, e, n, i, r, s, a, o) {
      return (
        !1 === Xi &&
          (console.warn(
            "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().",
          ),
          (Xi = !0)),
        this.getInterpolation(t, e, n, i, r, s, a, o)
      );
    }
    static getInterpolation(t, e, n, i, r, s, a, o) {
      return (
        this.getBarycoord(t, e, n, i, zi),
        o.setScalar(0),
        o.addScaledVector(r, zi.x),
        o.addScaledVector(s, zi.y),
        o.addScaledVector(a, zi.z),
        o
      );
    }
    static isFrontFacing(t, e, n, i) {
      return Di.subVectors(n, e), Fi.subVectors(t, e), Di.cross(Fi).dot(i) < 0;
    }
    set(t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
    }
    setFromPointsAndIndices(t, e, n, i) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
    }
    setFromAttributeAndIndices(t, e, n, i) {
      return (
        this.a.fromBufferAttribute(t, e),
        this.b.fromBufferAttribute(t, n),
        this.c.fromBufferAttribute(t, i),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
    getArea() {
      return (
        Di.subVectors(this.c, this.b),
        Fi.subVectors(this.a, this.b),
        0.5 * Di.cross(Fi).length()
      );
    }
    getMidpoint(t) {
      return t
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3);
    }
    getNormal(t) {
      return qi.getNormal(this.a, this.b, this.c, t);
    }
    getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t, e) {
      return qi.getBarycoord(t, this.a, this.b, this.c, e);
    }
    getUV(t, e, n, i, r) {
      return (
        !1 === Xi &&
          (console.warn(
            "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().",
          ),
          (Xi = !0)),
        qi.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
      );
    }
    getInterpolation(t, e, n, i, r) {
      return qi.getInterpolation(t, this.a, this.b, this.c, e, n, i, r);
    }
    containsPoint(t) {
      return qi.containsPoint(t, this.a, this.b, this.c);
    }
    isFrontFacing(t) {
      return qi.isFrontFacing(this.a, this.b, this.c, t);
    }
    intersectsBox(t) {
      return t.intersectsTriangle(this);
    }
    closestPointToPoint(t, e) {
      const n = this.a,
        i = this.b,
        r = this.c;
      let s, a;
      ki.subVectors(i, n), Hi.subVectors(r, n), Vi.subVectors(t, n);
      const o = ki.dot(Vi),
        l = Hi.dot(Vi);
      if (o <= 0 && l <= 0) return e.copy(n);
      Wi.subVectors(t, i);
      const c = ki.dot(Wi),
        h = Hi.dot(Wi);
      if (c >= 0 && h <= c) return e.copy(i);
      const u = o * h - c * l;
      if (u <= 0 && o >= 0 && c <= 0)
        return (s = o / (o - c)), e.copy(n).addScaledVector(ki, s);
      ji.subVectors(t, r);
      const d = ki.dot(ji),
        p = Hi.dot(ji);
      if (p >= 0 && d <= p) return e.copy(r);
      const f = d * l - o * p;
      if (f <= 0 && l >= 0 && p <= 0)
        return (a = l / (l - p)), e.copy(n).addScaledVector(Hi, a);
      const m = c * p - d * h;
      if (m <= 0 && h - c >= 0 && d - p >= 0)
        return (
          Gi.subVectors(r, i),
          (a = (h - c) / (h - c + (d - p))),
          e.copy(i).addScaledVector(Gi, a)
        );
      const g = 1 / (m + f + u);
      return (
        (s = f * g),
        (a = u * g),
        e.copy(n).addScaledVector(ki, s).addScaledVector(Hi, a)
      );
    }
    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }
  let Yi = 0;
  class Ki extends Ve {
    constructor() {
      super(),
        (this.isMaterial = !0),
        Object.defineProperty(this, "id", { value: Yi++ }),
        (this.uuid = Ye()),
        (this.name = ""),
        (this.type = "Material"),
        (this.blending = 1),
        (this.side = at),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.alphaHash = !1),
        (this.blendSrc = 204),
        (this.blendDst = 205),
        (this.blendEquation = lt),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = 3),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = 519),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = Fe),
        (this.stencilZFail = Fe),
        (this.stencilZPass = Fe),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaToCoverage = !1),
        (this.premultipliedAlpha = !1),
        (this.forceSinglePass = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0),
        (this._alphaTest = 0);
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(t) {
      this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t) {
      if (void 0 !== t)
        for (const e in t) {
          const n = t[e];
          if (void 0 === n) {
            console.warn(
              `THREE.Material: parameter '${e}' has value of undefined.`,
            );
            continue;
          }
          const i = this[e];
          void 0 !== i
            ? i && i.isColor
              ? i.set(n)
              : i && i.isVector3 && n && n.isVector3
              ? i.copy(n)
              : (this[e] = n)
            : console.warn(
                `THREE.Material: '${e}' is not a property of THREE.${this.type}.`,
              );
        }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      e && (t = { textures: {}, images: {} });
      const n = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON",
        },
      };
      function i(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        "" !== this.name && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        void 0 !== this.roughness && (n.roughness = this.roughness),
        void 0 !== this.metalness && (n.metalness = this.metalness),
        void 0 !== this.sheen && (n.sheen = this.sheen),
        this.sheenColor &&
          this.sheenColor.isColor &&
          (n.sheenColor = this.sheenColor.getHex()),
        void 0 !== this.sheenRoughness &&
          (n.sheenRoughness = this.sheenRoughness),
        this.emissive &&
          this.emissive.isColor &&
          (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity &&
          1 !== this.emissiveIntensity &&
          (n.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (n.specular = this.specular.getHex()),
        void 0 !== this.specularIntensity &&
          (n.specularIntensity = this.specularIntensity),
        this.specularColor &&
          this.specularColor.isColor &&
          (n.specularColor = this.specularColor.getHex()),
        void 0 !== this.shininess && (n.shininess = this.shininess),
        void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness &&
          (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
          (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        void 0 !== this.iridescence && (n.iridescence = this.iridescence),
        void 0 !== this.iridescenceIOR &&
          (n.iridescenceIOR = this.iridescenceIOR),
        void 0 !== this.iridescenceThicknessRange &&
          (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap &&
          this.iridescenceMap.isTexture &&
          (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
        this.iridescenceThicknessMap &&
          this.iridescenceThicknessMap.isTexture &&
          (n.iridescenceThicknessMap =
            this.iridescenceThicknessMap.toJSON(t).uuid),
        void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
        void 0 !== this.anisotropyRotation &&
          (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap &&
          this.anisotropyMap.isTexture &&
          (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (n.matcap = this.matcap.toJSON(t).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (n.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          ((n.lightMap = this.lightMap.toJSON(t).uuid),
          (n.lightMapIntensity = this.lightMapIntensity)),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((n.aoMap = this.aoMap.toJSON(t).uuid),
          (n.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
          (n.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((n.normalMap = this.normalMap.toJSON(t).uuid),
          (n.normalMapType = this.normalMapType),
          (n.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
          (n.displacementScale = this.displacementScale),
          (n.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (n.specularMap = this.specularMap.toJSON(t).uuid),
        this.specularIntensityMap &&
          this.specularIntensityMap.isTexture &&
          (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
        this.specularColorMap &&
          this.specularColorMap.isTexture &&
          (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((n.envMap = this.envMap.toJSON(t).uuid),
          void 0 !== this.combine && (n.combine = this.combine)),
        void 0 !== this.envMapIntensity &&
          (n.envMapIntensity = this.envMapIntensity),
        void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
        void 0 !== this.refractionRatio &&
          (n.refractionRatio = this.refractionRatio),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (n.gradientMap = this.gradientMap.toJSON(t).uuid),
        void 0 !== this.transmission && (n.transmission = this.transmission),
        this.transmissionMap &&
          this.transmissionMap.isTexture &&
          (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
        void 0 !== this.thickness && (n.thickness = this.thickness),
        this.thicknessMap &&
          this.thicknessMap.isTexture &&
          (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
        void 0 !== this.attenuationDistance &&
          this.attenuationDistance !== 1 / 0 &&
          (n.attenuationDistance = this.attenuationDistance),
        void 0 !== this.attenuationColor &&
          (n.attenuationColor = this.attenuationColor.getHex()),
        void 0 !== this.size && (n.size = this.size),
        null !== this.shadowSide && (n.shadowSide = this.shadowSide),
        void 0 !== this.sizeAttenuation &&
          (n.sizeAttenuation = this.sizeAttenuation),
        1 !== this.blending && (n.blending = this.blending),
        this.side !== at && (n.side = this.side),
        this.vertexColors && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        !0 === this.transparent && (n.transparent = this.transparent),
        (n.depthFunc = this.depthFunc),
        (n.depthTest = this.depthTest),
        (n.depthWrite = this.depthWrite),
        (n.colorWrite = this.colorWrite),
        (n.stencilWrite = this.stencilWrite),
        (n.stencilWriteMask = this.stencilWriteMask),
        (n.stencilFunc = this.stencilFunc),
        (n.stencilRef = this.stencilRef),
        (n.stencilFuncMask = this.stencilFuncMask),
        (n.stencilFail = this.stencilFail),
        (n.stencilZFail = this.stencilZFail),
        (n.stencilZPass = this.stencilZPass),
        void 0 !== this.rotation &&
          0 !== this.rotation &&
          (n.rotation = this.rotation),
        !0 === this.polygonOffset && (n.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (n.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits &&
          (n.polygonOffsetUnits = this.polygonOffsetUnits),
        void 0 !== this.linewidth &&
          1 !== this.linewidth &&
          (n.linewidth = this.linewidth),
        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
        void 0 !== this.scale && (n.scale = this.scale),
        !0 === this.dithering && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        !0 === this.alphaHash && (n.alphaHash = this.alphaHash),
        !0 === this.alphaToCoverage &&
          (n.alphaToCoverage = this.alphaToCoverage),
        !0 === this.premultipliedAlpha &&
          (n.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.forceSinglePass &&
          (n.forceSinglePass = this.forceSinglePass),
        !0 === this.wireframe && (n.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 &&
          (n.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap &&
          (n.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin &&
          (n.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.flatShading && (n.flatShading = this.flatShading),
        !1 === this.visible && (n.visible = !1),
        !1 === this.toneMapped && (n.toneMapped = !1),
        !1 === this.fog && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        e)
      ) {
        const e = i(t.textures),
          r = i(t.images);
        e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
      }
      return n;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.name = t.name),
        (this.blending = t.blending),
        (this.side = t.side),
        (this.vertexColors = t.vertexColors),
        (this.opacity = t.opacity),
        (this.transparent = t.transparent),
        (this.blendSrc = t.blendSrc),
        (this.blendDst = t.blendDst),
        (this.blendEquation = t.blendEquation),
        (this.blendSrcAlpha = t.blendSrcAlpha),
        (this.blendDstAlpha = t.blendDstAlpha),
        (this.blendEquationAlpha = t.blendEquationAlpha),
        (this.depthFunc = t.depthFunc),
        (this.depthTest = t.depthTest),
        (this.depthWrite = t.depthWrite),
        (this.stencilWriteMask = t.stencilWriteMask),
        (this.stencilFunc = t.stencilFunc),
        (this.stencilRef = t.stencilRef),
        (this.stencilFuncMask = t.stencilFuncMask),
        (this.stencilFail = t.stencilFail),
        (this.stencilZFail = t.stencilZFail),
        (this.stencilZPass = t.stencilZPass),
        (this.stencilWrite = t.stencilWrite);
      const e = t.clippingPlanes;
      let n = null;
      if (null !== e) {
        const t = e.length;
        n = new Array(t);
        for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
      }
      return (
        (this.clippingPlanes = n),
        (this.clipIntersection = t.clipIntersection),
        (this.clipShadows = t.clipShadows),
        (this.shadowSide = t.shadowSide),
        (this.colorWrite = t.colorWrite),
        (this.precision = t.precision),
        (this.polygonOffset = t.polygonOffset),
        (this.polygonOffsetFactor = t.polygonOffsetFactor),
        (this.polygonOffsetUnits = t.polygonOffsetUnits),
        (this.dithering = t.dithering),
        (this.alphaTest = t.alphaTest),
        (this.alphaHash = t.alphaHash),
        (this.alphaToCoverage = t.alphaToCoverage),
        (this.premultipliedAlpha = t.premultipliedAlpha),
        (this.forceSinglePass = t.forceSinglePass),
        (this.visible = t.visible),
        (this.toneMapped = t.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
  }
  const Zi = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    Ji = { h: 0, s: 0, l: 0 },
    $i = { h: 0, s: 0, l: 0 };
  function Qi(t, e, n) {
    return (
      n < 0 && (n += 1),
      n > 1 && (n -= 1),
      n < 1 / 6
        ? t + 6 * (e - t) * n
        : n < 0.5
        ? e
        : n < 2 / 3
        ? t + 6 * (e - t) * (2 / 3 - n)
        : t
    );
  }
  class tr {
    constructor(t, e, n) {
      return (
        (this.isColor = !0),
        (this.r = 1),
        (this.g = 1),
        (this.b = 1),
        this.set(t, e, n)
      );
    }
    set(t, e, n) {
      if (void 0 === e && void 0 === n) {
        const e = t;
        e && e.isColor
          ? this.copy(e)
          : "number" == typeof e
          ? this.setHex(e)
          : "string" == typeof e && this.setStyle(e);
      } else this.setRGB(t, e, n);
      return this;
    }
    setScalar(t) {
      return (this.r = t), (this.g = t), (this.b = t), this;
    }
    setHex(t, e = Ne) {
      return (
        (t = Math.floor(t)),
        (this.r = ((t >> 16) & 255) / 255),
        (this.g = ((t >> 8) & 255) / 255),
        (this.b = (255 & t) / 255),
        xn.toWorkingColorSpace(this, e),
        this
      );
    }
    setRGB(t, e, n, i = xn.workingColorSpace) {
      return (
        (this.r = t),
        (this.g = e),
        (this.b = n),
        xn.toWorkingColorSpace(this, i),
        this
      );
    }
    setHSL(t, e, n, i = xn.workingColorSpace) {
      if (((t = Ze(t, 1)), (e = Ke(e, 0, 1)), (n = Ke(n, 0, 1)), 0 === e))
        this.r = this.g = this.b = n;
      else {
        const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
          r = 2 * n - i;
        (this.r = Qi(r, i, t + 1 / 3)),
          (this.g = Qi(r, i, t)),
          (this.b = Qi(r, i, t - 1 / 3));
      }
      return xn.toWorkingColorSpace(this, i), this;
    }
    setStyle(t, e = Ne) {
      function n(e) {
        void 0 !== e &&
          parseFloat(e) < 1 &&
          console.warn(
            "THREE.Color: Alpha component of " + t + " will be ignored.",
          );
      }
      let i;
      if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
        let r;
        const s = i[1],
          a = i[2];
        switch (s) {
          case "rgb":
          case "rgba":
            if (
              (r =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a,
                ))
            )
              return (
                n(r[4]),
                this.setRGB(
                  Math.min(255, parseInt(r[1], 10)) / 255,
                  Math.min(255, parseInt(r[2], 10)) / 255,
                  Math.min(255, parseInt(r[3], 10)) / 255,
                  e,
                )
              );
            if (
              (r =
                /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a,
                ))
            )
              return (
                n(r[4]),
                this.setRGB(
                  Math.min(100, parseInt(r[1], 10)) / 100,
                  Math.min(100, parseInt(r[2], 10)) / 100,
                  Math.min(100, parseInt(r[3], 10)) / 100,
                  e,
                )
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (r =
                /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a,
                ))
            )
              return (
                n(r[4]),
                this.setHSL(
                  parseFloat(r[1]) / 360,
                  parseFloat(r[2]) / 100,
                  parseFloat(r[3]) / 100,
                  e,
                )
              );
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + t);
        }
      } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
        const n = i[1],
          r = n.length;
        if (3 === r)
          return this.setRGB(
            parseInt(n.charAt(0), 16) / 15,
            parseInt(n.charAt(1), 16) / 15,
            parseInt(n.charAt(2), 16) / 15,
            e,
          );
        if (6 === r) return this.setHex(parseInt(n, 16), e);
        console.warn("THREE.Color: Invalid hex color " + t);
      } else if (t && t.length > 0) return this.setColorName(t, e);
      return this;
    }
    setColorName(t, e = Ne) {
      const n = Zi[t.toLowerCase()];
      return (
        void 0 !== n
          ? this.setHex(n, e)
          : console.warn("THREE.Color: Unknown color " + t),
        this
      );
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(t) {
      return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
    }
    copySRGBToLinear(t) {
      return (this.r = fn(t.r)), (this.g = fn(t.g)), (this.b = fn(t.b)), this;
    }
    copyLinearToSRGB(t) {
      return (this.r = mn(t.r)), (this.g = mn(t.g)), (this.b = mn(t.b)), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(t = Ne) {
      return (
        xn.fromWorkingColorSpace(er.copy(this), t),
        65536 * Math.round(Ke(255 * er.r, 0, 255)) +
          256 * Math.round(Ke(255 * er.g, 0, 255)) +
          Math.round(Ke(255 * er.b, 0, 255))
      );
    }
    getHexString(t = Ne) {
      return ("000000" + this.getHex(t).toString(16)).slice(-6);
    }
    getHSL(t, e = xn.workingColorSpace) {
      xn.fromWorkingColorSpace(er.copy(this), e);
      const n = er.r,
        i = er.g,
        r = er.b,
        s = Math.max(n, i, r),
        a = Math.min(n, i, r);
      let o, l;
      const c = (a + s) / 2;
      if (a === s) (o = 0), (l = 0);
      else {
        const t = s - a;
        switch (((l = c <= 0.5 ? t / (s + a) : t / (2 - s - a)), s)) {
          case n:
            o = (i - r) / t + (i < r ? 6 : 0);
            break;
          case i:
            o = (r - n) / t + 2;
            break;
          case r:
            o = (n - i) / t + 4;
        }
        o /= 6;
      }
      return (t.h = o), (t.s = l), (t.l = c), t;
    }
    getRGB(t, e = xn.workingColorSpace) {
      return (
        xn.fromWorkingColorSpace(er.copy(this), e),
        (t.r = er.r),
        (t.g = er.g),
        (t.b = er.b),
        t
      );
    }
    getStyle(t = Ne) {
      xn.fromWorkingColorSpace(er.copy(this), t);
      const e = er.r,
        n = er.g,
        i = er.b;
      return t !== Ne
        ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
        : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(
            255 * i,
          )})`;
    }
    offsetHSL(t, e, n) {
      return (
        this.getHSL(Ji),
        (Ji.h += t),
        (Ji.s += e),
        (Ji.l += n),
        this.setHSL(Ji.h, Ji.s, Ji.l),
        this
      );
    }
    add(t) {
      return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
    }
    addColors(t, e) {
      return (
        (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
      );
    }
    addScalar(t) {
      return (this.r += t), (this.g += t), (this.b += t), this;
    }
    sub(t) {
      return (
        (this.r = Math.max(0, this.r - t.r)),
        (this.g = Math.max(0, this.g - t.g)),
        (this.b = Math.max(0, this.b - t.b)),
        this
      );
    }
    multiply(t) {
      return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
    }
    multiplyScalar(t) {
      return (this.r *= t), (this.g *= t), (this.b *= t), this;
    }
    lerp(t, e) {
      return (
        (this.r += (t.r - this.r) * e),
        (this.g += (t.g - this.g) * e),
        (this.b += (t.b - this.b) * e),
        this
      );
    }
    lerpColors(t, e, n) {
      return (
        (this.r = t.r + (e.r - t.r) * n),
        (this.g = t.g + (e.g - t.g) * n),
        (this.b = t.b + (e.b - t.b) * n),
        this
      );
    }
    lerpHSL(t, e) {
      this.getHSL(Ji), t.getHSL($i);
      const n = Je(Ji.h, $i.h, e),
        i = Je(Ji.s, $i.s, e),
        r = Je(Ji.l, $i.l, e);
      return this.setHSL(n, i, r), this;
    }
    setFromVector3(t) {
      return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
    }
    applyMatrix3(t) {
      const e = this.r,
        n = this.g,
        i = this.b,
        r = t.elements;
      return (
        (this.r = r[0] * e + r[3] * n + r[6] * i),
        (this.g = r[1] * e + r[4] * n + r[7] * i),
        (this.b = r[2] * e + r[5] * n + r[8] * i),
        this
      );
    }
    equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    }
    fromArray(t, e = 0) {
      return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
    }
    fromBufferAttribute(t, e) {
      return (
        (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this
      );
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  const er = new tr();
  tr.NAMES = Zi;
  class nr extends Ki {
    constructor(t) {
      super(),
        (this.isMeshBasicMaterial = !0),
        (this.type = "MeshBasicMaterial"),
        (this.color = new tr(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = ct),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.fog = t.fog),
        this
      );
    }
  }
  const ir = rr();
  function rr() {
    const t = new ArrayBuffer(4),
      e = new Float32Array(t),
      n = new Uint32Array(t),
      i = new Uint32Array(512),
      r = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
      const t = l - 127;
      t < -27
        ? ((i[l] = 0), (i[256 | l] = 32768), (r[l] = 24), (r[256 | l] = 24))
        : t < -14
        ? ((i[l] = 1024 >> (-t - 14)),
          (i[256 | l] = (1024 >> (-t - 14)) | 32768),
          (r[l] = -t - 1),
          (r[256 | l] = -t - 1))
        : t <= 15
        ? ((i[l] = (t + 15) << 10),
          (i[256 | l] = ((t + 15) << 10) | 32768),
          (r[l] = 13),
          (r[256 | l] = 13))
        : t < 128
        ? ((i[l] = 31744), (i[256 | l] = 64512), (r[l] = 24), (r[256 | l] = 24))
        : ((i[l] = 31744),
          (i[256 | l] = 64512),
          (r[l] = 13),
          (r[256 | l] = 13));
    }
    const s = new Uint32Array(2048),
      a = new Uint32Array(64),
      o = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
      let t = l << 13,
        e = 0;
      for (; 0 == (8388608 & t); ) (t <<= 1), (e -= 8388608);
      (t &= -8388609), (e += 947912704), (s[l] = t | e);
    }
    for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
    for (let l = 1; l < 31; ++l) a[l] = l << 23;
    (a[31] = 1199570944), (a[32] = 2147483648);
    for (let l = 33; l < 63; ++l) a[l] = 2147483648 + ((l - 32) << 23);
    a[63] = 3347054592;
    for (let l = 1; l < 64; ++l) 32 !== l && (o[l] = 1024);
    return {
      floatView: e,
      uint32View: n,
      baseTable: i,
      shiftTable: r,
      mantissaTable: s,
      exponentTable: a,
      offsetTable: o,
    };
  }
  function sr(t) {
    Math.abs(t) > 65504 &&
      console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
      (t = Ke(t, -65504, 65504)),
      (ir.floatView[0] = t);
    const e = ir.uint32View[0],
      n = (e >> 23) & 511;
    return ir.baseTable[n] + ((8388607 & e) >> ir.shiftTable[n]);
  }
  function ar(t) {
    const e = t >> 10;
    return (
      (ir.uint32View[0] =
        ir.mantissaTable[ir.offsetTable[e] + (1023 & t)] + ir.exponentTable[e]),
      ir.floatView[0]
    );
  }
  const or = { toHalfFloat: sr, fromHalfFloat: ar },
    lr = new Nn(),
    cr = new sn();
  class hr {
    constructor(t, e, n = !1) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array.",
        );
      (this.isBufferAttribute = !0),
        (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = n),
        (this.usage = Be),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.gpuType = Ft),
        (this.version = 0);
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    setUsage(t) {
      return (this.usage = t), this;
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.array = new t.array.constructor(t.array)),
        (this.itemSize = t.itemSize),
        (this.count = t.count),
        (this.normalized = t.normalized),
        (this.usage = t.usage),
        (this.gpuType = t.gpuType),
        this
      );
    }
    copyAt(t, e, n) {
      (t *= this.itemSize), (n *= e.itemSize);
      for (let i = 0, r = this.itemSize; i < r; i++)
        this.array[t + i] = e.array[n + i];
      return this;
    }
    copyArray(t) {
      return this.array.set(t), this;
    }
    applyMatrix3(t) {
      if (2 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          cr.fromBufferAttribute(this, e),
            cr.applyMatrix3(t),
            this.setXY(e, cr.x, cr.y);
      else if (3 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          lr.fromBufferAttribute(this, e),
            lr.applyMatrix3(t),
            this.setXYZ(e, lr.x, lr.y, lr.z);
      return this;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.count; e < n; e++)
        lr.fromBufferAttribute(this, e),
          lr.applyMatrix4(t),
          this.setXYZ(e, lr.x, lr.y, lr.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++)
        lr.fromBufferAttribute(this, e),
          lr.applyNormalMatrix(t),
          this.setXYZ(e, lr.x, lr.y, lr.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++)
        lr.fromBufferAttribute(this, e),
          lr.transformDirection(t),
          this.setXYZ(e, lr.x, lr.y, lr.z);
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    getComponent(t, e) {
      let n = this.array[t * this.itemSize + e];
      return this.normalized && (n = en(n, this.array)), n;
    }
    setComponent(t, e, n) {
      return (
        this.normalized && (n = nn(n, this.array)),
        (this.array[t * this.itemSize + e] = n),
        this
      );
    }
    getX(t) {
      let e = this.array[t * this.itemSize];
      return this.normalized && (e = en(e, this.array)), e;
    }
    setX(t, e) {
      return (
        this.normalized && (e = nn(e, this.array)),
        (this.array[t * this.itemSize] = e),
        this
      );
    }
    getY(t) {
      let e = this.array[t * this.itemSize + 1];
      return this.normalized && (e = en(e, this.array)), e;
    }
    setY(t, e) {
      return (
        this.normalized && (e = nn(e, this.array)),
        (this.array[t * this.itemSize + 1] = e),
        this
      );
    }
    getZ(t) {
      let e = this.array[t * this.itemSize + 2];
      return this.normalized && (e = en(e, this.array)), e;
    }
    setZ(t, e) {
      return (
        this.normalized && (e = nn(e, this.array)),
        (this.array[t * this.itemSize + 2] = e),
        this
      );
    }
    getW(t) {
      let e = this.array[t * this.itemSize + 3];
      return this.normalized && (e = en(e, this.array)), e;
    }
    setW(t, e) {
      return (
        this.normalized && (e = nn(e, this.array)),
        (this.array[t * this.itemSize + 3] = e),
        this
      );
    }
    setXY(t, e, n) {
      return (
        (t *= this.itemSize),
        this.normalized && ((e = nn(e, this.array)), (n = nn(n, this.array))),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        this
      );
    }
    setXYZ(t, e, n, i) {
      return (
        (t *= this.itemSize),
        this.normalized &&
          ((e = nn(e, this.array)),
          (n = nn(n, this.array)),
          (i = nn(i, this.array))),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        this
      );
    }
    setXYZW(t, e, n, i, r) {
      return (
        (t *= this.itemSize),
        this.normalized &&
          ((e = nn(e, this.array)),
          (n = nn(n, this.array)),
          (i = nn(i, this.array)),
          (r = nn(r, this.array))),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        (this.array[t + 3] = r),
        this
      );
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized,
      };
      return (
        "" !== this.name && (t.name = this.name),
        this.usage !== Be && (t.usage = this.usage),
        (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
          (t.updateRange = this.updateRange),
        t
      );
    }
  }
  class ur extends hr {
    constructor(t, e, n) {
      super(new Uint16Array(t), e, n);
    }
  }
  class dr extends hr {
    constructor(t, e, n) {
      super(new Uint32Array(t), e, n);
    }
  }
  class pr extends hr {
    constructor(t, e, n) {
      super(new Float32Array(t), e, n);
    }
  }
  let fr = 0;
  const mr = new hi(),
    gr = new Oi(),
    vr = new Nn(),
    _r = new Fn(),
    yr = new Fn(),
    xr = new Nn();
  class Mr extends Ve {
    constructor() {
      super(),
        (this.isBufferGeometry = !0),
        Object.defineProperty(this, "id", { value: fr++ }),
        (this.uuid = Ye()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    getIndex() {
      return this.index;
    }
    setIndex(t) {
      return (
        Array.isArray(t)
          ? (this.index = new (ln(t) ? dr : ur)(t, 1))
          : (this.index = t),
        this
      );
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    setAttribute(t, e) {
      return (this.attributes[t] = e), this;
    }
    deleteAttribute(t) {
      return delete this.attributes[t], this;
    }
    hasAttribute(t) {
      return void 0 !== this.attributes[t];
    }
    addGroup(t, e, n = 0) {
      this.groups.push({ start: t, count: e, materialIndex: n });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t, e) {
      (this.drawRange.start = t), (this.drawRange.count = e);
    }
    applyMatrix4(t) {
      const e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
      const n = this.attributes.normal;
      if (void 0 !== n) {
        const e = new an().getNormalMatrix(t);
        n.applyNormalMatrix(e), (n.needsUpdate = !0);
      }
      const i = this.attributes.tangent;
      return (
        void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    }
    applyQuaternion(t) {
      return mr.makeRotationFromQuaternion(t), this.applyMatrix4(mr), this;
    }
    rotateX(t) {
      return mr.makeRotationX(t), this.applyMatrix4(mr), this;
    }
    rotateY(t) {
      return mr.makeRotationY(t), this.applyMatrix4(mr), this;
    }
    rotateZ(t) {
      return mr.makeRotationZ(t), this.applyMatrix4(mr), this;
    }
    translate(t, e, n) {
      return mr.makeTranslation(t, e, n), this.applyMatrix4(mr), this;
    }
    scale(t, e, n) {
      return mr.makeScale(t, e, n), this.applyMatrix4(mr), this;
    }
    lookAt(t) {
      return (
        gr.lookAt(t), gr.updateMatrix(), this.applyMatrix4(gr.matrix), this
      );
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(vr).negate(),
        this.translate(vr.x, vr.y, vr.z),
        this
      );
    }
    setFromPoints(t) {
      const e = [];
      for (let n = 0, i = t.length; n < i; n++) {
        const i = t[n];
        e.push(i.x, i.y, i.z || 0);
      }
      return this.setAttribute("position", new pr(e, 3)), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new Fn());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
            this,
          ),
          void this.boundingBox.set(
            new Nn(-1 / 0, -1 / 0, -1 / 0),
            new Nn(1 / 0, 1 / 0, 1 / 0),
          )
        );
      if (void 0 !== t) {
        if ((this.boundingBox.setFromBufferAttribute(t), e))
          for (let n = 0, i = e.length; n < i; n++) {
            const t = e[n];
            _r.setFromBufferAttribute(t),
              this.morphTargetsRelative
                ? (xr.addVectors(this.boundingBox.min, _r.min),
                  this.boundingBox.expandByPoint(xr),
                  xr.addVectors(this.boundingBox.max, _r.max),
                  this.boundingBox.expandByPoint(xr))
                : (this.boundingBox.expandByPoint(_r.min),
                  this.boundingBox.expandByPoint(_r.max));
          }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this,
        );
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new ei());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
            this,
          ),
          void this.boundingSphere.set(new Nn(), 1 / 0)
        );
      if (t) {
        const n = this.boundingSphere.center;
        if ((_r.setFromBufferAttribute(t), e))
          for (let t = 0, r = e.length; t < r; t++) {
            const n = e[t];
            yr.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (xr.addVectors(_r.min, yr.min),
                  _r.expandByPoint(xr),
                  xr.addVectors(_r.max, yr.max),
                  _r.expandByPoint(xr))
                : (_r.expandByPoint(yr.min), _r.expandByPoint(yr.max));
          }
        _r.getCenter(n);
        let i = 0;
        for (let e = 0, r = t.count; e < r; e++)
          xr.fromBufferAttribute(t, e),
            (i = Math.max(i, n.distanceToSquared(xr)));
        if (e)
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r],
              a = this.morphTargetsRelative;
            for (let e = 0, r = s.count; e < r; e++)
              xr.fromBufferAttribute(s, e),
                a && (vr.fromBufferAttribute(t, e), xr.add(vr)),
                (i = Math.max(i, n.distanceToSquared(xr)));
          }
        (this.boundingSphere.radius = Math.sqrt(i)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this,
            );
      }
    }
    computeTangents() {
      const t = this.index,
        e = this.attributes;
      if (
        null === t ||
        void 0 === e.position ||
        void 0 === e.normal ||
        void 0 === e.uv
      )
        return void console.error(
          "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
        );
      const n = t.array,
        i = e.position.array,
        r = e.normal.array,
        s = e.uv.array,
        a = i.length / 3;
      !1 === this.hasAttribute("tangent") &&
        this.setAttribute("tangent", new hr(new Float32Array(4 * a), 4));
      const o = this.getAttribute("tangent").array,
        l = [],
        c = [];
      for (let w = 0; w < a; w++) (l[w] = new Nn()), (c[w] = new Nn());
      const h = new Nn(),
        u = new Nn(),
        d = new Nn(),
        p = new sn(),
        f = new sn(),
        m = new sn(),
        g = new Nn(),
        v = new Nn();
      function _(t, e, n) {
        h.fromArray(i, 3 * t),
          u.fromArray(i, 3 * e),
          d.fromArray(i, 3 * n),
          p.fromArray(s, 2 * t),
          f.fromArray(s, 2 * e),
          m.fromArray(s, 2 * n),
          u.sub(h),
          d.sub(h),
          f.sub(p),
          m.sub(p);
        const r = 1 / (f.x * m.y - m.x * f.y);
        isFinite(r) &&
          (g
            .copy(u)
            .multiplyScalar(m.y)
            .addScaledVector(d, -f.y)
            .multiplyScalar(r),
          v
            .copy(d)
            .multiplyScalar(f.x)
            .addScaledVector(u, -m.x)
            .multiplyScalar(r),
          l[t].add(g),
          l[e].add(g),
          l[n].add(g),
          c[t].add(v),
          c[e].add(v),
          c[n].add(v));
      }
      let y = this.groups;
      0 === y.length && (y = [{ start: 0, count: n.length }]);
      for (let w = 0, E = y.length; w < E; ++w) {
        const t = y[w],
          e = t.start;
        for (let i = e, r = e + t.count; i < r; i += 3)
          _(n[i + 0], n[i + 1], n[i + 2]);
      }
      const x = new Nn(),
        M = new Nn(),
        S = new Nn(),
        b = new Nn();
      function T(t) {
        S.fromArray(r, 3 * t), b.copy(S);
        const e = l[t];
        x.copy(e),
          x.sub(S.multiplyScalar(S.dot(e))).normalize(),
          M.crossVectors(b, e);
        const n = M.dot(c[t]) < 0 ? -1 : 1;
        (o[4 * t] = x.x),
          (o[4 * t + 1] = x.y),
          (o[4 * t + 2] = x.z),
          (o[4 * t + 3] = n);
      }
      for (let w = 0, E = y.length; w < E; ++w) {
        const t = y[w],
          e = t.start;
        for (let i = e, r = e + t.count; i < r; i += 3)
          T(n[i + 0]), T(n[i + 1]), T(n[i + 2]);
      }
    }
    computeVertexNormals() {
      const t = this.index,
        e = this.getAttribute("position");
      if (void 0 !== e) {
        let n = this.getAttribute("normal");
        if (void 0 === n)
          (n = new hr(new Float32Array(3 * e.count), 3)),
            this.setAttribute("normal", n);
        else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
        const i = new Nn(),
          r = new Nn(),
          s = new Nn(),
          a = new Nn(),
          o = new Nn(),
          l = new Nn(),
          c = new Nn(),
          h = new Nn();
        if (t)
          for (let u = 0, d = t.count; u < d; u += 3) {
            const d = t.getX(u + 0),
              p = t.getX(u + 1),
              f = t.getX(u + 2);
            i.fromBufferAttribute(e, d),
              r.fromBufferAttribute(e, p),
              s.fromBufferAttribute(e, f),
              c.subVectors(s, r),
              h.subVectors(i, r),
              c.cross(h),
              a.fromBufferAttribute(n, d),
              o.fromBufferAttribute(n, p),
              l.fromBufferAttribute(n, f),
              a.add(c),
              o.add(c),
              l.add(c),
              n.setXYZ(d, a.x, a.y, a.z),
              n.setXYZ(p, o.x, o.y, o.z),
              n.setXYZ(f, l.x, l.y, l.z);
          }
        else
          for (let t = 0, u = e.count; t < u; t += 3)
            i.fromBufferAttribute(e, t + 0),
              r.fromBufferAttribute(e, t + 1),
              s.fromBufferAttribute(e, t + 2),
              c.subVectors(s, r),
              h.subVectors(i, r),
              c.cross(h),
              n.setXYZ(t + 0, c.x, c.y, c.z),
              n.setXYZ(t + 1, c.x, c.y, c.z),
              n.setXYZ(t + 2, c.x, c.y, c.z);
        this.normalizeNormals(), (n.needsUpdate = !0);
      }
    }
    normalizeNormals() {
      const t = this.attributes.normal;
      for (let e = 0, n = t.count; e < n; e++)
        xr.fromBufferAttribute(t, e),
          xr.normalize(),
          t.setXYZ(e, xr.x, xr.y, xr.z);
    }
    toNonIndexed() {
      function t(t, e) {
        const n = t.array,
          i = t.itemSize,
          r = t.normalized,
          s = new n.constructor(e.length * i);
        let a = 0,
          o = 0;
        for (let l = 0, c = e.length; l < c; l++) {
          a = t.isInterleavedBufferAttribute
            ? e[l] * t.data.stride + t.offset
            : e[l] * i;
          for (let t = 0; t < i; t++) s[o++] = n[a++];
        }
        return new hr(s, i, r);
      }
      if (null === this.index)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
          ),
          this
        );
      const e = new Mr(),
        n = this.index.array,
        i = this.attributes;
      for (const a in i) {
        const r = t(i[a], n);
        e.setAttribute(a, r);
      }
      const r = this.morphAttributes;
      for (const a in r) {
        const i = [],
          s = r[a];
        for (let e = 0, r = s.length; e < r; e++) {
          const r = t(s[e], n);
          i.push(r);
        }
        e.morphAttributes[a] = i;
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      const s = this.groups;
      for (let a = 0, o = s.length; a < o; a++) {
        const t = s[a];
        e.addGroup(t.start, t.count, t.materialIndex);
      }
      return e;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        "" !== this.name && (t.name = this.name),
        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        const e = this.parameters;
        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
        return t;
      }
      t.data = { attributes: {} };
      const e = this.index;
      null !== e &&
        (t.data.index = {
          type: e.array.constructor.name,
          array: Array.prototype.slice.call(e.array),
        });
      const n = this.attributes;
      for (const o in n) {
        const e = n[o];
        t.data.attributes[o] = e.toJSON(t.data);
      }
      const i = {};
      let r = !1;
      for (const o in this.morphAttributes) {
        const e = this.morphAttributes[o],
          n = [];
        for (let i = 0, r = e.length; i < r; i++) {
          const r = e[i];
          n.push(r.toJSON(t.data));
        }
        n.length > 0 && ((i[o] = n), (r = !0));
      }
      r &&
        ((t.data.morphAttributes = i),
        (t.data.morphTargetsRelative = this.morphTargetsRelative));
      const s = this.groups;
      s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
      const a = this.boundingSphere;
      return (
        null !== a &&
          (t.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius,
          }),
        t
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      const e = {};
      this.name = t.name;
      const n = t.index;
      null !== n && this.setIndex(n.clone(e));
      const i = t.attributes;
      for (const l in i) {
        const t = i[l];
        this.setAttribute(l, t.clone(e));
      }
      const r = t.morphAttributes;
      for (const l in r) {
        const t = [],
          n = r[l];
        for (let i = 0, r = n.length; i < r; i++) t.push(n[i].clone(e));
        this.morphAttributes[l] = t;
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      const s = t.groups;
      for (let l = 0, c = s.length; l < c; l++) {
        const t = s[l];
        this.addGroup(t.start, t.count, t.materialIndex);
      }
      const a = t.boundingBox;
      null !== a && (this.boundingBox = a.clone());
      const o = t.boundingSphere;
      return (
        null !== o && (this.boundingSphere = o.clone()),
        (this.drawRange.start = t.drawRange.start),
        (this.drawRange.count = t.drawRange.count),
        (this.userData = t.userData),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  const Sr = new hi(),
    br = new ci(),
    Tr = new ei(),
    wr = new Nn(),
    Er = new Nn(),
    Ar = new Nn(),
    Rr = new Nn(),
    Cr = new Nn(),
    Lr = new Nn(),
    Ir = new sn(),
    Pr = new sn(),
    Ur = new sn(),
    Nr = new Nn(),
    Or = new Nn(),
    Dr = new Nn(),
    Fr = new Nn(),
    Br = new Nn();
  class zr extends Oi {
    constructor(t = new Mr(), e = new nr()) {
      super(),
        (this.isMesh = !0),
        (this.type = "Mesh"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        void 0 !== t.morphTargetInfluences &&
          (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
        void 0 !== t.morphTargetDictionary &&
          (this.morphTargetDictionary = Object.assign(
            {},
            t.morphTargetDictionary,
          )),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
    getVertexPosition(t, e) {
      const n = this.geometry,
        i = n.attributes.position,
        r = n.morphAttributes.position,
        s = n.morphTargetsRelative;
      e.fromBufferAttribute(i, t);
      const a = this.morphTargetInfluences;
      if (r && a) {
        Lr.set(0, 0, 0);
        for (let n = 0, i = r.length; n < i; n++) {
          const i = a[n],
            o = r[n];
          0 !== i &&
            (Cr.fromBufferAttribute(o, t),
            s ? Lr.addScaledVector(Cr, i) : Lr.addScaledVector(Cr.sub(e), i));
        }
        e.add(Lr);
      }
      return e;
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.material,
        r = this.matrixWorld;
      if (void 0 !== i) {
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Tr.copy(n.boundingSphere),
          Tr.applyMatrix4(r),
          br.copy(t.ray).recast(t.near),
          !1 === Tr.containsPoint(br.origin))
        ) {
          if (null === br.intersectSphere(Tr, wr)) return;
          if (br.origin.distanceToSquared(wr) > a(t.far - t.near, 2)) return;
        }
        Sr.copy(r).invert(),
          br.copy(t.ray).applyMatrix4(Sr),
          (null !== n.boundingBox && !1 === br.intersectsBox(n.boundingBox)) ||
            this._computeIntersections(t, e, br);
      }
    }
    _computeIntersections(t, e, n) {
      let i;
      const r = this.geometry,
        s = this.material,
        a = r.index,
        o = r.attributes.position,
        l = r.attributes.uv,
        c = r.attributes.uv1,
        h = r.attributes.normal,
        u = r.groups,
        d = r.drawRange;
      if (null !== a)
        if (Array.isArray(s))
          for (let p = 0, f = u.length; p < f; p++) {
            const r = u[p],
              o = s[r.materialIndex];
            for (
              let s = Math.max(r.start, d.start),
                u = Math.min(
                  a.count,
                  Math.min(r.start + r.count, d.start + d.count),
                );
              s < u;
              s += 3
            ) {
              (i = kr(
                this,
                o,
                t,
                n,
                l,
                c,
                h,
                a.getX(s),
                a.getX(s + 1),
                a.getX(s + 2),
              )),
                i &&
                  ((i.faceIndex = Math.floor(s / 3)),
                  (i.face.materialIndex = r.materialIndex),
                  e.push(i));
            }
          }
        else {
          for (
            let r = Math.max(0, d.start),
              o = Math.min(a.count, d.start + d.count);
            r < o;
            r += 3
          ) {
            (i = kr(
              this,
              s,
              t,
              n,
              l,
              c,
              h,
              a.getX(r),
              a.getX(r + 1),
              a.getX(r + 2),
            )),
              i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
          }
        }
      else if (void 0 !== o)
        if (Array.isArray(s))
          for (let p = 0, f = u.length; p < f; p++) {
            const r = u[p],
              a = s[r.materialIndex];
            for (
              let s = Math.max(r.start, d.start),
                u = Math.min(
                  o.count,
                  Math.min(r.start + r.count, d.start + d.count),
                );
              s < u;
              s += 3
            ) {
              (i = kr(this, a, t, n, l, c, h, s, s + 1, s + 2)),
                i &&
                  ((i.faceIndex = Math.floor(s / 3)),
                  (i.face.materialIndex = r.materialIndex),
                  e.push(i));
            }
          }
        else {
          for (
            let r = Math.max(0, d.start),
              a = Math.min(o.count, d.start + d.count);
            r < a;
            r += 3
          ) {
            (i = kr(this, s, t, n, l, c, h, r, r + 1, r + 2)),
              i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
          }
        }
    }
  }
  function kr(t, e, n, i, r, s, a, o, l, c) {
    t.getVertexPosition(o, Er),
      t.getVertexPosition(l, Ar),
      t.getVertexPosition(c, Rr);
    const h = (function (t, e, n, i, r, s, a, o) {
      let l;
      if (
        ((l =
          e.side === ot
            ? i.intersectTriangle(a, s, r, !0, o)
            : i.intersectTriangle(r, s, a, e.side === at, o)),
        null === l)
      )
        return null;
      Br.copy(o), Br.applyMatrix4(t.matrixWorld);
      const c = n.ray.origin.distanceTo(Br);
      return c < n.near || c > n.far
        ? null
        : { distance: c, point: Br.clone(), object: t };
    })(t, e, n, i, Er, Ar, Rr, Fr);
    if (h) {
      r &&
        (Ir.fromBufferAttribute(r, o),
        Pr.fromBufferAttribute(r, l),
        Ur.fromBufferAttribute(r, c),
        (h.uv = qi.getInterpolation(Fr, Er, Ar, Rr, Ir, Pr, Ur, new sn()))),
        s &&
          (Ir.fromBufferAttribute(s, o),
          Pr.fromBufferAttribute(s, l),
          Ur.fromBufferAttribute(s, c),
          (h.uv1 = qi.getInterpolation(Fr, Er, Ar, Rr, Ir, Pr, Ur, new sn())),
          (h.uv2 = h.uv1)),
        a &&
          (Nr.fromBufferAttribute(a, o),
          Or.fromBufferAttribute(a, l),
          Dr.fromBufferAttribute(a, c),
          (h.normal = qi.getInterpolation(
            Fr,
            Er,
            Ar,
            Rr,
            Nr,
            Or,
            Dr,
            new Nn(),
          )),
          h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
      const t = { a: o, b: l, c: c, normal: new Nn(), materialIndex: 0 };
      qi.getNormal(Er, Ar, Rr, t.normal), (h.face = t);
    }
    return h;
  }
  class Hr extends Mr {
    constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
      super(),
        (this.type = "BoxGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          depth: n,
          widthSegments: i,
          heightSegments: r,
          depthSegments: s,
        });
      const a = this;
      (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
      const o = [],
        l = [],
        c = [],
        h = [];
      let u = 0,
        d = 0;
      function p(t, e, n, i, r, s, p, f, m, g, v) {
        const _ = s / m,
          y = p / g,
          x = s / 2,
          M = p / 2,
          S = f / 2,
          b = m + 1,
          T = g + 1;
        let w = 0,
          E = 0;
        const A = new Nn();
        for (let a = 0; a < T; a++) {
          const s = a * y - M;
          for (let o = 0; o < b; o++) {
            const u = o * _ - x;
            (A[t] = u * i),
              (A[e] = s * r),
              (A[n] = S),
              l.push(A.x, A.y, A.z),
              (A[t] = 0),
              (A[e] = 0),
              (A[n] = f > 0 ? 1 : -1),
              c.push(A.x, A.y, A.z),
              h.push(o / m),
              h.push(1 - a / g),
              (w += 1);
          }
        }
        for (let a = 0; a < g; a++)
          for (let t = 0; t < m; t++) {
            const e = u + t + b * a,
              n = u + t + b * (a + 1),
              i = u + (t + 1) + b * (a + 1),
              r = u + (t + 1) + b * a;
            o.push(e, n, r), o.push(n, i, r), (E += 6);
          }
        a.addGroup(d, E, v), (d += E), (u += w);
      }
      p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
        p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
        p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
        p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
        p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
        p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
        this.setIndex(o),
        this.setAttribute("position", new pr(l, 3)),
        this.setAttribute("normal", new pr(c, 3)),
        this.setAttribute("uv", new pr(h, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new Hr(
        t.width,
        t.height,
        t.depth,
        t.widthSegments,
        t.heightSegments,
        t.depthSegments,
      );
    }
  }
  function Gr(t) {
    const e = {};
    for (const n in t) {
      e[n] = {};
      for (const i in t[n]) {
        const r = t[n][i];
        r &&
        (r.isColor ||
          r.isMatrix3 ||
          r.isMatrix4 ||
          r.isVector2 ||
          r.isVector3 ||
          r.isVector4 ||
          r.isTexture ||
          r.isQuaternion)
          ? r.isRenderTargetTexture
            ? (console.warn(
                "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().",
              ),
              (e[n][i] = null))
            : (e[n][i] = r.clone())
          : Array.isArray(r)
          ? (e[n][i] = r.slice())
          : (e[n][i] = r);
      }
    }
    return e;
  }
  function Vr(t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const i = Gr(t[n]);
      for (const t in i) e[t] = i[t];
    }
    return e;
  }
  function Wr(t) {
    return null === t.getRenderTarget() ? t.outputColorSpace : Oe;
  }
  const jr = { clone: Gr, merge: Vr };
  class Xr extends Ki {
    constructor(t) {
      super(),
        (this.isShaderMaterial = !0),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.uniformsGroups = []),
        (this.vertexShader =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
        (this.fragmentShader =
          "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.forceSinglePass = !0),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv1: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        (this.glslVersion = null),
        void 0 !== t && this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.fragmentShader = t.fragmentShader),
        (this.vertexShader = t.vertexShader),
        (this.uniforms = Gr(t.uniforms)),
        (this.uniformsGroups = (function (t) {
          const e = [];
          for (let n = 0; n < t.length; n++) e.push(t[n].clone());
          return e;
        })(t.uniformsGroups)),
        (this.defines = Object.assign({}, t.defines)),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.fog = t.fog),
        (this.lights = t.lights),
        (this.clipping = t.clipping),
        (this.extensions = Object.assign({}, t.extensions)),
        (this.glslVersion = t.glslVersion),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      (e.glslVersion = this.glslVersion), (e.uniforms = {});
      for (const i in this.uniforms) {
        const n = this.uniforms[i].value;
        n && n.isTexture
          ? (e.uniforms[i] = { type: "t", value: n.toJSON(t).uuid })
          : n && n.isColor
          ? (e.uniforms[i] = { type: "c", value: n.getHex() })
          : n && n.isVector2
          ? (e.uniforms[i] = { type: "v2", value: n.toArray() })
          : n && n.isVector3
          ? (e.uniforms[i] = { type: "v3", value: n.toArray() })
          : n && n.isVector4
          ? (e.uniforms[i] = { type: "v4", value: n.toArray() })
          : n && n.isMatrix3
          ? (e.uniforms[i] = { type: "m3", value: n.toArray() })
          : n && n.isMatrix4
          ? (e.uniforms[i] = { type: "m4", value: n.toArray() })
          : (e.uniforms[i] = { value: n });
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines),
        (e.vertexShader = this.vertexShader),
        (e.fragmentShader = this.fragmentShader),
        (e.lights = this.lights),
        (e.clipping = this.clipping);
      const n = {};
      for (const i in this.extensions) !0 === this.extensions[i] && (n[i] = !0);
      return Object.keys(n).length > 0 && (e.extensions = n), e;
    }
  }
  class qr extends Oi {
    constructor() {
      super(),
        (this.isCamera = !0),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new hi()),
        (this.projectionMatrix = new hi()),
        (this.projectionMatrixInverse = new hi()),
        (this.coordinateSystem = He);
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        this.matrixWorldInverse.copy(t.matrixWorldInverse),
        this.projectionMatrix.copy(t.projectionMatrix),
        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
        (this.coordinateSystem = t.coordinateSystem),
        this
      );
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Yr extends qr {
    constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
      super(),
        (this.isPerspectiveCamera = !0),
        (this.type = "PerspectiveCamera"),
        (this.fov = t),
        (this.zoom = 1),
        (this.near = n),
        (this.far = i),
        (this.focus = 10),
        (this.aspect = e),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.fov = t.fov),
        (this.zoom = t.zoom),
        (this.near = t.near),
        (this.far = t.far),
        (this.focus = t.focus),
        (this.aspect = t.aspect),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        (this.filmGauge = t.filmGauge),
        (this.filmOffset = t.filmOffset),
        this
      );
    }
    setFocalLength(t) {
      const e = (0.5 * this.getFilmHeight()) / t;
      (this.fov = 2 * qe * Math.atan(e)), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const t = Math.tan(0.5 * Xe * this.fov);
      return (0.5 * this.getFilmHeight()) / t;
    }
    getEffectiveFOV() {
      return 2 * qe * Math.atan(Math.tan(0.5 * Xe * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(t, e, n, i, r, s) {
      (this.aspect = t / e),
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = this.near;
      let e = (t * Math.tan(0.5 * Xe * this.fov)) / this.zoom,
        n = 2 * e,
        i = this.aspect * n,
        r = -0.5 * i;
      const s = this.view;
      if (null !== this.view && this.view.enabled) {
        const t = s.fullWidth,
          a = s.fullHeight;
        (r += (s.offsetX * i) / t),
          (e -= (s.offsetY * n) / a),
          (i *= s.width / t),
          (n *= s.height / a);
      }
      const a = this.filmOffset;
      0 !== a && (r += (t * a) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(
          r,
          r + i,
          e,
          e - n,
          t,
          this.far,
          this.coordinateSystem,
        ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.fov = this.fov),
        (e.object.zoom = this.zoom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        (e.object.focus = this.focus),
        (e.object.aspect = this.aspect),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        (e.object.filmGauge = this.filmGauge),
        (e.object.filmOffset = this.filmOffset),
        e
      );
    }
  }
  const Kr = -90;
  class Zr extends Oi {
    constructor(t, e, n) {
      super(),
        (this.type = "CubeCamera"),
        (this.renderTarget = n),
        (this.coordinateSystem = null);
      const i = new Yr(Kr, 1, t, e);
      (i.layers = this.layers), this.add(i);
      const r = new Yr(Kr, 1, t, e);
      (r.layers = this.layers), this.add(r);
      const s = new Yr(Kr, 1, t, e);
      (s.layers = this.layers), this.add(s);
      const a = new Yr(Kr, 1, t, e);
      (a.layers = this.layers), this.add(a);
      const o = new Yr(Kr, 1, t, e);
      (o.layers = this.layers), this.add(o);
      const l = new Yr(Kr, 1, t, e);
      (l.layers = this.layers), this.add(l);
    }
    updateCoordinateSystem() {
      const t = this.coordinateSystem,
        e = this.children.concat(),
        [n, i, r, s, a, o] = e;
      for (const l of e) this.remove(l);
      if (t === He)
        n.up.set(0, 1, 0),
          n.lookAt(1, 0, 0),
          i.up.set(0, 1, 0),
          i.lookAt(-1, 0, 0),
          r.up.set(0, 0, -1),
          r.lookAt(0, 1, 0),
          s.up.set(0, 0, 1),
          s.lookAt(0, -1, 0),
          a.up.set(0, 1, 0),
          a.lookAt(0, 0, 1),
          o.up.set(0, 1, 0),
          o.lookAt(0, 0, -1);
      else {
        if (t !== Ge)
          throw new Error(
            "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
              t,
          );
        n.up.set(0, -1, 0),
          n.lookAt(-1, 0, 0),
          i.up.set(0, -1, 0),
          i.lookAt(1, 0, 0),
          r.up.set(0, 0, 1),
          r.lookAt(0, 1, 0),
          s.up.set(0, 0, -1),
          s.lookAt(0, -1, 0),
          a.up.set(0, -1, 0),
          a.lookAt(0, 0, 1),
          o.up.set(0, -1, 0),
          o.lookAt(0, 0, -1);
      }
      for (const l of e) this.add(l), l.updateMatrixWorld();
    }
    update(t, e) {
      null === this.parent && this.updateMatrixWorld();
      const n = this.renderTarget;
      this.coordinateSystem !== t.coordinateSystem &&
        ((this.coordinateSystem = t.coordinateSystem),
        this.updateCoordinateSystem());
      const [i, r, s, a, o, l] = this.children,
        c = t.getRenderTarget(),
        h = t.xr.enabled;
      t.xr.enabled = !1;
      const u = n.texture.generateMipmaps;
      (n.texture.generateMipmaps = !1),
        t.setRenderTarget(n, 0),
        t.render(e, i),
        t.setRenderTarget(n, 1),
        t.render(e, r),
        t.setRenderTarget(n, 2),
        t.render(e, s),
        t.setRenderTarget(n, 3),
        t.render(e, a),
        t.setRenderTarget(n, 4),
        t.render(e, o),
        (n.texture.generateMipmaps = u),
        t.setRenderTarget(n, 5),
        t.render(e, l),
        t.setRenderTarget(c),
        (t.xr.enabled = h),
        (n.texture.needsPMREMUpdate = !0);
    }
  }
  class Jr extends An {
    constructor(t, e, n, i, r, s, a, o, l, c) {
      super(
        (t = void 0 !== t ? t : []),
        (e = void 0 !== e ? e : yt),
        n,
        i,
        r,
        s,
        a,
        o,
        l,
        c,
      ),
        (this.isCubeTexture = !0),
        (this.flipY = !1);
    }
    get images() {
      return this.image;
    }
    set images(t) {
      this.image = t;
    }
  }
  class $r extends Ln {
    constructor(t = 1, e = {}) {
      super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
      const n = { width: t, height: t, depth: 1 },
        i = [n, n, n, n, n, n];
      void 0 !== e.encoding &&
        (pn(
          "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.",
        ),
        (e.colorSpace = e.encoding === Pe ? Ne : Ue)),
        (this.texture = new Jr(
          i,
          e.mapping,
          e.wrapS,
          e.wrapT,
          e.magFilter,
          e.minFilter,
          e.format,
          e.type,
          e.anisotropy,
          e.colorSpace,
        )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.generateMipmaps =
          void 0 !== e.generateMipmaps && e.generateMipmaps),
        (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Lt);
    }
    fromEquirectangularTexture(t, e) {
      (this.texture.type = e.type),
        (this.texture.colorSpace = e.colorSpace),
        (this.texture.generateMipmaps = e.generateMipmaps),
        (this.texture.minFilter = e.minFilter),
        (this.texture.magFilter = e.magFilter);
      const n = {
          uniforms: { tEquirect: { value: null } },
          vertexShader:
            "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
          fragmentShader:
            "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
        },
        i = new Hr(5, 5, 5),
        r = new Xr({
          name: "CubemapFromEquirect",
          uniforms: Gr(n.uniforms),
          vertexShader: n.vertexShader,
          fragmentShader: n.fragmentShader,
          side: ot,
          blending: 0,
        });
      r.uniforms.tEquirect.value = e;
      const s = new zr(i, r),
        a = e.minFilter;
      e.minFilter === Pt && (e.minFilter = Lt);
      return (
        new Zr(1, 10, this).update(t, s),
        (e.minFilter = a),
        s.geometry.dispose(),
        s.material.dispose(),
        this
      );
    }
    clear(t, e, n, i) {
      const r = t.getRenderTarget();
      for (let s = 0; s < 6; s++) t.setRenderTarget(this, s), t.clear(e, n, i);
      t.setRenderTarget(r);
    }
  }
  const Qr = new Nn(),
    ts = new Nn(),
    es = new an();
  class ns {
    constructor(t = new Nn(1, 0, 0), e = 0) {
      (this.isPlane = !0), (this.normal = t), (this.constant = e);
    }
    set(t, e) {
      return this.normal.copy(t), (this.constant = e), this;
    }
    setComponents(t, e, n, i) {
      return this.normal.set(t, e, n), (this.constant = i), this;
    }
    setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
    }
    setFromCoplanarPoints(t, e, n) {
      const i = Qr.subVectors(n, e).cross(ts.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, t), this;
    }
    copy(t) {
      return this.normal.copy(t.normal), (this.constant = t.constant), this;
    }
    normalize() {
      const t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), (this.constant *= t), this;
    }
    negate() {
      return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant;
    }
    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius;
    }
    projectPoint(t, e) {
      return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
    }
    intersectLine(t, e) {
      const n = t.delta(Qr),
        i = this.normal.dot(n);
      if (0 === i)
        return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
      const r = -(t.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
    }
    intersectsLine(t) {
      const e = this.distanceToPoint(t.start),
        n = this.distanceToPoint(t.end);
      return (e < 0 && n > 0) || (n < 0 && e > 0);
    }
    intersectsBox(t) {
      return t.intersectsPlane(this);
    }
    intersectsSphere(t) {
      return t.intersectsPlane(this);
    }
    coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t, e) {
      const n = e || es.getNormalMatrix(t),
        i = this.coplanarPoint(Qr).applyMatrix4(t),
        r = this.normal.applyMatrix3(n).normalize();
      return (this.constant = -i.dot(r)), this;
    }
    translate(t) {
      return (this.constant -= t.dot(this.normal)), this;
    }
    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const is = new ei(),
    rs = new Nn();
  class ss {
    constructor(
      t = new ns(),
      e = new ns(),
      n = new ns(),
      i = new ns(),
      r = new ns(),
      s = new ns(),
    ) {
      this.planes = [t, e, n, i, r, s];
    }
    set(t, e, n, i, r, s) {
      const a = this.planes;
      return (
        a[0].copy(t),
        a[1].copy(e),
        a[2].copy(n),
        a[3].copy(i),
        a[4].copy(r),
        a[5].copy(s),
        this
      );
    }
    copy(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
      return this;
    }
    setFromProjectionMatrix(t, e = 2e3) {
      const n = this.planes,
        i = t.elements,
        r = i[0],
        s = i[1],
        a = i[2],
        o = i[3],
        l = i[4],
        c = i[5],
        h = i[6],
        u = i[7],
        d = i[8],
        p = i[9],
        f = i[10],
        m = i[11],
        g = i[12],
        v = i[13],
        _ = i[14],
        y = i[15];
      if (
        (n[0].setComponents(o - r, u - l, m - d, y - g).normalize(),
        n[1].setComponents(o + r, u + l, m + d, y + g).normalize(),
        n[2].setComponents(o + s, u + c, m + p, y + v).normalize(),
        n[3].setComponents(o - s, u - c, m - p, y - v).normalize(),
        n[4].setComponents(o - a, u - h, m - f, y - _).normalize(),
        e === He)
      )
        n[5].setComponents(o + a, u + h, m + f, y + _).normalize();
      else {
        if (e !== Ge)
          throw new Error(
            "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
              e,
          );
        n[5].setComponents(a, h, f, _).normalize();
      }
      return this;
    }
    intersectsObject(t) {
      if (void 0 !== t.boundingSphere)
        null === t.boundingSphere && t.computeBoundingSphere(),
          is.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
      else {
        const e = t.geometry;
        null === e.boundingSphere && e.computeBoundingSphere(),
          is.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
      }
      return this.intersectsSphere(is);
    }
    intersectsSprite(t) {
      return (
        is.center.set(0, 0, 0),
        (is.radius = 0.7071067811865476),
        is.applyMatrix4(t.matrixWorld),
        this.intersectsSphere(is)
      );
    }
    intersectsSphere(t) {
      const e = this.planes,
        n = t.center,
        i = -t.radius;
      for (let r = 0; r < 6; r++) {
        if (e[r].distanceToPoint(n) < i) return !1;
      }
      return !0;
    }
    intersectsBox(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) {
        const i = e[n];
        if (
          ((rs.x = i.normal.x > 0 ? t.max.x : t.min.x),
          (rs.y = i.normal.y > 0 ? t.max.y : t.min.y),
          (rs.z = i.normal.z > 0 ? t.max.z : t.min.z),
          i.distanceToPoint(rs) < 0)
        )
          return !1;
      }
      return !0;
    }
    containsPoint(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
      return !0;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function as() {
    let t = null,
      e = !1,
      n = null,
      i = null;
    function r(e, s) {
      n(e, s), (i = t.requestAnimationFrame(r));
    }
    return {
      start: function () {
        !0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0));
      },
      stop: function () {
        t.cancelAnimationFrame(i), (e = !1);
      },
      setAnimationLoop: function (t) {
        n = t;
      },
      setContext: function (e) {
        t = e;
      },
    };
  }
  function os(t, e) {
    const n = e.isWebGL2,
      i = new WeakMap();
    return {
      get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
      },
      remove: function (e) {
        e.isInterleavedBufferAttribute && (e = e.data);
        const n = i.get(e);
        n && (t.deleteBuffer(n.buffer), i.delete(e));
      },
      update: function (e, r) {
        if (e.isGLBufferAttribute) {
          const t = i.get(e);
          return void (
            (!t || t.version < e.version) &&
            i.set(e, {
              buffer: e.buffer,
              type: e.type,
              bytesPerElement: e.elementSize,
              version: e.version,
            })
          );
        }
        e.isInterleavedBufferAttribute && (e = e.data);
        const s = i.get(e);
        void 0 === s
          ? i.set(
              e,
              (function (e, i) {
                const r = e.array,
                  s = e.usage,
                  a = t.createBuffer();
                let o;
                if (
                  (t.bindBuffer(i, a),
                  t.bufferData(i, r, s),
                  e.onUploadCallback(),
                  r instanceof Float32Array)
                )
                  o = t.FLOAT;
                else if (r instanceof Uint16Array)
                  if (e.isFloat16BufferAttribute) {
                    if (!n)
                      throw new Error(
                        "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.",
                      );
                    o = t.HALF_FLOAT;
                  } else o = t.UNSIGNED_SHORT;
                else if (r instanceof Int16Array) o = t.SHORT;
                else if (r instanceof Uint32Array) o = t.UNSIGNED_INT;
                else if (r instanceof Int32Array) o = t.INT;
                else if (r instanceof Int8Array) o = t.BYTE;
                else if (r instanceof Uint8Array) o = t.UNSIGNED_BYTE;
                else {
                  if (!(r instanceof Uint8ClampedArray))
                    throw new Error(
                      "THREE.WebGLAttributes: Unsupported buffer data format: " +
                        r,
                    );
                  o = t.UNSIGNED_BYTE;
                }
                return {
                  buffer: a,
                  type: o,
                  bytesPerElement: r.BYTES_PER_ELEMENT,
                  version: e.version,
                };
              })(e, r),
            )
          : s.version < e.version &&
            (!(function (e, i, r) {
              const s = i.array,
                a = i.updateRange;
              t.bindBuffer(r, e),
                -1 === a.count
                  ? t.bufferSubData(r, 0, s)
                  : (n
                      ? t.bufferSubData(
                          r,
                          a.offset * s.BYTES_PER_ELEMENT,
                          s,
                          a.offset,
                          a.count,
                        )
                      : t.bufferSubData(
                          r,
                          a.offset * s.BYTES_PER_ELEMENT,
                          s.subarray(a.offset, a.offset + a.count),
                        ),
                    (a.count = -1)),
                i.onUploadCallback();
            })(s.buffer, e, r),
            (s.version = e.version));
      },
    };
  }
  class ls extends Mr {
    constructor(t = 1, e = 1, n = 1, i = 1) {
      super(),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i,
        });
      const r = t / 2,
        s = e / 2,
        a = Math.floor(n),
        o = Math.floor(i),
        l = a + 1,
        c = o + 1,
        h = t / a,
        u = e / o,
        d = [],
        p = [],
        f = [],
        m = [];
      for (let g = 0; g < c; g++) {
        const t = g * u - s;
        for (let e = 0; e < l; e++) {
          const n = e * h - r;
          p.push(n, -t, 0), f.push(0, 0, 1), m.push(e / a), m.push(1 - g / o);
        }
      }
      for (let g = 0; g < o; g++)
        for (let t = 0; t < a; t++) {
          const e = t + l * g,
            n = t + l * (g + 1),
            i = t + 1 + l * (g + 1),
            r = t + 1 + l * g;
          d.push(e, n, r), d.push(n, i, r);
        }
      this.setIndex(d),
        this.setAttribute("position", new pr(p, 3)),
        this.setAttribute("normal", new pr(f, 3)),
        this.setAttribute("uv", new pr(m, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new ls(t.width, t.height, t.widthSegments, t.heightSegments);
    }
  }
  const cs = {
      alphahash_fragment:
        "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
      alphahash_pars_fragment:
        "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
      alphamap_fragment:
        "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
      alphamap_pars_fragment:
        "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      alphatest_fragment:
        "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
      alphatest_pars_fragment:
        "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
      aomap_fragment:
        "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
      aomap_pars_fragment:
        "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      begin_vertex:
        "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
      beginnormal_vertex:
        "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      bsdfs:
        "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
      iridescence_fragment:
        "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
      bumpmap_pars_fragment:
        "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      clipping_planes_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
      clipping_planes_pars_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      clipping_planes_pars_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
      clipping_planes_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
      color_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
      color_pars_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_pars_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
      common:
        "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
      cube_uv_reflection_fragment:
        "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
      defaultnormal_vertex:
        "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      displacementmap_pars_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      displacementmap_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
      emissivemap_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      emissivemap_pars_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      colorspace_fragment:
        "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      colorspace_pars_fragment:
        "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
      envmap_fragment:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      envmap_common_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
      envmap_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      envmap_pars_vertex:
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      envmap_physical_pars_fragment:
        "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
      envmap_vertex:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
      fog_fragment:
        "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      fog_pars_fragment:
        "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      gradientmap_pars_fragment:
        "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
      lightmap_fragment:
        "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
      lightmap_pars_fragment:
        "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      lights_lambert_fragment:
        "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
      lights_lambert_pars_fragment:
        "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
      lights_pars_begin:
        "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
      lights_toon_fragment:
        "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
      lights_toon_pars_fragment:
        "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
      lights_phong_fragment:
        "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      lights_phong_pars_fragment:
        "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
      lights_physical_fragment:
        "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
      lights_physical_pars_fragment:
        "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      lights_fragment_begin:
        "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      lights_fragment_maps:
        "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
      lights_fragment_end:
        "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
      logdepthbuf_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
      logdepthbuf_pars_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_pars_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
      logdepthbuf_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
      map_fragment:
        "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif",
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      map_particle_fragment:
        "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
      map_particle_pars_fragment:
        "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      metalnessmap_fragment:
        "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      metalnessmap_pars_fragment:
        "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      morphcolor_vertex:
        "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
      morphnormal_vertex:
        "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
      morphtarget_pars_vertex:
        "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
      morphtarget_vertex:
        "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
      normal_fragment_begin:
        "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
      normal_fragment_maps:
        "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
      normal_pars_fragment:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_pars_vertex:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_vertex:
        "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
      normalmap_pars_fragment:
        "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
      clearcoat_normal_fragment_begin:
        "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
      clearcoat_normal_fragment_maps:
        "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
      clearcoat_pars_fragment:
        "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
      iridescence_pars_fragment:
        "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
      opaque_fragment:
        "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
      packing:
        "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
      premultiplied_alpha_fragment:
        "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      project_vertex:
        "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      dithering_fragment:
        "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      dithering_pars_fragment:
        "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      roughnessmap_fragment:
        "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      roughnessmap_pars_fragment:
        "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      shadowmap_pars_fragment:
        "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
      shadowmap_pars_vertex:
        "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      shadowmap_vertex:
        "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
      shadowmask_pars_fragment:
        "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      skinbase_vertex:
        "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      skinning_pars_vertex:
        "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
      skinning_vertex:
        "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      skinnormal_vertex:
        "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      specularmap_fragment:
        "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      specularmap_pars_fragment:
        "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      tonemapping_fragment:
        "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      tonemapping_pars_fragment:
        "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
      transmission_fragment:
        "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
      transmission_pars_fragment:
        "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
      uv_pars_fragment:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_pars_vertex:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_vertex:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
      worldpos_vertex:
        "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      background_vert:
        "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      background_frag:
        "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      backgroundCube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      backgroundCube_frag:
        "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      cube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      cube_frag:
        "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      depth_vert:
        "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
      depth_frag:
        "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
      distanceRGBA_vert:
        "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      distanceRGBA_frag:
        "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      equirect_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      equirect_frag:
        "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      linedashed_vert:
        "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      linedashed_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      meshbasic_vert:
        "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      meshbasic_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshlambert_vert:
        "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshlambert_frag:
        "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshmatcap_vert:
        "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      meshmatcap_frag:
        "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshnormal_vert:
        "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      meshnormal_frag:
        "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
      meshphong_vert:
        "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphong_frag:
        "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphysical_vert:
        "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
      meshphysical_frag:
        "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshtoon_vert:
        "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshtoon_frag:
        "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      points_vert:
        "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      points_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      shadow_vert:
        "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      shadow_frag:
        "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
      sprite_vert:
        "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      sprite_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
    },
    hs = {
      common: {
        diffuse: { value: new tr(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        mapTransform: { value: new an() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new an() },
        alphaTest: { value: 0 },
      },
      specularmap: {
        specularMap: { value: null },
        specularMapTransform: { value: new an() },
      },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 },
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 },
        aoMapTransform: { value: new an() },
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 },
        lightMapTransform: { value: new an() },
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpMapTransform: { value: new an() },
        bumpScale: { value: 1 },
      },
      normalmap: {
        normalMap: { value: null },
        normalMapTransform: { value: new an() },
        normalScale: { value: new sn(1, 1) },
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementMapTransform: { value: new an() },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      emissivemap: {
        emissiveMap: { value: null },
        emissiveMapTransform: { value: new an() },
      },
      metalnessmap: {
        metalnessMap: { value: null },
        metalnessMapTransform: { value: new an() },
      },
      roughnessmap: {
        roughnessMap: { value: null },
        roughnessMapTransform: { value: new an() },
      },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new tr(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {} },
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
          },
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotLightMap: { value: [] },
        spotShadowMap: { value: [] },
        spotLightMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: { color: {}, position: {}, decay: {}, distance: {} },
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
        ltc_1: { value: null },
        ltc_2: { value: null },
      },
      points: {
        diffuse: { value: new tr(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaMapTransform: { value: new an() },
        alphaTest: { value: 0 },
        uvTransform: { value: new an() },
      },
      sprite: {
        diffuse: { value: new tr(16777215) },
        opacity: { value: 1 },
        center: { value: new sn(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        mapTransform: { value: new an() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new an() },
        alphaTest: { value: 0 },
      },
    },
    us = {
      basic: {
        uniforms: Vr([
          hs.common,
          hs.specularmap,
          hs.envmap,
          hs.aomap,
          hs.lightmap,
          hs.fog,
        ]),
        vertexShader: cs.meshbasic_vert,
        fragmentShader: cs.meshbasic_frag,
      },
      lambert: {
        uniforms: Vr([
          hs.common,
          hs.specularmap,
          hs.envmap,
          hs.aomap,
          hs.lightmap,
          hs.emissivemap,
          hs.bumpmap,
          hs.normalmap,
          hs.displacementmap,
          hs.fog,
          hs.lights,
          { emissive: { value: new tr(0) } },
        ]),
        vertexShader: cs.meshlambert_vert,
        fragmentShader: cs.meshlambert_frag,
      },
      phong: {
        uniforms: Vr([
          hs.common,
          hs.specularmap,
          hs.envmap,
          hs.aomap,
          hs.lightmap,
          hs.emissivemap,
          hs.bumpmap,
          hs.normalmap,
          hs.displacementmap,
          hs.fog,
          hs.lights,
          {
            emissive: { value: new tr(0) },
            specular: { value: new tr(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: cs.meshphong_vert,
        fragmentShader: cs.meshphong_frag,
      },
      standard: {
        uniforms: Vr([
          hs.common,
          hs.envmap,
          hs.aomap,
          hs.lightmap,
          hs.emissivemap,
          hs.bumpmap,
          hs.normalmap,
          hs.displacementmap,
          hs.roughnessmap,
          hs.metalnessmap,
          hs.fog,
          hs.lights,
          {
            emissive: { value: new tr(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: cs.meshphysical_vert,
        fragmentShader: cs.meshphysical_frag,
      },
      toon: {
        uniforms: Vr([
          hs.common,
          hs.aomap,
          hs.lightmap,
          hs.emissivemap,
          hs.bumpmap,
          hs.normalmap,
          hs.displacementmap,
          hs.gradientmap,
          hs.fog,
          hs.lights,
          { emissive: { value: new tr(0) } },
        ]),
        vertexShader: cs.meshtoon_vert,
        fragmentShader: cs.meshtoon_frag,
      },
      matcap: {
        uniforms: Vr([
          hs.common,
          hs.bumpmap,
          hs.normalmap,
          hs.displacementmap,
          hs.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: cs.meshmatcap_vert,
        fragmentShader: cs.meshmatcap_frag,
      },
      points: {
        uniforms: Vr([hs.points, hs.fog]),
        vertexShader: cs.points_vert,
        fragmentShader: cs.points_frag,
      },
      dashed: {
        uniforms: Vr([
          hs.common,
          hs.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: cs.linedashed_vert,
        fragmentShader: cs.linedashed_frag,
      },
      depth: {
        uniforms: Vr([hs.common, hs.displacementmap]),
        vertexShader: cs.depth_vert,
        fragmentShader: cs.depth_frag,
      },
      normal: {
        uniforms: Vr([
          hs.common,
          hs.bumpmap,
          hs.normalmap,
          hs.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: cs.meshnormal_vert,
        fragmentShader: cs.meshnormal_frag,
      },
      sprite: {
        uniforms: Vr([hs.sprite, hs.fog]),
        vertexShader: cs.sprite_vert,
        fragmentShader: cs.sprite_frag,
      },
      background: {
        uniforms: {
          uvTransform: { value: new an() },
          t2D: { value: null },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: cs.background_vert,
        fragmentShader: cs.background_frag,
      },
      backgroundCube: {
        uniforms: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          backgroundBlurriness: { value: 0 },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: cs.backgroundCube_vert,
        fragmentShader: cs.backgroundCube_frag,
      },
      cube: {
        uniforms: {
          tCube: { value: null },
          tFlip: { value: -1 },
          opacity: { value: 1 },
        },
        vertexShader: cs.cube_vert,
        fragmentShader: cs.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: cs.equirect_vert,
        fragmentShader: cs.equirect_frag,
      },
      distanceRGBA: {
        uniforms: Vr([
          hs.common,
          hs.displacementmap,
          {
            referencePosition: { value: new Nn() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: cs.distanceRGBA_vert,
        fragmentShader: cs.distanceRGBA_frag,
      },
      shadow: {
        uniforms: Vr([
          hs.lights,
          hs.fog,
          { color: { value: new tr(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: cs.shadow_vert,
        fragmentShader: cs.shadow_frag,
      },
    };
  us.physical = {
    uniforms: Vr([
      us.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatMapTransform: { value: new an() },
        clearcoatNormalMap: { value: null },
        clearcoatNormalMapTransform: { value: new an() },
        clearcoatNormalScale: { value: new sn(1, 1) },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatRoughnessMapTransform: { value: new an() },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceMapTransform: { value: new an() },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        iridescenceThicknessMapTransform: { value: new an() },
        sheen: { value: 0 },
        sheenColor: { value: new tr(0) },
        sheenColorMap: { value: null },
        sheenColorMapTransform: { value: new an() },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        sheenRoughnessMapTransform: { value: new an() },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionMapTransform: { value: new an() },
        transmissionSamplerSize: { value: new sn() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        thicknessMapTransform: { value: new an() },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: new tr(0) },
        specularColor: { value: new tr(1, 1, 1) },
        specularColorMap: { value: null },
        specularColorMapTransform: { value: new an() },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularIntensityMapTransform: { value: new an() },
        anisotropyVector: { value: new sn() },
        anisotropyMap: { value: null },
        anisotropyMapTransform: { value: new an() },
      },
    ]),
    vertexShader: cs.meshphysical_vert,
    fragmentShader: cs.meshphysical_frag,
  };
  const ds = { r: 0, b: 0, g: 0 };
  function ps(t, e, n, i, r, s, a) {
    const o = new tr(0);
    let l,
      c,
      h = !0 === s ? 0 : 1,
      u = null,
      d = 0,
      p = null;
    function f(e, n) {
      e.getRGB(ds, Wr(t)), i.buffers.color.setClear(ds.r, ds.g, ds.b, n, a);
    }
    return {
      getClearColor: function () {
        return o;
      },
      setClearColor: function (t, e = 1) {
        o.set(t), (h = e), f(o, h);
      },
      getClearAlpha: function () {
        return h;
      },
      setClearAlpha: function (t) {
        (h = t), f(o, h);
      },
      render: function (s, m) {
        let g = !1,
          v = !0 === m.isScene ? m.background : null;
        if (v && v.isTexture) {
          v = (m.backgroundBlurriness > 0 ? n : e).get(v);
        }
        switch (
          (null === v ? f(o, h) : v && v.isColor && (f(v, 1), (g = !0)),
          t.xr.getEnvironmentBlendMode())
        ) {
          case "opaque":
            g = !0;
            break;
          case "additive":
            i.buffers.color.setClear(0, 0, 0, 1, a), (g = !0);
            break;
          case "alpha-blend":
            i.buffers.color.setClear(0, 0, 0, 0, a), (g = !0);
        }
        (t.autoClear || g) &&
          t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
          v && (v.isCubeTexture || v.mapping === bt)
            ? (void 0 === c &&
                ((c = new zr(
                  new Hr(1, 1, 1),
                  new Xr({
                    name: "BackgroundCubeMaterial",
                    uniforms: Gr(us.backgroundCube.uniforms),
                    vertexShader: us.backgroundCube.vertexShader,
                    fragmentShader: us.backgroundCube.fragmentShader,
                    side: ot,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  }),
                )),
                c.geometry.deleteAttribute("normal"),
                c.geometry.deleteAttribute("uv"),
                (c.onBeforeRender = function (t, e, n) {
                  this.matrixWorld.copyPosition(n.matrixWorld);
                }),
                Object.defineProperty(c.material, "envMap", {
                  get: function () {
                    return this.uniforms.envMap.value;
                  },
                }),
                r.update(c)),
              (c.material.uniforms.envMap.value = v),
              (c.material.uniforms.flipEnvMap.value =
                v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1),
              (c.material.uniforms.backgroundBlurriness.value =
                m.backgroundBlurriness),
              (c.material.uniforms.backgroundIntensity.value =
                m.backgroundIntensity),
              (c.material.toneMapped = v.colorSpace !== Ne),
              (u === v && d === v.version && p === t.toneMapping) ||
                ((c.material.needsUpdate = !0),
                (u = v),
                (d = v.version),
                (p = t.toneMapping)),
              c.layers.enableAll(),
              s.unshift(c, c.geometry, c.material, 0, 0, null))
            : v &&
              v.isTexture &&
              (void 0 === l &&
                ((l = new zr(
                  new ls(2, 2),
                  new Xr({
                    name: "BackgroundMaterial",
                    uniforms: Gr(us.background.uniforms),
                    vertexShader: us.background.vertexShader,
                    fragmentShader: us.background.fragmentShader,
                    side: at,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  }),
                )),
                l.geometry.deleteAttribute("normal"),
                Object.defineProperty(l.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                r.update(l)),
              (l.material.uniforms.t2D.value = v),
              (l.material.uniforms.backgroundIntensity.value =
                m.backgroundIntensity),
              (l.material.toneMapped = v.colorSpace !== Ne),
              !0 === v.matrixAutoUpdate && v.updateMatrix(),
              l.material.uniforms.uvTransform.value.copy(v.matrix),
              (u === v && d === v.version && p === t.toneMapping) ||
                ((l.material.needsUpdate = !0),
                (u = v),
                (d = v.version),
                (p = t.toneMapping)),
              l.layers.enableAll(),
              s.unshift(l, l.geometry, l.material, 0, 0, null));
      },
    };
  }
  function fs(t, e, n, i) {
    const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
      s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
      a = i.isWebGL2 || null !== s,
      o = {},
      l = p(null);
    let c = l,
      h = !1;
    function u(e) {
      return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
    }
    function d(e) {
      return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
    }
    function p(t) {
      const e = [],
        n = [],
        i = [];
      for (let s = 0; s < r; s++) (e[s] = 0), (n[s] = 0), (i[s] = 0);
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: e,
        enabledAttributes: n,
        attributeDivisors: i,
        object: t,
        attributes: {},
        index: null,
      };
    }
    function f() {
      const t = c.newAttributes;
      for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
    }
    function m(t) {
      g(t, 0);
    }
    function g(n, r) {
      const s = c.newAttributes,
        a = c.enabledAttributes,
        o = c.attributeDivisors;
      if (
        ((s[n] = 1),
        0 === a[n] && (t.enableVertexAttribArray(n), (a[n] = 1)),
        o[n] !== r)
      ) {
        (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](n, r),
          (o[n] = r);
      }
    }
    function v() {
      const e = c.newAttributes,
        n = c.enabledAttributes;
      for (let i = 0, r = n.length; i < r; i++)
        n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
    }
    function _(e, n, i, r, s, a, o) {
      !0 === o
        ? t.vertexAttribIPointer(e, n, i, s, a)
        : t.vertexAttribPointer(e, n, i, r, s, a);
    }
    function y() {
      x(), (h = !0), c !== l && ((c = l), u(c.object));
    }
    function x() {
      (l.geometry = null), (l.program = null), (l.wireframe = !1);
    }
    return {
      setup: function (r, l, d, y, x) {
        let M = !1;
        if (a) {
          const e = (function (e, n, r) {
            const a = !0 === r.wireframe;
            let l = o[e.id];
            void 0 === l && ((l = {}), (o[e.id] = l));
            let c = l[n.id];
            void 0 === c && ((c = {}), (l[n.id] = c));
            let h = c[a];
            void 0 === h &&
              ((h = p(
                i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES(),
              )),
              (c[a] = h));
            return h;
          })(y, d, l);
          c !== e && ((c = e), u(c.object)),
            (M = (function (t, e, n, i) {
              const r = c.attributes,
                s = e.attributes;
              let a = 0;
              const o = n.getAttributes();
              for (const l in o) {
                if (o[l].location >= 0) {
                  const e = r[l];
                  let n = s[l];
                  if (
                    (void 0 === n &&
                      ("instanceMatrix" === l &&
                        t.instanceMatrix &&
                        (n = t.instanceMatrix),
                      "instanceColor" === l &&
                        t.instanceColor &&
                        (n = t.instanceColor)),
                    void 0 === e)
                  )
                    return !0;
                  if (e.attribute !== n) return !0;
                  if (n && e.data !== n.data) return !0;
                  a++;
                }
              }
              return c.attributesNum !== a || c.index !== i;
            })(r, y, d, x)),
            M &&
              (function (t, e, n, i) {
                const r = {},
                  s = e.attributes;
                let a = 0;
                const o = n.getAttributes();
                for (const l in o) {
                  if (o[l].location >= 0) {
                    let e = s[l];
                    void 0 === e &&
                      ("instanceMatrix" === l &&
                        t.instanceMatrix &&
                        (e = t.instanceMatrix),
                      "instanceColor" === l &&
                        t.instanceColor &&
                        (e = t.instanceColor));
                    const n = {};
                    (n.attribute = e),
                      e && e.data && (n.data = e.data),
                      (r[l] = n),
                      a++;
                  }
                }
                (c.attributes = r), (c.attributesNum = a), (c.index = i);
              })(r, y, d, x);
        } else {
          const t = !0 === l.wireframe;
          (c.geometry === y.id && c.program === d.id && c.wireframe === t) ||
            ((c.geometry = y.id),
            (c.program = d.id),
            (c.wireframe = t),
            (M = !0));
        }
        null !== x && n.update(x, t.ELEMENT_ARRAY_BUFFER),
          (M || h) &&
            ((h = !1),
            (function (r, s, a, o) {
              if (
                !1 === i.isWebGL2 &&
                (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                null === e.get("ANGLE_instanced_arrays")
              )
                return;
              f();
              const l = o.attributes,
                c = a.getAttributes(),
                h = s.defaultAttributeValues;
              for (const e in c) {
                const s = c[e];
                if (s.location >= 0) {
                  let a = l[e];
                  if (
                    (void 0 === a &&
                      ("instanceMatrix" === e &&
                        r.instanceMatrix &&
                        (a = r.instanceMatrix),
                      "instanceColor" === e &&
                        r.instanceColor &&
                        (a = r.instanceColor)),
                    void 0 !== a)
                  ) {
                    const e = a.normalized,
                      l = a.itemSize,
                      c = n.get(a);
                    if (void 0 === c) continue;
                    const h = c.buffer,
                      u = c.type,
                      d = c.bytesPerElement,
                      p =
                        !0 === i.isWebGL2 &&
                        (u === t.INT ||
                          u === t.UNSIGNED_INT ||
                          a.gpuType === Ot);
                    if (a.isInterleavedBufferAttribute) {
                      const n = a.data,
                        i = n.stride,
                        c = a.offset;
                      if (n.isInstancedInterleavedBuffer) {
                        for (let t = 0; t < s.locationSize; t++)
                          g(s.location + t, n.meshPerAttribute);
                        !0 !== r.isInstancedMesh &&
                          void 0 === o._maxInstanceCount &&
                          (o._maxInstanceCount = n.meshPerAttribute * n.count);
                      } else
                        for (let t = 0; t < s.locationSize; t++)
                          m(s.location + t);
                      t.bindBuffer(t.ARRAY_BUFFER, h);
                      for (let t = 0; t < s.locationSize; t++)
                        _(
                          s.location + t,
                          l / s.locationSize,
                          u,
                          e,
                          i * d,
                          (c + (l / s.locationSize) * t) * d,
                          p,
                        );
                    } else {
                      if (a.isInstancedBufferAttribute) {
                        for (let t = 0; t < s.locationSize; t++)
                          g(s.location + t, a.meshPerAttribute);
                        !0 !== r.isInstancedMesh &&
                          void 0 === o._maxInstanceCount &&
                          (o._maxInstanceCount = a.meshPerAttribute * a.count);
                      } else
                        for (let t = 0; t < s.locationSize; t++)
                          m(s.location + t);
                      t.bindBuffer(t.ARRAY_BUFFER, h);
                      for (let t = 0; t < s.locationSize; t++)
                        _(
                          s.location + t,
                          l / s.locationSize,
                          u,
                          e,
                          l * d,
                          (l / s.locationSize) * t * d,
                          p,
                        );
                    }
                  } else if (void 0 !== h) {
                    const n = h[e];
                    if (void 0 !== n)
                      switch (n.length) {
                        case 2:
                          t.vertexAttrib2fv(s.location, n);
                          break;
                        case 3:
                          t.vertexAttrib3fv(s.location, n);
                          break;
                        case 4:
                          t.vertexAttrib4fv(s.location, n);
                          break;
                        default:
                          t.vertexAttrib1fv(s.location, n);
                      }
                  }
                }
              }
              v();
            })(r, l, d, y),
            null !== x &&
              t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(x).buffer));
      },
      reset: y,
      resetDefaultState: x,
      dispose: function () {
        y();
        for (const t in o) {
          const e = o[t];
          for (const t in e) {
            const n = e[t];
            for (const t in n) d(n[t].object), delete n[t];
            delete e[t];
          }
          delete o[t];
        }
      },
      releaseStatesOfGeometry: function (t) {
        if (void 0 === o[t.id]) return;
        const e = o[t.id];
        for (const n in e) {
          const t = e[n];
          for (const e in t) d(t[e].object), delete t[e];
          delete e[n];
        }
        delete o[t.id];
      },
      releaseStatesOfProgram: function (t) {
        for (const e in o) {
          const n = o[e];
          if (void 0 === n[t.id]) continue;
          const i = n[t.id];
          for (const t in i) d(i[t].object), delete i[t];
          delete n[t.id];
        }
      },
      initAttributes: f,
      enableAttribute: m,
      disableUnusedAttributes: v,
    };
  }
  function ms(t, e, n, i) {
    const r = i.isWebGL2;
    let s;
    (this.setMode = function (t) {
      s = t;
    }),
      (this.render = function (e, i) {
        t.drawArrays(s, e, i), n.update(i, s, 1);
      }),
      (this.renderInstances = function (i, a, o) {
        if (0 === o) return;
        let l, c;
        if (r) (l = t), (c = "drawArraysInstanced");
        else if (
          ((l = e.get("ANGLE_instanced_arrays")),
          (c = "drawArraysInstancedANGLE"),
          null === l)
        )
          return void console.error(
            "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
          );
        l[c](s, i, a, o), n.update(a, s, o);
      });
  }
  function gs(t, e, n) {
    let i;
    function r(e) {
      if ("highp" === e) {
        if (
          t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
            0 &&
          t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
            .precision > 0
        )
          return "highp";
        e = "mediump";
      }
      return "mediump" === e &&
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
          .precision > 0
        ? "mediump"
        : "lowp";
    }
    const s =
      "undefined" != typeof WebGL2RenderingContext &&
      "WebGL2RenderingContext" === t.constructor.name;
    let a = void 0 !== n.precision ? n.precision : "highp";
    const o = r(a);
    o !== a &&
      (console.warn(
        "THREE.WebGLRenderer:",
        a,
        "not supported, using",
        o,
        "instead.",
      ),
      (a = o));
    const l = s || e.has("WEBGL_draw_buffers"),
      c = !0 === n.logarithmicDepthBuffer,
      h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
      u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      d = t.getParameter(t.MAX_TEXTURE_SIZE),
      p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
      f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
      m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
      g = t.getParameter(t.MAX_VARYING_VECTORS),
      v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
      _ = u > 0,
      y = s || e.has("OES_texture_float");
    return {
      isWebGL2: s,
      drawBuffers: l,
      getMaxAnisotropy: function () {
        if (void 0 !== i) return i;
        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
          const n = e.get("EXT_texture_filter_anisotropic");
          i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else i = 0;
        return i;
      },
      getMaxPrecision: r,
      precision: a,
      logarithmicDepthBuffer: c,
      maxTextures: h,
      maxVertexTextures: u,
      maxTextureSize: d,
      maxCubemapSize: p,
      maxAttributes: f,
      maxVertexUniforms: m,
      maxVaryings: g,
      maxFragmentUniforms: v,
      vertexTextures: _,
      floatFragmentTextures: y,
      floatVertexTextures: _ && y,
      maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0,
    };
  }
  function vs(t) {
    const e = this;
    let n = null,
      i = 0,
      r = !1,
      s = !1;
    const a = new ns(),
      o = new an(),
      l = { value: null, needsUpdate: !1 };
    function c(t, n, i, r) {
      const s = null !== t ? t.length : 0;
      let c = null;
      if (0 !== s) {
        if (((c = l.value), !0 !== r || null === c)) {
          const e = i + 4 * s,
            r = n.matrixWorldInverse;
          o.getNormalMatrix(r),
            (null === c || c.length < e) && (c = new Float32Array(e));
          for (let n = 0, l = i; n !== s; ++n, l += 4)
            a.copy(t[n]).applyMatrix4(r, o),
              a.normal.toArray(c, l),
              (c[l + 3] = a.constant);
        }
        (l.value = c), (l.needsUpdate = !0);
      }
      return (e.numPlanes = s), (e.numIntersection = 0), c;
    }
    (this.uniform = l),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (t, e) {
        const n = 0 !== t.length || e || 0 !== i || r;
        return (r = e), (i = t.length), n;
      }),
      (this.beginShadows = function () {
        (s = !0), c(null);
      }),
      (this.endShadows = function () {
        s = !1;
      }),
      (this.setGlobalState = function (t, e) {
        n = c(t, e, 0);
      }),
      (this.setState = function (a, o, h) {
        const u = a.clippingPlanes,
          d = a.clipIntersection,
          p = a.clipShadows,
          f = t.get(a);
        if (!r || null === u || 0 === u.length || (s && !p))
          s
            ? c(null)
            : (function () {
                l.value !== n && ((l.value = n), (l.needsUpdate = i > 0));
                (e.numPlanes = i), (e.numIntersection = 0);
              })();
        else {
          const t = s ? 0 : i,
            e = 4 * t;
          let r = f.clippingState || null;
          (l.value = r), (r = c(u, o, e, h));
          for (let i = 0; i !== e; ++i) r[i] = n[i];
          (f.clippingState = r),
            (this.numIntersection = d ? this.numPlanes : 0),
            (this.numPlanes += t);
        }
      });
  }
  function _s(t) {
    let e = new WeakMap();
    function n(t, e) {
      return e === Mt ? (t.mapping = yt) : e === St && (t.mapping = xt), t;
    }
    function i(t) {
      const n = t.target;
      n.removeEventListener("dispose", i);
      const r = e.get(n);
      void 0 !== r && (e.delete(n), r.dispose());
    }
    return {
      get: function (r) {
        if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
          const s = r.mapping;
          if (s === Mt || s === St) {
            if (e.has(r)) {
              return n(e.get(r).texture, r.mapping);
            }
            {
              const s = r.image;
              if (s && s.height > 0) {
                const a = new $r(s.height / 2);
                return (
                  a.fromEquirectangularTexture(t, r),
                  e.set(r, a),
                  r.addEventListener("dispose", i),
                  n(a.texture, r.mapping)
                );
              }
              return null;
            }
          }
        }
        return r;
      },
      dispose: function () {
        e = new WeakMap();
      },
    };
  }
  class ys extends qr {
    constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
      super(),
        (this.isOrthographicCamera = !0),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = t),
        (this.right = e),
        (this.top = n),
        (this.bottom = i),
        (this.near = r),
        (this.far = s),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.left = t.left),
        (this.right = t.right),
        (this.top = t.top),
        (this.bottom = t.bottom),
        (this.near = t.near),
        (this.far = t.far),
        (this.zoom = t.zoom),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        this
      );
    }
    setViewOffset(t, e, n, i, r, s) {
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = (this.right - this.left) / (2 * this.zoom),
        e = (this.top - this.bottom) / (2 * this.zoom),
        n = (this.right + this.left) / 2,
        i = (this.top + this.bottom) / 2;
      let r = n - t,
        s = n + t,
        a = i + e,
        o = i - e;
      if (null !== this.view && this.view.enabled) {
        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
          e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        (r += t * this.view.offsetX),
          (s = r + t * this.view.width),
          (a -= e * this.view.offsetY),
          (o = a - e * this.view.height);
      }
      this.projectionMatrix.makeOrthographic(
        r,
        s,
        a,
        o,
        this.near,
        this.far,
        this.coordinateSystem,
      ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.zoom = this.zoom),
        (e.object.left = this.left),
        (e.object.right = this.right),
        (e.object.top = this.top),
        (e.object.bottom = this.bottom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        e
      );
    }
  }
  const xs = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    Ms = 20,
    Ss = new ys(),
    bs = new tr();
  let Ts = null;
  const ws = (1 + Math.sqrt(5)) / 2,
    Es = 1 / ws,
    As = [
      new Nn(1, 1, 1),
      new Nn(-1, 1, 1),
      new Nn(1, 1, -1),
      new Nn(-1, 1, -1),
      new Nn(0, ws, Es),
      new Nn(0, ws, -Es),
      new Nn(Es, 0, ws),
      new Nn(-Es, 0, ws),
      new Nn(ws, Es, 0),
      new Nn(-ws, Es, 0),
    ];
  class Rs {
    constructor(t) {
      (this._renderer = t),
        (this._pingPongRenderTarget = null),
        (this._lodMax = 0),
        (this._cubeSize = 0),
        (this._lodPlanes = []),
        (this._sizeLods = []),
        (this._sigmas = []),
        (this._blurMaterial = null),
        (this._cubemapMaterial = null),
        (this._equirectMaterial = null),
        this._compileMaterial(this._blurMaterial);
    }
    fromScene(t, e = 0, n = 0.1, i = 100) {
      (Ts = this._renderer.getRenderTarget()), this._setSize(256);
      const r = this._allocateTargets();
      return (
        (r.depthBuffer = !0),
        this._sceneToCubeUV(t, n, i, r),
        e > 0 && this._blur(r, 0, 0, e),
        this._applyPMREM(r),
        this._cleanup(r),
        r
      );
    }
    fromEquirectangular(t, e = null) {
      return this._fromTexture(t, e);
    }
    fromCubemap(t, e = null) {
      return this._fromTexture(t, e);
    }
    compileCubemapShader() {
      null === this._cubemapMaterial &&
        ((this._cubemapMaterial = Ps()),
        this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      null === this._equirectMaterial &&
        ((this._equirectMaterial = Is()),
        this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(),
        null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
        null !== this._equirectMaterial && this._equirectMaterial.dispose();
    }
    _setSize(t) {
      (this._lodMax = Math.floor(Math.log2(t))),
        (this._cubeSize = Math.pow(2, this._lodMax));
    }
    _dispose() {
      null !== this._blurMaterial && this._blurMaterial.dispose(),
        null !== this._pingPongRenderTarget &&
          this._pingPongRenderTarget.dispose();
      for (let t = 0; t < this._lodPlanes.length; t++)
        this._lodPlanes[t].dispose();
    }
    _cleanup(t) {
      this._renderer.setRenderTarget(Ts),
        (t.scissorTest = !1),
        Ls(t, 0, 0, t.width, t.height);
    }
    _fromTexture(t, e) {
      t.mapping === yt || t.mapping === xt
        ? this._setSize(
            0 === t.image.length
              ? 16
              : t.image[0].width || t.image[0].image.width,
          )
        : this._setSize(t.image.width / 4),
        (Ts = this._renderer.getRenderTarget());
      const n = e || this._allocateTargets();
      return (
        this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
      );
    }
    _allocateTargets() {
      const t = 3 * Math.max(this._cubeSize, 112),
        e = 4 * this._cubeSize,
        n = {
          magFilter: Lt,
          minFilter: Lt,
          generateMipmaps: !1,
          type: Bt,
          format: Gt,
          colorSpace: Oe,
          depthBuffer: !1,
        },
        i = Cs(t, e, n);
      if (
        null === this._pingPongRenderTarget ||
        this._pingPongRenderTarget.width !== t ||
        this._pingPongRenderTarget.height !== e
      ) {
        null !== this._pingPongRenderTarget && this._dispose(),
          (this._pingPongRenderTarget = Cs(t, e, n));
        const { _lodMax: i } = this;
        ({
          sizeLods: this._sizeLods,
          lodPlanes: this._lodPlanes,
          sigmas: this._sigmas,
        } = (function (t) {
          const e = [],
            n = [],
            i = [];
          let r = t;
          const s = t - 4 + 1 + xs.length;
          for (let a = 0; a < s; a++) {
            const s = Math.pow(2, r);
            n.push(s);
            let o = 1 / s;
            a > t - 4 ? (o = xs[a - t + 4 - 1]) : 0 === a && (o = 0), i.push(o);
            const l = 1 / (s - 2),
              c = -l,
              h = 1 + l,
              u = [c, c, h, c, h, h, c, c, h, h, c, h],
              d = 6,
              p = 6,
              f = 3,
              m = 2,
              g = 1,
              v = new Float32Array(f * p * d),
              _ = new Float32Array(m * p * d),
              y = new Float32Array(g * p * d);
            for (let t = 0; t < d; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                n = t > 2 ? 0 : -1,
                i = [
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n + 1,
                  0,
                ];
              v.set(i, f * p * t), _.set(u, m * p * t);
              const r = [t, t, t, t, t, t];
              y.set(r, g * p * t);
            }
            const x = new Mr();
            x.setAttribute("position", new hr(v, f)),
              x.setAttribute("uv", new hr(_, m)),
              x.setAttribute("faceIndex", new hr(y, g)),
              e.push(x),
              r > 4 && r--;
          }
          return { lodPlanes: e, sizeLods: n, sigmas: i };
        })(i)),
          (this._blurMaterial = (function (t, e, n) {
            const i = new Float32Array(Ms),
              r = new Nn(0, 1, 0),
              s = new Xr({
                name: "SphericalGaussianBlur",
                defines: {
                  n: Ms,
                  CUBEUV_TEXEL_WIDTH: 1 / e,
                  CUBEUV_TEXEL_HEIGHT: 1 / n,
                  CUBEUV_MAX_MIP: `${t}.0`,
                },
                uniforms: {
                  envMap: { value: null },
                  samples: { value: 1 },
                  weights: { value: i },
                  latitudinal: { value: !1 },
                  dTheta: { value: 0 },
                  mipInt: { value: 0 },
                  poleAxis: { value: r },
                },
                vertexShader: Us(),
                fragmentShader:
                  "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1,
              });
            return s;
          })(i, t, e));
      }
      return i;
    }
    _compileMaterial(t) {
      const e = new zr(this._lodPlanes[0], t);
      this._renderer.compile(e, Ss);
    }
    _sceneToCubeUV(t, e, n, i) {
      const r = new Yr(90, 1, e, n),
        s = [1, -1, 1, 1, 1, 1],
        a = [1, 1, 1, -1, -1, -1],
        o = this._renderer,
        l = o.autoClear,
        c = o.toneMapping;
      o.getClearColor(bs), (o.toneMapping = dt), (o.autoClear = !1);
      const h = new nr({
          name: "PMREM.Background",
          side: ot,
          depthWrite: !1,
          depthTest: !1,
        }),
        u = new zr(new Hr(), h);
      let d = !1;
      const p = t.background;
      p
        ? p.isColor && (h.color.copy(p), (t.background = null), (d = !0))
        : (h.color.copy(bs), (d = !0));
      for (let f = 0; f < 6; f++) {
        const e = f % 3;
        0 === e
          ? (r.up.set(0, s[f], 0), r.lookAt(a[f], 0, 0))
          : 1 === e
          ? (r.up.set(0, 0, s[f]), r.lookAt(0, a[f], 0))
          : (r.up.set(0, s[f], 0), r.lookAt(0, 0, a[f]));
        const n = this._cubeSize;
        Ls(i, e * n, f > 2 ? n : 0, n, n),
          o.setRenderTarget(i),
          d && o.render(u, r),
          o.render(t, r);
      }
      u.geometry.dispose(),
        u.material.dispose(),
        (o.toneMapping = c),
        (o.autoClear = l),
        (t.background = p);
    }
    _textureToCubeUV(t, e) {
      const n = this._renderer,
        i = t.mapping === yt || t.mapping === xt;
      i
        ? (null === this._cubemapMaterial && (this._cubemapMaterial = Ps()),
          (this._cubemapMaterial.uniforms.flipEnvMap.value =
            !1 === t.isRenderTargetTexture ? -1 : 1))
        : null === this._equirectMaterial && (this._equirectMaterial = Is());
      const r = i ? this._cubemapMaterial : this._equirectMaterial,
        s = new zr(this._lodPlanes[0], r);
      r.uniforms.envMap.value = t;
      const a = this._cubeSize;
      Ls(e, 0, 0, 3 * a, 2 * a), n.setRenderTarget(e), n.render(s, Ss);
    }
    _applyPMREM(t) {
      const e = this._renderer,
        n = e.autoClear;
      e.autoClear = !1;
      for (let i = 1; i < this._lodPlanes.length; i++) {
        const e = Math.sqrt(
            this._sigmas[i] * this._sigmas[i] -
              this._sigmas[i - 1] * this._sigmas[i - 1],
          ),
          n = As[(i - 1) % As.length];
        this._blur(t, i - 1, i, e, n);
      }
      e.autoClear = n;
    }
    _blur(t, e, n, i, r) {
      const s = this._pingPongRenderTarget;
      this._halfBlur(t, s, e, n, i, "latitudinal", r),
        this._halfBlur(s, t, n, n, i, "longitudinal", r);
    }
    _halfBlur(t, e, n, i, r, s, a) {
      const o = this._renderer,
        l = this._blurMaterial;
      "latitudinal" !== s &&
        "longitudinal" !== s &&
        console.error(
          "blur direction must be either latitudinal or longitudinal!",
        );
      const c = new zr(this._lodPlanes[i], l),
        h = l.uniforms,
        u = this._sizeLods[n] - 1,
        d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
        p = r / d,
        f = isFinite(r) ? 1 + Math.floor(3 * p) : Ms;
      f > Ms &&
        console.warn(
          `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`,
        );
      const m = [];
      let g = 0;
      for (let y = 0; y < Ms; ++y) {
        const t = y / p,
          e = Math.exp((-t * t) / 2);
        m.push(e), 0 === y ? (g += e) : y < f && (g += 2 * e);
      }
      for (let y = 0; y < m.length; y++) m[y] = m[y] / g;
      (h.envMap.value = t.texture),
        (h.samples.value = f),
        (h.weights.value = m),
        (h.latitudinal.value = "latitudinal" === s),
        a && (h.poleAxis.value = a);
      const { _lodMax: v } = this;
      (h.dTheta.value = d), (h.mipInt.value = v - n);
      const _ = this._sizeLods[i];
      Ls(
        e,
        3 * _ * (i > v - 4 ? i - v + 4 : 0),
        4 * (this._cubeSize - _),
        3 * _,
        2 * _,
      ),
        o.setRenderTarget(e),
        o.render(c, Ss);
    }
  }
  function Cs(t, e, n) {
    const i = new Ln(t, e, n);
    return (
      (i.texture.mapping = bt),
      (i.texture.name = "PMREM.cubeUv"),
      (i.scissorTest = !0),
      i
    );
  }
  function Ls(t, e, n, i, r) {
    t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
  }
  function Is() {
    return new Xr({
      name: "EquirectangularToCubeUV",
      uniforms: { envMap: { value: null } },
      vertexShader: Us(),
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function Ps() {
    return new Xr({
      name: "CubemapToCubeUV",
      uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
      vertexShader: Us(),
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function Us() {
    return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
  }
  function Ns(t) {
    let e = new WeakMap(),
      n = null;
    function i(t) {
      const n = t.target;
      n.removeEventListener("dispose", i);
      const r = e.get(n);
      void 0 !== r && (e.delete(n), r.dispose());
    }
    return {
      get: function (r) {
        if (r && r.isTexture) {
          const s = r.mapping,
            a = s === Mt || s === St,
            o = s === yt || s === xt;
          if (a || o) {
            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
              r.needsPMREMUpdate = !1;
              let i = e.get(r);
              return (
                null === n && (n = new Rs(t)),
                (i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i)),
                e.set(r, i),
                i.texture
              );
            }
            if (e.has(r)) return e.get(r).texture;
            {
              const s = r.image;
              if (
                (a && s && s.height > 0) ||
                (o &&
                  s &&
                  (function (t) {
                    let e = 0;
                    const n = 6;
                    for (let i = 0; i < n; i++) void 0 !== t[i] && e++;
                    return e === n;
                  })(s))
              ) {
                null === n && (n = new Rs(t));
                const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                return e.set(r, s), r.addEventListener("dispose", i), s.texture;
              }
              return null;
            }
          }
        }
        return r;
      },
      dispose: function () {
        (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
      },
    };
  }
  function Os(t) {
    const e = {};
    function n(n) {
      if (void 0 !== e[n]) return e[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i =
            t.getExtension("WEBGL_depth_texture") ||
            t.getExtension("MOZ_WEBGL_depth_texture") ||
            t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i =
            t.getExtension("EXT_texture_filter_anisotropic") ||
            t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
            t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i =
            t.getExtension("WEBGL_compressed_texture_s3tc") ||
            t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i =
            t.getExtension("WEBGL_compressed_texture_pvrtc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = t.getExtension(n);
      }
      return (e[n] = i), i;
    }
    return {
      has: function (t) {
        return null !== n(t);
      },
      init: function (t) {
        t.isWebGL2
          ? n("EXT_color_buffer_float")
          : (n("WEBGL_depth_texture"),
            n("OES_texture_float"),
            n("OES_texture_half_float"),
            n("OES_texture_half_float_linear"),
            n("OES_standard_derivatives"),
            n("OES_element_index_uint"),
            n("OES_vertex_array_object"),
            n("ANGLE_instanced_arrays")),
          n("OES_texture_float_linear"),
          n("EXT_color_buffer_half_float"),
          n("WEBGL_multisampled_render_to_texture");
      },
      get: function (t) {
        const e = n(t);
        return (
          null === e &&
            console.warn(
              "THREE.WebGLRenderer: " + t + " extension not supported.",
            ),
          e
        );
      },
    };
  }
  function Ds(t, e, n, i) {
    const r = {},
      s = new WeakMap();
    function a(t) {
      const o = t.target;
      null !== o.index && e.remove(o.index);
      for (const n in o.attributes) e.remove(o.attributes[n]);
      for (const n in o.morphAttributes) {
        const t = o.morphAttributes[n];
        for (let n = 0, i = t.length; n < i; n++) e.remove(t[n]);
      }
      o.removeEventListener("dispose", a), delete r[o.id];
      const l = s.get(o);
      l && (e.remove(l), s.delete(o)),
        i.releaseStatesOfGeometry(o),
        !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
        n.memory.geometries--;
    }
    function o(t) {
      const n = [],
        i = t.index,
        r = t.attributes.position;
      let a = 0;
      if (null !== i) {
        const t = i.array;
        a = i.version;
        for (let e = 0, i = t.length; e < i; e += 3) {
          const i = t[e + 0],
            r = t[e + 1],
            s = t[e + 2];
          n.push(i, r, r, s, s, i);
        }
      } else {
        if (void 0 === r) return;
        {
          const t = r.array;
          a = r.version;
          for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
            const t = e + 0,
              i = e + 1,
              r = e + 2;
            n.push(t, i, i, r, r, t);
          }
        }
      }
      const o = new (ln(n) ? dr : ur)(n, 1);
      o.version = a;
      const l = s.get(t);
      l && e.remove(l), s.set(t, o);
    }
    return {
      get: function (t, e) {
        return (
          !0 === r[e.id] ||
            (e.addEventListener("dispose", a),
            (r[e.id] = !0),
            n.memory.geometries++),
          e
        );
      },
      update: function (n) {
        const i = n.attributes;
        for (const s in i) e.update(i[s], t.ARRAY_BUFFER);
        const r = n.morphAttributes;
        for (const s in r) {
          const n = r[s];
          for (let i = 0, r = n.length; i < r; i++)
            e.update(n[i], t.ARRAY_BUFFER);
        }
      },
      getWireframeAttribute: function (t) {
        const e = s.get(t);
        if (e) {
          const n = t.index;
          null !== n && e.version < n.version && o(t);
        } else o(t);
        return s.get(t);
      },
    };
  }
  function Fs(t, e, n, i) {
    const r = i.isWebGL2;
    let s, a, o;
    (this.setMode = function (t) {
      s = t;
    }),
      (this.setIndex = function (t) {
        (a = t.type), (o = t.bytesPerElement);
      }),
      (this.render = function (e, i) {
        t.drawElements(s, i, a, e * o), n.update(i, s, 1);
      }),
      (this.renderInstances = function (i, l, c) {
        if (0 === c) return;
        let h, u;
        if (r) (h = t), (u = "drawElementsInstanced");
        else if (
          ((h = e.get("ANGLE_instanced_arrays")),
          (u = "drawElementsInstancedANGLE"),
          null === h)
        )
          return void console.error(
            "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
          );
        h[u](s, l, a, i * o, c), n.update(l, s, c);
      });
  }
  function Bs(t) {
    const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function () {
        (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
      },
      update: function (n, i, r) {
        switch ((e.calls++, i)) {
          case t.TRIANGLES:
            e.triangles += r * (n / 3);
            break;
          case t.LINES:
            e.lines += r * (n / 2);
            break;
          case t.LINE_STRIP:
            e.lines += r * (n - 1);
            break;
          case t.LINE_LOOP:
            e.lines += r * n;
            break;
          case t.POINTS:
            e.points += r * n;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", i);
        }
      },
    };
  }
  function zs(t, e) {
    return t[0] - e[0];
  }
  function ks(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }
  function Hs(t, e, n) {
    const i = {},
      r = new Float32Array(8),
      s = new WeakMap(),
      a = new Rn(),
      o = [];
    for (let l = 0; l < 8; l++) o[l] = [l, 0];
    return {
      update: function (l, c, h) {
        const u = l.morphTargetInfluences;
        if (!0 === e.isWebGL2) {
          const i =
              c.morphAttributes.position ||
              c.morphAttributes.normal ||
              c.morphAttributes.color,
            r = void 0 !== i ? i.length : 0;
          let o = s.get(c);
          if (void 0 === o || o.count !== r) {
            let t = function () {
              v.dispose(), s.delete(c), c.removeEventListener("dispose", t);
            };
            void 0 !== o && o.texture.dispose();
            const n = void 0 !== c.morphAttributes.position,
              i = void 0 !== c.morphAttributes.normal,
              l = void 0 !== c.morphAttributes.color,
              h = c.morphAttributes.position || [],
              u = c.morphAttributes.normal || [],
              d = c.morphAttributes.color || [];
            let p = 0;
            !0 === n && (p = 1), !0 === i && (p = 2), !0 === l && (p = 3);
            let f = c.attributes.position.count * p,
              m = 1;
            f > e.maxTextureSize &&
              ((m = Math.ceil(f / e.maxTextureSize)), (f = e.maxTextureSize));
            const g = new Float32Array(f * m * 4 * r),
              v = new In(g, f, m, r);
            (v.type = Ft), (v.needsUpdate = !0);
            const _ = 4 * p;
            for (let e = 0; e < r; e++) {
              const t = h[e],
                r = u[e],
                s = d[e],
                o = f * m * 4 * e;
              for (let e = 0; e < t.count; e++) {
                const c = e * _;
                !0 === n &&
                  (a.fromBufferAttribute(t, e),
                  (g[o + c + 0] = a.x),
                  (g[o + c + 1] = a.y),
                  (g[o + c + 2] = a.z),
                  (g[o + c + 3] = 0)),
                  !0 === i &&
                    (a.fromBufferAttribute(r, e),
                    (g[o + c + 4] = a.x),
                    (g[o + c + 5] = a.y),
                    (g[o + c + 6] = a.z),
                    (g[o + c + 7] = 0)),
                  !0 === l &&
                    (a.fromBufferAttribute(s, e),
                    (g[o + c + 8] = a.x),
                    (g[o + c + 9] = a.y),
                    (g[o + c + 10] = a.z),
                    (g[o + c + 11] = 4 === s.itemSize ? a.w : 1));
              }
            }
            (o = { count: r, texture: v, size: new sn(f, m) }),
              s.set(c, o),
              c.addEventListener("dispose", t);
          }
          let l = 0;
          for (let t = 0; t < u.length; t++) l += u[t];
          const d = c.morphTargetsRelative ? 1 : 1 - l;
          h.getUniforms().setValue(t, "morphTargetBaseInfluence", d),
            h.getUniforms().setValue(t, "morphTargetInfluences", u),
            h.getUniforms().setValue(t, "morphTargetsTexture", o.texture, n),
            h.getUniforms().setValue(t, "morphTargetsTextureSize", o.size);
        } else {
          const e = void 0 === u ? 0 : u.length;
          let n = i[c.id];
          if (void 0 === n || n.length !== e) {
            n = [];
            for (let t = 0; t < e; t++) n[t] = [t, 0];
            i[c.id] = n;
          }
          for (let t = 0; t < e; t++) {
            const e = n[t];
            (e[0] = t), (e[1] = u[t]);
          }
          n.sort(ks);
          for (let t = 0; t < 8; t++)
            t < e && n[t][1]
              ? ((o[t][0] = n[t][0]), (o[t][1] = n[t][1]))
              : ((o[t][0] = Number.MAX_SAFE_INTEGER), (o[t][1] = 0));
          o.sort(zs);
          const s = c.morphAttributes.position,
            a = c.morphAttributes.normal;
          let l = 0;
          for (let t = 0; t < 8; t++) {
            const e = o[t],
              n = e[0],
              i = e[1];
            n !== Number.MAX_SAFE_INTEGER && i
              ? (s &&
                  c.getAttribute("morphTarget" + t) !== s[n] &&
                  c.setAttribute("morphTarget" + t, s[n]),
                a &&
                  c.getAttribute("morphNormal" + t) !== a[n] &&
                  c.setAttribute("morphNormal" + t, a[n]),
                (r[t] = i),
                (l += i))
              : (s &&
                  !0 === c.hasAttribute("morphTarget" + t) &&
                  c.deleteAttribute("morphTarget" + t),
                a &&
                  !0 === c.hasAttribute("morphNormal" + t) &&
                  c.deleteAttribute("morphNormal" + t),
                (r[t] = 0));
          }
          const d = c.morphTargetsRelative ? 1 : 1 - l;
          h.getUniforms().setValue(t, "morphTargetBaseInfluence", d),
            h.getUniforms().setValue(t, "morphTargetInfluences", r);
        }
      },
    };
  }
  function Gs(t, e, n, i) {
    let r = new WeakMap();
    function s(t) {
      const e = t.target;
      e.removeEventListener("dispose", s),
        n.remove(e.instanceMatrix),
        null !== e.instanceColor && n.remove(e.instanceColor);
    }
    return {
      update: function (a) {
        const o = i.render.frame,
          l = a.geometry,
          c = e.get(a, l);
        if (
          (r.get(c) !== o && (e.update(c), r.set(c, o)),
          a.isInstancedMesh &&
            (!1 === a.hasEventListener("dispose", s) &&
              a.addEventListener("dispose", s),
            r.get(a) !== o &&
              (n.update(a.instanceMatrix, t.ARRAY_BUFFER),
              null !== a.instanceColor &&
                n.update(a.instanceColor, t.ARRAY_BUFFER),
              r.set(a, o))),
          a.isSkinnedMesh)
        ) {
          const t = a.skeleton;
          r.get(t) !== o && (t.update(), r.set(t, o));
        }
        return c;
      },
      dispose: function () {
        r = new WeakMap();
      },
    };
  }
  const Vs = new An(),
    Ws = new In(),
    js = new Pn(),
    Xs = new Jr(),
    qs = [],
    Ys = [],
    Ks = new Float32Array(16),
    Zs = new Float32Array(9),
    Js = new Float32Array(4);
  function $s(t, e, n) {
    const i = t[0];
    if (i <= 0 || i > 0) return t;
    const r = e * n;
    let s = qs[r];
    if ((void 0 === s && ((s = new Float32Array(r)), (qs[r] = s)), 0 !== e)) {
      i.toArray(s, 0);
      for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
    }
    return s;
  }
  function Qs(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
    return !0;
  }
  function ta(t, e) {
    for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
  }
  function ea(t, e) {
    let n = Ys[e];
    void 0 === n && ((n = new Int32Array(e)), (Ys[e] = n));
    for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
    return n;
  }
  function na(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
  }
  function ia(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (Qs(n, e)) return;
      t.uniform2fv(this.addr, e), ta(n, e);
    }
  }
  function ra(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3f(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else if (void 0 !== e.r)
      (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
        (t.uniform3f(this.addr, e.r, e.g, e.b),
        (n[0] = e.r),
        (n[1] = e.g),
        (n[2] = e.b));
    else {
      if (Qs(n, e)) return;
      t.uniform3fv(this.addr, e), ta(n, e);
    }
  }
  function sa(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (Qs(n, e)) return;
      t.uniform4fv(this.addr, e), ta(n, e);
    }
  }
  function aa(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (Qs(n, e)) return;
      t.uniformMatrix2fv(this.addr, !1, e), ta(n, e);
    } else {
      if (Qs(n, i)) return;
      Js.set(i), t.uniformMatrix2fv(this.addr, !1, Js), ta(n, i);
    }
  }
  function oa(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (Qs(n, e)) return;
      t.uniformMatrix3fv(this.addr, !1, e), ta(n, e);
    } else {
      if (Qs(n, i)) return;
      Zs.set(i), t.uniformMatrix3fv(this.addr, !1, Zs), ta(n, i);
    }
  }
  function la(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (Qs(n, e)) return;
      t.uniformMatrix4fv(this.addr, !1, e), ta(n, e);
    } else {
      if (Qs(n, i)) return;
      Ks.set(i), t.uniformMatrix4fv(this.addr, !1, Ks), ta(n, i);
    }
  }
  function ca(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
  }
  function ha(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (Qs(n, e)) return;
      t.uniform2iv(this.addr, e), ta(n, e);
    }
  }
  function ua(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3i(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else {
      if (Qs(n, e)) return;
      t.uniform3iv(this.addr, e), ta(n, e);
    }
  }
  function da(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (Qs(n, e)) return;
      t.uniform4iv(this.addr, e), ta(n, e);
    }
  }
  function pa(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
  }
  function fa(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (Qs(n, e)) return;
      t.uniform2uiv(this.addr, e), ta(n, e);
    }
  }
  function ma(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3ui(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else {
      if (Qs(n, e)) return;
      t.uniform3uiv(this.addr, e), ta(n, e);
    }
  }
  function ga(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (Qs(n, e)) return;
      t.uniform4uiv(this.addr, e), ta(n, e);
    }
  }
  function va(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture2D(e || Vs, r);
  }
  function _a(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture3D(e || js, r);
  }
  function ya(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTextureCube(e || Xs, r);
  }
  function xa(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture2DArray(e || Ws, r);
  }
  function Ma(t, e) {
    t.uniform1fv(this.addr, e);
  }
  function Sa(t, e) {
    const n = $s(e, this.size, 2);
    t.uniform2fv(this.addr, n);
  }
  function ba(t, e) {
    const n = $s(e, this.size, 3);
    t.uniform3fv(this.addr, n);
  }
  function Ta(t, e) {
    const n = $s(e, this.size, 4);
    t.uniform4fv(this.addr, n);
  }
  function wa(t, e) {
    const n = $s(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n);
  }
  function Ea(t, e) {
    const n = $s(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n);
  }
  function Aa(t, e) {
    const n = $s(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n);
  }
  function Ra(t, e) {
    t.uniform1iv(this.addr, e);
  }
  function Ca(t, e) {
    t.uniform2iv(this.addr, e);
  }
  function La(t, e) {
    t.uniform3iv(this.addr, e);
  }
  function Ia(t, e) {
    t.uniform4iv(this.addr, e);
  }
  function Pa(t, e) {
    t.uniform1uiv(this.addr, e);
  }
  function Ua(t, e) {
    t.uniform2uiv(this.addr, e);
  }
  function Na(t, e) {
    t.uniform3uiv(this.addr, e);
  }
  function Oa(t, e) {
    t.uniform4uiv(this.addr, e);
  }
  function Da(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = ea(n, r);
    Qs(i, s) || (t.uniform1iv(this.addr, s), ta(i, s));
    for (let a = 0; a !== r; ++a) n.setTexture2D(e[a] || Vs, s[a]);
  }
  function Fa(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = ea(n, r);
    Qs(i, s) || (t.uniform1iv(this.addr, s), ta(i, s));
    for (let a = 0; a !== r; ++a) n.setTexture3D(e[a] || js, s[a]);
  }
  function Ba(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = ea(n, r);
    Qs(i, s) || (t.uniform1iv(this.addr, s), ta(i, s));
    for (let a = 0; a !== r; ++a) n.setTextureCube(e[a] || Xs, s[a]);
  }
  function za(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = ea(n, r);
    Qs(i, s) || (t.uniform1iv(this.addr, s), ta(i, s));
    for (let a = 0; a !== r; ++a) n.setTexture2DArray(e[a] || Ws, s[a]);
  }
  class ka {
    constructor(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return na;
            case 35664:
              return ia;
            case 35665:
              return ra;
            case 35666:
              return sa;
            case 35674:
              return aa;
            case 35675:
              return oa;
            case 35676:
              return la;
            case 5124:
            case 35670:
              return ca;
            case 35667:
            case 35671:
              return ha;
            case 35668:
            case 35672:
              return ua;
            case 35669:
            case 35673:
              return da;
            case 5125:
              return pa;
            case 36294:
              return fa;
            case 36295:
              return ma;
            case 36296:
              return ga;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return va;
            case 35679:
            case 36299:
            case 36307:
              return _a;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return ya;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return xa;
          }
        })(e.type));
    }
  }
  class Ha {
    constructor(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return Ma;
            case 35664:
              return Sa;
            case 35665:
              return ba;
            case 35666:
              return Ta;
            case 35674:
              return wa;
            case 35675:
              return Ea;
            case 35676:
              return Aa;
            case 5124:
            case 35670:
              return Ra;
            case 35667:
            case 35671:
              return Ca;
            case 35668:
            case 35672:
              return La;
            case 35669:
            case 35673:
              return Ia;
            case 5125:
              return Pa;
            case 36294:
              return Ua;
            case 36295:
              return Na;
            case 36296:
              return Oa;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Da;
            case 35679:
            case 36299:
            case 36307:
              return Fa;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Ba;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return za;
          }
        })(e.type));
    }
  }
  class Ga {
    constructor(t) {
      (this.id = t), (this.seq = []), (this.map = {});
    }
    setValue(t, e, n) {
      const i = this.seq;
      for (let r = 0, s = i.length; r !== s; ++r) {
        const s = i[r];
        s.setValue(t, e[s.id], n);
      }
    }
  }
  const Va = /(\w+)(\])?(\[|\.)?/g;
  function Wa(t, e) {
    t.seq.push(e), (t.map[e.id] = e);
  }
  function ja(t, e, n) {
    const i = t.name,
      r = i.length;
    for (Va.lastIndex = 0; ; ) {
      const s = Va.exec(i),
        a = Va.lastIndex;
      let o = s[1];
      const l = "]" === s[2],
        c = s[3];
      if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
        Wa(n, void 0 === c ? new ka(o, t, e) : new Ha(o, t, e));
        break;
      }
      {
        let t = n.map[o];
        void 0 === t && ((t = new Ga(o)), Wa(n, t)), (n = t);
      }
    }
  }
  class Xa {
    constructor(t, e) {
      (this.seq = []), (this.map = {});
      const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
      for (let i = 0; i < n; ++i) {
        const n = t.getActiveUniform(e, i);
        ja(n, t.getUniformLocation(e, n.name), this);
      }
    }
    setValue(t, e, n, i) {
      const r = this.map[e];
      void 0 !== r && r.setValue(t, n, i);
    }
    setOptional(t, e, n) {
      const i = e[n];
      void 0 !== i && this.setValue(t, n, i);
    }
    static upload(t, e, n, i) {
      for (let r = 0, s = e.length; r !== s; ++r) {
        const s = e[r],
          a = n[s.id];
        !1 !== a.needsUpdate && s.setValue(t, a.value, i);
      }
    }
    static seqWithValue(t, e) {
      const n = [];
      for (let i = 0, r = t.length; i !== r; ++i) {
        const r = t[i];
        r.id in e && n.push(r);
      }
      return n;
    }
  }
  function qa(t, e, n) {
    const i = t.createShader(e);
    return t.shaderSource(i, n), t.compileShader(i), i;
  }
  let Ya = 0;
  function Ka(t, e, n) {
    const i = t.getShaderParameter(e, t.COMPILE_STATUS),
      r = t.getShaderInfoLog(e).trim();
    if (i && "" === r) return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
      const i = parseInt(s[1]);
      return (
        n.toUpperCase() +
        "\n\n" +
        r +
        "\n\n" +
        (function (t, e) {
          const n = t.split("\n"),
            i = [],
            r = Math.max(e - 6, 0),
            s = Math.min(e + 6, n.length);
          for (let a = r; a < s; a++) {
            const t = a + 1;
            i.push(`${t === e ? ">" : " "} ${t}: ${n[a]}`);
          }
          return i.join("\n");
        })(t.getShaderSource(e), i)
      );
    }
    return r;
  }
  function Za(t, e) {
    const n = (function (t) {
      switch (t) {
        case Oe:
          return ["Linear", "( value )"];
        case Ne:
          return ["sRGB", "( value )"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported color space:", t),
            ["Linear", "( value )"]
          );
      }
    })(e);
    return (
      "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    );
  }
  function Ja(t, e) {
    let n;
    switch (e) {
      case pt:
        n = "Linear";
        break;
      case ft:
        n = "Reinhard";
        break;
      case mt:
        n = "OptimizedCineon";
        break;
      case gt:
        n = "ACESFilmic";
        break;
      case vt:
        n = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
          (n = "Linear");
    }
    return (
      "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    );
  }
  function $a(t) {
    return "" !== t;
  }
  function Qa(t, e) {
    const n =
      e.numSpotLightShadows +
      e.numSpotLightMaps -
      e.numSpotLightShadowsWithMaps;
    return t
      .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
      .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
      .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
      .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
      .replace(
        /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
        e.numSpotLightShadowsWithMaps,
      )
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }
  function to(t, e) {
    return t
      .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        e.numClippingPlanes - e.numClipIntersection,
      );
  }
  const eo = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function no(t) {
    return t.replace(eo, ro);
  }
  const io = new Map([
    ["encodings_fragment", "colorspace_fragment"],
    ["encodings_pars_fragment", "colorspace_pars_fragment"],
    ["output_fragment", "opaque_fragment"],
  ]);
  function ro(t, e) {
    let n = cs[e];
    if (void 0 === n) {
      const t = io.get(e);
      if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
      (n = cs[t]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          t,
        );
    }
    return no(n);
  }
  const so =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function ao(t) {
    return t.replace(so, oo);
  }
  function oo(t, e, n, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(n); s++)
      r += i
        .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
        .replace(/UNROLLED_LOOP_INDEX/g, s);
    return r;
  }
  function lo(t) {
    let e =
      "precision " +
      t.precision +
      " float;\nprecision " +
      t.precision +
      " int;";
    return (
      "highp" === t.precision
        ? (e += "\n#define HIGH_PRECISION")
        : "mediump" === t.precision
        ? (e += "\n#define MEDIUM_PRECISION")
        : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
      e
    );
  }
  function co(t, e, n, i) {
    const r = t.getContext(),
      s = n.defines;
    let a = n.vertexShader,
      o = n.fragmentShader;
    const l = (function (t) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          t.shadowMapType === it
            ? (e = "SHADOWMAP_TYPE_PCF")
            : t.shadowMapType === rt
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : t.shadowMapType === st && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      })(n),
      c = (function (t) {
        let e = "ENVMAP_TYPE_CUBE";
        if (t.envMap)
          switch (t.envMapMode) {
            case yt:
            case xt:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case bt:
              e = "ENVMAP_TYPE_CUBE_UV";
          }
        return e;
      })(n),
      h = (function (t) {
        let e = "ENVMAP_MODE_REFLECTION";
        t.envMap && t.envMapMode === xt && (e = "ENVMAP_MODE_REFRACTION");
        return e;
      })(n),
      u = (function (t) {
        let e = "ENVMAP_BLENDING_NONE";
        if (t.envMap)
          switch (t.combine) {
            case ct:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case ht:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case ut:
              e = "ENVMAP_BLENDING_ADD";
          }
        return e;
      })(n),
      d = (function (t) {
        const e = t.envMapCubeUVHeight;
        if (null === e) return null;
        const n = Math.log2(e) - 2,
          i = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
          texelHeight: i,
          maxMip: n,
        };
      })(n),
      p = n.isWebGL2
        ? ""
        : (function (t) {
            return [
              t.extensionDerivatives ||
              t.envMapCubeUVHeight ||
              t.bumpMap ||
              t.normalMapTangentSpace ||
              t.clearcoatNormalMap ||
              t.flatShading ||
              "physical" === t.shaderID
                ? "#extension GL_OES_standard_derivatives : enable"
                : "",
              (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
              t.rendererExtensionFragDepth
                ? "#extension GL_EXT_frag_depth : enable"
                : "",
              t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                ? "#extension GL_EXT_draw_buffers : require"
                : "",
              (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
              t.rendererExtensionShaderTextureLod
                ? "#extension GL_EXT_shader_texture_lod : enable"
                : "",
            ]
              .filter($a)
              .join("\n");
          })(n),
      f = (function (t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          !1 !== i && e.push("#define " + n + " " + i);
        }
        return e.join("\n");
      })(s),
      m = r.createProgram();
    let g,
      v,
      _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
    n.isRawShaderMaterial
      ? ((g = [
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          f,
        ]
          .filter($a)
          .join("\n")),
        g.length > 0 && (g += "\n"),
        (v = [
          p,
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          f,
        ]
          .filter($a)
          .join("\n")),
        v.length > 0 && (v += "\n"))
      : ((g = [
          lo(n),
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          f,
          n.instancing ? "#define USE_INSTANCING" : "",
          n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + h : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          n.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.alphaHash ? "#define USE_ALPHAHASH" : "",
          n.transmission ? "#define USE_TRANSMISSION" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          n.mapUv ? "#define MAP_UV " + n.mapUv : "",
          n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
          n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
          n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
          n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
          n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
          n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
          n.displacementMapUv
            ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
            : "",
          n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
          n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
          n.anisotropyMapUv
            ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
            : "",
          n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
          n.clearcoatNormalMapUv
            ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
            : "",
          n.clearcoatRoughnessMapUv
            ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
            : "",
          n.iridescenceMapUv
            ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
            : "",
          n.iridescenceThicknessMapUv
            ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
              n.iridescenceThicknessMapUv
            : "",
          n.sheenColorMapUv
            ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
            : "",
          n.sheenRoughnessMapUv
            ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
            : "",
          n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
          n.specularColorMapUv
            ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
            : "",
          n.specularIntensityMapUv
            ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
            : "",
          n.transmissionMapUv
            ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
            : "",
          n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
          n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "",
          n.vertexColors ? "#define USE_COLOR" : "",
          n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          n.vertexUv1s ? "#define USE_UV1" : "",
          n.vertexUv2s ? "#define USE_UV2" : "",
          n.vertexUv3s ? "#define USE_UV3" : "",
          n.pointsUvs ? "#define USE_POINTS_UV" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.skinning ? "#define USE_SKINNING" : "",
          n.morphTargets ? "#define USE_MORPHTARGETS" : "",
          n.morphNormals && !1 === n.flatShading
            ? "#define USE_MORPHNORMALS"
            : "",
          n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
          n.morphTargetsCount > 0 && n.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE"
            : "",
          n.morphTargetsCount > 0 && n.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
            : "",
          n.morphTargetsCount > 0 && n.isWebGL2
            ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
            : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + l : "",
          n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "\tattribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "\tattribute vec3 instanceColor;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "\tattribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "\tattribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "\tattribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "\tattribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "\tattribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "\tattribute vec3 color;",
          "#endif",
          "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
          "\tattribute vec3 morphTarget0;",
          "\tattribute vec3 morphTarget1;",
          "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;",
          "\t#ifdef USE_MORPHNORMALS",
          "\t\tattribute vec3 morphNormal0;",
          "\t\tattribute vec3 morphNormal1;",
          "\t\tattribute vec3 morphNormal2;",
          "\t\tattribute vec3 morphNormal3;",
          "\t#else",
          "\t\tattribute vec3 morphTarget4;",
          "\t\tattribute vec3 morphTarget5;",
          "\t\tattribute vec3 morphTarget6;",
          "\t\tattribute vec3 morphTarget7;",
          "\t#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "\tattribute vec4 skinIndex;",
          "\tattribute vec4 skinWeight;",
          "#endif",
          "\n",
        ]
          .filter($a)
          .join("\n")),
        (v = [
          p,
          lo(n),
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          f,
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.matcap ? "#define USE_MATCAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + c : "",
          n.envMap ? "#define " + h : "",
          n.envMap ? "#define " + u : "",
          d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
          d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
          d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.anisotropy ? "#define USE_ANISOTROPY" : "",
          n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          n.clearcoat ? "#define USE_CLEARCOAT" : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.iridescence ? "#define USE_IRIDESCENCE" : "",
          n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          n.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.alphaTest ? "#define USE_ALPHATEST" : "",
          n.alphaHash ? "#define USE_ALPHAHASH" : "",
          n.sheen ? "#define USE_SHEEN" : "",
          n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          n.transmission ? "#define USE_TRANSMISSION" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "",
          n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
          n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          n.vertexUv1s ? "#define USE_UV1" : "",
          n.vertexUv2s ? "#define USE_UV2" : "",
          n.vertexUv3s ? "#define USE_UV3" : "",
          n.pointsUvs ? "#define USE_POINTS_UV" : "",
          n.gradientMap ? "#define USE_GRADIENTMAP" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + l : "",
          n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          n.toneMapping !== dt ? "#define TONE_MAPPING" : "",
          n.toneMapping !== dt ? cs.tonemapping_pars_fragment : "",
          n.toneMapping !== dt ? Ja("toneMapping", n.toneMapping) : "",
          n.dithering ? "#define DITHERING" : "",
          n.opaque ? "#define OPAQUE" : "",
          cs.colorspace_pars_fragment,
          Za("linearToOutputTexel", n.outputColorSpace),
          n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
          "\n",
        ]
          .filter($a)
          .join("\n"))),
      (a = no(a)),
      (a = Qa(a, n)),
      (a = to(a, n)),
      (o = no(o)),
      (o = Qa(o, n)),
      (o = to(o, n)),
      (a = ao(a)),
      (o = ao(o)),
      n.isWebGL2 &&
        !0 !== n.isRawShaderMaterial &&
        ((_ = "#version 300 es\n"),
        (g =
          [
            "precision mediump sampler2DArray;",
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture",
          ].join("\n") +
          "\n" +
          g),
        (v =
          [
            "#define varying in",
            n.glslVersion === ze
              ? ""
              : "layout(location = 0) out highp vec4 pc_fragColor;",
            n.glslVersion === ze ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad",
          ].join("\n") +
          "\n" +
          v));
    const y = _ + g + a,
      x = _ + v + o,
      M = qa(r, r.VERTEX_SHADER, y),
      S = qa(r, r.FRAGMENT_SHADER, x);
    if (
      (r.attachShader(m, M),
      r.attachShader(m, S),
      void 0 !== n.index0AttributeName
        ? r.bindAttribLocation(m, 0, n.index0AttributeName)
        : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
      r.linkProgram(m),
      t.debug.checkShaderErrors)
    ) {
      const e = r.getProgramInfoLog(m).trim(),
        n = r.getShaderInfoLog(M).trim(),
        i = r.getShaderInfoLog(S).trim();
      let s = !0,
        a = !0;
      if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
        if (((s = !1), "function" == typeof t.debug.onShaderError))
          t.debug.onShaderError(r, m, M, S);
        else {
          const t = Ka(r, M, "vertex"),
            n = Ka(r, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(m, r.VALIDATE_STATUS) +
              "\n\nProgram Info Log: " +
              e +
              "\n" +
              t +
              "\n" +
              n,
          );
        }
      else
        "" !== e
          ? console.warn("THREE.WebGLProgram: Program Info Log:", e)
          : ("" !== n && "" !== i) || (a = !1);
      a &&
        (this.diagnostics = {
          runnable: s,
          programLog: e,
          vertexShader: { log: n, prefix: g },
          fragmentShader: { log: i, prefix: v },
        });
    }
    let b, T;
    return (
      r.deleteShader(M),
      r.deleteShader(S),
      (this.getUniforms = function () {
        return void 0 === b && (b = new Xa(r, m)), b;
      }),
      (this.getAttributes = function () {
        return (
          void 0 === T &&
            (T = (function (t, e) {
              const n = {},
                i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
              for (let r = 0; r < i; r++) {
                const i = t.getActiveAttrib(e, r),
                  s = i.name;
                let a = 1;
                i.type === t.FLOAT_MAT2 && (a = 2),
                  i.type === t.FLOAT_MAT3 && (a = 3),
                  i.type === t.FLOAT_MAT4 && (a = 4),
                  (n[s] = {
                    type: i.type,
                    location: t.getAttribLocation(e, s),
                    locationSize: a,
                  });
              }
              return n;
            })(r, m)),
          T
        );
      }),
      (this.destroy = function () {
        i.releaseStatesOfProgram(this),
          r.deleteProgram(m),
          (this.program = void 0);
      }),
      (this.type = n.shaderType),
      (this.name = n.shaderName),
      (this.id = Ya++),
      (this.cacheKey = e),
      (this.usedTimes = 1),
      (this.program = m),
      (this.vertexShader = M),
      (this.fragmentShader = S),
      this
    );
  }
  let ho = 0;
  class uo {
    constructor() {
      (this.shaderCache = new Map()), (this.materialCache = new Map());
    }
    update(t) {
      const e = t.vertexShader,
        n = t.fragmentShader,
        i = this._getShaderStage(e),
        r = this._getShaderStage(n),
        s = this._getShaderCacheForMaterial(t);
      return (
        !1 === s.has(i) && (s.add(i), i.usedTimes++),
        !1 === s.has(r) && (s.add(r), r.usedTimes++),
        this
      );
    }
    remove(t) {
      const e = this.materialCache.get(t);
      for (const n of e)
        n.usedTimes--, 0 === n.usedTimes && this.shaderCache.delete(n.code);
      return this.materialCache.delete(t), this;
    }
    getVertexShaderID(t) {
      return this._getShaderStage(t.vertexShader).id;
    }
    getFragmentShaderID(t) {
      return this._getShaderStage(t.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(t) {
      const e = this.materialCache;
      let n = e.get(t);
      return void 0 === n && ((n = new Set()), e.set(t, n)), n;
    }
    _getShaderStage(t) {
      const e = this.shaderCache;
      let n = e.get(t);
      return void 0 === n && ((n = new po(t)), e.set(t, n)), n;
    }
  }
  class po {
    constructor(t) {
      (this.id = ho++), (this.code = t), (this.usedTimes = 0);
    }
  }
  function fo(t, e, n, i, r, s, a) {
    const o = new Mi(),
      l = new uo(),
      c = [],
      h = r.isWebGL2,
      u = r.logarithmicDepthBuffer,
      d = r.vertexTextures;
    let p = r.precision;
    const f = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    };
    function m(t) {
      return 0 === t ? "uv" : `uv${t}`;
    }
    return {
      getParameters: function (s, o, c, g, v) {
        const _ = g.fog,
          y = v.geometry,
          x = s.isMeshStandardMaterial ? g.environment : null,
          M = (s.isMeshStandardMaterial ? n : e).get(s.envMap || x),
          S = M && M.mapping === bt ? M.image.height : null,
          b = f[s.type];
        null !== s.precision &&
          ((p = r.getMaxPrecision(s.precision)),
          p !== s.precision &&
            console.warn(
              "THREE.WebGLProgram.getParameters:",
              s.precision,
              "not supported, using",
              p,
              "instead.",
            ));
        const T =
            y.morphAttributes.position ||
            y.morphAttributes.normal ||
            y.morphAttributes.color,
          w = void 0 !== T ? T.length : 0;
        let E,
          A,
          R,
          C,
          L = 0;
        if (
          (void 0 !== y.morphAttributes.position && (L = 1),
          void 0 !== y.morphAttributes.normal && (L = 2),
          void 0 !== y.morphAttributes.color && (L = 3),
          b)
        ) {
          const t = us[b];
          (E = t.vertexShader), (A = t.fragmentShader);
        } else
          (E = s.vertexShader),
            (A = s.fragmentShader),
            l.update(s),
            (R = l.getVertexShaderID(s)),
            (C = l.getFragmentShaderID(s));
        const I = t.getRenderTarget(),
          P = !0 === v.isInstancedMesh,
          U = !!s.map,
          N = !!s.matcap,
          O = !!M,
          D = !!s.aoMap,
          F = !!s.lightMap,
          B = !!s.bumpMap,
          z = !!s.normalMap,
          k = !!s.displacementMap,
          H = !!s.emissiveMap,
          G = !!s.metalnessMap,
          V = !!s.roughnessMap,
          W = s.anisotropy > 0,
          j = s.clearcoat > 0,
          X = s.iridescence > 0,
          q = s.sheen > 0,
          Y = s.transmission > 0,
          K = W && !!s.anisotropyMap,
          Z = j && !!s.clearcoatMap,
          J = j && !!s.clearcoatNormalMap,
          $ = j && !!s.clearcoatRoughnessMap,
          Q = X && !!s.iridescenceMap,
          tt = X && !!s.iridescenceThicknessMap,
          et = q && !!s.sheenColorMap,
          nt = q && !!s.sheenRoughnessMap,
          it = !!s.specularMap,
          rt = !!s.specularColorMap,
          st = !!s.specularIntensityMap,
          at = Y && !!s.transmissionMap,
          lt = Y && !!s.thicknessMap,
          ct = !!s.gradientMap,
          ht = !!s.alphaMap,
          ut = s.alphaTest > 0,
          pt = !!s.alphaHash,
          ft = !!s.extensions,
          mt = !!y.attributes.uv1,
          gt = !!y.attributes.uv2,
          vt = !!y.attributes.uv3;
        let _t = dt;
        return (
          s.toneMapped &&
            ((null !== I && !0 !== I.isXRRenderTarget) || (_t = t.toneMapping)),
          {
            isWebGL2: h,
            shaderID: b,
            shaderType: s.type,
            shaderName: s.name,
            vertexShader: E,
            fragmentShader: A,
            defines: s.defines,
            customVertexShaderID: R,
            customFragmentShaderID: C,
            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
            glslVersion: s.glslVersion,
            precision: p,
            instancing: P,
            instancingColor: P && null !== v.instanceColor,
            supportsVertexTextures: d,
            outputColorSpace:
              null === I
                ? t.outputColorSpace
                : !0 === I.isXRRenderTarget
                ? I.texture.colorSpace
                : Oe,
            map: U,
            matcap: N,
            envMap: O,
            envMapMode: O && M.mapping,
            envMapCubeUVHeight: S,
            aoMap: D,
            lightMap: F,
            bumpMap: B,
            normalMap: z,
            displacementMap: d && k,
            emissiveMap: H,
            normalMapObjectSpace: z && 1 === s.normalMapType,
            normalMapTangentSpace: z && 0 === s.normalMapType,
            metalnessMap: G,
            roughnessMap: V,
            anisotropy: W,
            anisotropyMap: K,
            clearcoat: j,
            clearcoatMap: Z,
            clearcoatNormalMap: J,
            clearcoatRoughnessMap: $,
            iridescence: X,
            iridescenceMap: Q,
            iridescenceThicknessMap: tt,
            sheen: q,
            sheenColorMap: et,
            sheenRoughnessMap: nt,
            specularMap: it,
            specularColorMap: rt,
            specularIntensityMap: st,
            transmission: Y,
            transmissionMap: at,
            thicknessMap: lt,
            gradientMap: ct,
            opaque: !1 === s.transparent && 1 === s.blending,
            alphaMap: ht,
            alphaTest: ut,
            alphaHash: pt,
            combine: s.combine,
            mapUv: U && m(s.map.channel),
            aoMapUv: D && m(s.aoMap.channel),
            lightMapUv: F && m(s.lightMap.channel),
            bumpMapUv: B && m(s.bumpMap.channel),
            normalMapUv: z && m(s.normalMap.channel),
            displacementMapUv: k && m(s.displacementMap.channel),
            emissiveMapUv: H && m(s.emissiveMap.channel),
            metalnessMapUv: G && m(s.metalnessMap.channel),
            roughnessMapUv: V && m(s.roughnessMap.channel),
            anisotropyMapUv: K && m(s.anisotropyMap.channel),
            clearcoatMapUv: Z && m(s.clearcoatMap.channel),
            clearcoatNormalMapUv: J && m(s.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: $ && m(s.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Q && m(s.iridescenceMap.channel),
            iridescenceThicknessMapUv:
              tt && m(s.iridescenceThicknessMap.channel),
            sheenColorMapUv: et && m(s.sheenColorMap.channel),
            sheenRoughnessMapUv: nt && m(s.sheenRoughnessMap.channel),
            specularMapUv: it && m(s.specularMap.channel),
            specularColorMapUv: rt && m(s.specularColorMap.channel),
            specularIntensityMapUv: st && m(s.specularIntensityMap.channel),
            transmissionMapUv: at && m(s.transmissionMap.channel),
            thicknessMapUv: lt && m(s.thicknessMap.channel),
            alphaMapUv: ht && m(s.alphaMap.channel),
            vertexTangents: !!y.attributes.tangent && (z || W),
            vertexColors: s.vertexColors,
            vertexAlphas:
              !0 === s.vertexColors &&
              !!y.attributes.color &&
              4 === y.attributes.color.itemSize,
            vertexUv1s: mt,
            vertexUv2s: gt,
            vertexUv3s: vt,
            pointsUvs: !0 === v.isPoints && !!y.attributes.uv && (U || ht),
            fog: !!_,
            useFog: !0 === s.fog,
            fogExp2: _ && _.isFogExp2,
            flatShading: !0 === s.flatShading,
            sizeAttenuation: !0 === s.sizeAttenuation,
            logarithmicDepthBuffer: u,
            skinning: !0 === v.isSkinnedMesh,
            morphTargets: void 0 !== y.morphAttributes.position,
            morphNormals: void 0 !== y.morphAttributes.normal,
            morphColors: void 0 !== y.morphAttributes.color,
            morphTargetsCount: w,
            morphTextureStride: L,
            numDirLights: o.directional.length,
            numPointLights: o.point.length,
            numSpotLights: o.spot.length,
            numSpotLightMaps: o.spotLightMap.length,
            numRectAreaLights: o.rectArea.length,
            numHemiLights: o.hemi.length,
            numDirLightShadows: o.directionalShadowMap.length,
            numPointLightShadows: o.pointShadowMap.length,
            numSpotLightShadows: o.spotShadowMap.length,
            numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            dithering: s.dithering,
            shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
            shadowMapType: t.shadowMap.type,
            toneMapping: _t,
            useLegacyLights: t._useLegacyLights,
            premultipliedAlpha: s.premultipliedAlpha,
            doubleSided: 2 === s.side,
            flipSided: s.side === ot,
            useDepthPacking: s.depthPacking >= 0,
            depthPacking: s.depthPacking || 0,
            index0AttributeName: s.index0AttributeName,
            extensionDerivatives: ft && !0 === s.extensions.derivatives,
            extensionFragDepth: ft && !0 === s.extensions.fragDepth,
            extensionDrawBuffers: ft && !0 === s.extensions.drawBuffers,
            extensionShaderTextureLOD:
              ft && !0 === s.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              h || i.has("EXT_shader_texture_lod"),
            customProgramCacheKey: s.customProgramCacheKey(),
          }
        );
      },
      getProgramCacheKey: function (e) {
        const n = [];
        if (
          (e.shaderID
            ? n.push(e.shaderID)
            : (n.push(e.customVertexShaderID),
              n.push(e.customFragmentShaderID)),
          void 0 !== e.defines)
        )
          for (const t in e.defines) n.push(t), n.push(e.defines[t]);
        return (
          !1 === e.isRawShaderMaterial &&
            (!(function (t, e) {
              t.push(e.precision),
                t.push(e.outputColorSpace),
                t.push(e.envMapMode),
                t.push(e.envMapCubeUVHeight),
                t.push(e.mapUv),
                t.push(e.alphaMapUv),
                t.push(e.lightMapUv),
                t.push(e.aoMapUv),
                t.push(e.bumpMapUv),
                t.push(e.normalMapUv),
                t.push(e.displacementMapUv),
                t.push(e.emissiveMapUv),
                t.push(e.metalnessMapUv),
                t.push(e.roughnessMapUv),
                t.push(e.anisotropyMapUv),
                t.push(e.clearcoatMapUv),
                t.push(e.clearcoatNormalMapUv),
                t.push(e.clearcoatRoughnessMapUv),
                t.push(e.iridescenceMapUv),
                t.push(e.iridescenceThicknessMapUv),
                t.push(e.sheenColorMapUv),
                t.push(e.sheenRoughnessMapUv),
                t.push(e.specularMapUv),
                t.push(e.specularColorMapUv),
                t.push(e.specularIntensityMapUv),
                t.push(e.transmissionMapUv),
                t.push(e.thicknessMapUv),
                t.push(e.combine),
                t.push(e.fogExp2),
                t.push(e.sizeAttenuation),
                t.push(e.morphTargetsCount),
                t.push(e.morphAttributeCount),
                t.push(e.numDirLights),
                t.push(e.numPointLights),
                t.push(e.numSpotLights),
                t.push(e.numSpotLightMaps),
                t.push(e.numHemiLights),
                t.push(e.numRectAreaLights),
                t.push(e.numDirLightShadows),
                t.push(e.numPointLightShadows),
                t.push(e.numSpotLightShadows),
                t.push(e.numSpotLightShadowsWithMaps),
                t.push(e.shadowMapType),
                t.push(e.toneMapping),
                t.push(e.numClippingPlanes),
                t.push(e.numClipIntersection),
                t.push(e.depthPacking);
            })(n, e),
            (function (t, e) {
              o.disableAll(), e.isWebGL2 && o.enable(0);
              e.supportsVertexTextures && o.enable(1);
              e.instancing && o.enable(2);
              e.instancingColor && o.enable(3);
              e.matcap && o.enable(4);
              e.envMap && o.enable(5);
              e.normalMapObjectSpace && o.enable(6);
              e.normalMapTangentSpace && o.enable(7);
              e.clearcoat && o.enable(8);
              e.iridescence && o.enable(9);
              e.alphaTest && o.enable(10);
              e.vertexColors && o.enable(11);
              e.vertexAlphas && o.enable(12);
              e.vertexUv1s && o.enable(13);
              e.vertexUv2s && o.enable(14);
              e.vertexUv3s && o.enable(15);
              e.vertexTangents && o.enable(16);
              e.anisotropy && o.enable(17);
              t.push(o.mask), o.disableAll(), e.fog && o.enable(0);
              e.useFog && o.enable(1);
              e.flatShading && o.enable(2);
              e.logarithmicDepthBuffer && o.enable(3);
              e.skinning && o.enable(4);
              e.morphTargets && o.enable(5);
              e.morphNormals && o.enable(6);
              e.morphColors && o.enable(7);
              e.premultipliedAlpha && o.enable(8);
              e.shadowMapEnabled && o.enable(9);
              e.useLegacyLights && o.enable(10);
              e.doubleSided && o.enable(11);
              e.flipSided && o.enable(12);
              e.useDepthPacking && o.enable(13);
              e.dithering && o.enable(14);
              e.transmission && o.enable(15);
              e.sheen && o.enable(16);
              e.opaque && o.enable(17);
              e.pointsUvs && o.enable(18);
              t.push(o.mask);
            })(n, e),
            n.push(t.outputColorSpace)),
          n.push(e.customProgramCacheKey),
          n.join()
        );
      },
      getUniforms: function (t) {
        const e = f[t.type];
        let n;
        if (e) {
          const t = us[e];
          n = jr.clone(t.uniforms);
        } else n = t.uniforms;
        return n;
      },
      acquireProgram: function (e, n) {
        let i;
        for (let t = 0, r = c.length; t < r; t++) {
          const e = c[t];
          if (e.cacheKey === n) {
            (i = e), ++i.usedTimes;
            break;
          }
        }
        return void 0 === i && ((i = new co(t, n, e, s)), c.push(i)), i;
      },
      releaseProgram: function (t) {
        if (0 == --t.usedTimes) {
          const e = c.indexOf(t);
          (c[e] = c[c.length - 1]), c.pop(), t.destroy();
        }
      },
      releaseShaderCache: function (t) {
        l.remove(t);
      },
      programs: c,
      dispose: function () {
        l.dispose();
      },
    };
  }
  function mo() {
    let t = new WeakMap();
    return {
      get: function (e) {
        let n = t.get(e);
        return void 0 === n && ((n = {}), t.set(e, n)), n;
      },
      remove: function (e) {
        t.delete(e);
      },
      update: function (e, n, i) {
        t.get(e)[n] = i;
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function go(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.material.id !== e.material.id
      ? t.material.id - e.material.id
      : t.z !== e.z
      ? t.z - e.z
      : t.id - e.id;
  }
  function vo(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.z !== e.z
      ? e.z - t.z
      : t.id - e.id;
  }
  function _o() {
    const t = [];
    let e = 0;
    const n = [],
      i = [],
      r = [];
    function s(n, i, r, s, a, o) {
      let l = t[e];
      return (
        void 0 === l
          ? ((l = {
              id: n.id,
              object: n,
              geometry: i,
              material: r,
              groupOrder: s,
              renderOrder: n.renderOrder,
              z: a,
              group: o,
            }),
            (t[e] = l))
          : ((l.id = n.id),
            (l.object = n),
            (l.geometry = i),
            (l.material = r),
            (l.groupOrder = s),
            (l.renderOrder = n.renderOrder),
            (l.z = a),
            (l.group = o)),
        e++,
        l
      );
    }
    return {
      opaque: n,
      transmissive: i,
      transparent: r,
      init: function () {
        (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
      },
      push: function (t, e, a, o, l, c) {
        const h = s(t, e, a, o, l, c);
        a.transmission > 0
          ? i.push(h)
          : !0 === a.transparent
          ? r.push(h)
          : n.push(h);
      },
      unshift: function (t, e, a, o, l, c) {
        const h = s(t, e, a, o, l, c);
        a.transmission > 0
          ? i.unshift(h)
          : !0 === a.transparent
          ? r.unshift(h)
          : n.unshift(h);
      },
      finish: function () {
        for (let n = e, i = t.length; n < i; n++) {
          const e = t[n];
          if (null === e.id) break;
          (e.id = null),
            (e.object = null),
            (e.geometry = null),
            (e.material = null),
            (e.group = null);
        }
      },
      sort: function (t, e) {
        n.length > 1 && n.sort(t || go),
          i.length > 1 && i.sort(e || vo),
          r.length > 1 && r.sort(e || vo);
      },
    };
  }
  function yo() {
    let t = new WeakMap();
    return {
      get: function (e, n) {
        const i = t.get(e);
        let r;
        return (
          void 0 === i
            ? ((r = new _o()), t.set(e, [r]))
            : n >= i.length
            ? ((r = new _o()), i.push(r))
            : (r = i[n]),
          r
        );
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function xo() {
    const t = {};
    return {
      get: function (e) {
        if (void 0 !== t[e.id]) return t[e.id];
        let n;
        switch (e.type) {
          case "DirectionalLight":
            n = { direction: new Nn(), color: new tr() };
            break;
          case "SpotLight":
            n = {
              position: new Nn(),
              direction: new Nn(),
              color: new tr(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
            };
            break;
          case "PointLight":
            n = { position: new Nn(), color: new tr(), distance: 0, decay: 0 };
            break;
          case "HemisphereLight":
            n = {
              direction: new Nn(),
              skyColor: new tr(),
              groundColor: new tr(),
            };
            break;
          case "RectAreaLight":
            n = {
              color: new tr(),
              position: new Nn(),
              halfWidth: new Nn(),
              halfHeight: new Nn(),
            };
        }
        return (t[e.id] = n), n;
      },
    };
  }
  let Mo = 0;
  function So(t, e) {
    return (
      (e.castShadow ? 2 : 0) -
      (t.castShadow ? 2 : 0) +
      (e.map ? 1 : 0) -
      (t.map ? 1 : 0)
    );
  }
  function bo(t, e) {
    const n = new xo(),
      i = (function () {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
              case "DirectionalLight":
              case "SpotLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new sn(),
                };
                break;
              case "PointLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new sn(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
            }
            return (t[e.id] = n), n;
          },
        };
      })(),
      r = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
          numSpotMaps: -1,
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
      };
    for (let l = 0; l < 9; l++) r.probe.push(new Nn());
    const s = new Nn(),
      a = new hi(),
      o = new hi();
    return {
      setup: function (s, a) {
        let o = 0,
          l = 0,
          c = 0;
        for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
        let h = 0,
          u = 0,
          d = 0,
          p = 0,
          f = 0,
          m = 0,
          g = 0,
          v = 0,
          _ = 0,
          y = 0;
        s.sort(So);
        const x = !0 === a ? Math.PI : 1;
        for (let t = 0, e = s.length; t < e; t++) {
          const e = s[t],
            a = e.color,
            M = e.intensity,
            S = e.distance,
            b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
          if (e.isAmbientLight)
            (o += a.r * M * x), (l += a.g * M * x), (c += a.b * M * x);
          else if (e.isLightProbe)
            for (let t = 0; t < 9; t++)
              r.probe[t].addScaledVector(e.sh.coefficients[t], M);
          else if (e.isDirectionalLight) {
            const t = n.get(e);
            if (
              (t.color.copy(e.color).multiplyScalar(e.intensity * x),
              e.castShadow)
            ) {
              const t = e.shadow,
                n = i.get(e);
              (n.shadowBias = t.bias),
                (n.shadowNormalBias = t.normalBias),
                (n.shadowRadius = t.radius),
                (n.shadowMapSize = t.mapSize),
                (r.directionalShadow[h] = n),
                (r.directionalShadowMap[h] = b),
                (r.directionalShadowMatrix[h] = e.shadow.matrix),
                m++;
            }
            (r.directional[h] = t), h++;
          } else if (e.isSpotLight) {
            const t = n.get(e);
            t.position.setFromMatrixPosition(e.matrixWorld),
              t.color.copy(a).multiplyScalar(M * x),
              (t.distance = S),
              (t.coneCos = Math.cos(e.angle)),
              (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
              (t.decay = e.decay),
              (r.spot[d] = t);
            const s = e.shadow;
            if (
              (e.map &&
                ((r.spotLightMap[_] = e.map),
                _++,
                s.updateMatrices(e),
                e.castShadow && y++),
              (r.spotLightMatrix[d] = s.matrix),
              e.castShadow)
            ) {
              const t = i.get(e);
              (t.shadowBias = s.bias),
                (t.shadowNormalBias = s.normalBias),
                (t.shadowRadius = s.radius),
                (t.shadowMapSize = s.mapSize),
                (r.spotShadow[d] = t),
                (r.spotShadowMap[d] = b),
                v++;
            }
            d++;
          } else if (e.isRectAreaLight) {
            const t = n.get(e);
            t.color.copy(a).multiplyScalar(M),
              t.halfWidth.set(0.5 * e.width, 0, 0),
              t.halfHeight.set(0, 0.5 * e.height, 0),
              (r.rectArea[p] = t),
              p++;
          } else if (e.isPointLight) {
            const t = n.get(e);
            if (
              (t.color.copy(e.color).multiplyScalar(e.intensity * x),
              (t.distance = e.distance),
              (t.decay = e.decay),
              e.castShadow)
            ) {
              const t = e.shadow,
                n = i.get(e);
              (n.shadowBias = t.bias),
                (n.shadowNormalBias = t.normalBias),
                (n.shadowRadius = t.radius),
                (n.shadowMapSize = t.mapSize),
                (n.shadowCameraNear = t.camera.near),
                (n.shadowCameraFar = t.camera.far),
                (r.pointShadow[u] = n),
                (r.pointShadowMap[u] = b),
                (r.pointShadowMatrix[u] = e.shadow.matrix),
                g++;
            }
            (r.point[u] = t), u++;
          } else if (e.isHemisphereLight) {
            const t = n.get(e);
            t.skyColor.copy(e.color).multiplyScalar(M * x),
              t.groundColor.copy(e.groundColor).multiplyScalar(M * x),
              (r.hemi[f] = t),
              f++;
          }
        }
        p > 0 &&
          (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
            ? ((r.rectAreaLTC1 = hs.LTC_FLOAT_1),
              (r.rectAreaLTC2 = hs.LTC_FLOAT_2))
            : !0 === t.has("OES_texture_half_float_linear")
            ? ((r.rectAreaLTC1 = hs.LTC_HALF_1),
              (r.rectAreaLTC2 = hs.LTC_HALF_2))
            : console.error(
                "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.",
              )),
          (r.ambient[0] = o),
          (r.ambient[1] = l),
          (r.ambient[2] = c);
        const M = r.hash;
        (M.directionalLength === h &&
          M.pointLength === u &&
          M.spotLength === d &&
          M.rectAreaLength === p &&
          M.hemiLength === f &&
          M.numDirectionalShadows === m &&
          M.numPointShadows === g &&
          M.numSpotShadows === v &&
          M.numSpotMaps === _) ||
          ((r.directional.length = h),
          (r.spot.length = d),
          (r.rectArea.length = p),
          (r.point.length = u),
          (r.hemi.length = f),
          (r.directionalShadow.length = m),
          (r.directionalShadowMap.length = m),
          (r.pointShadow.length = g),
          (r.pointShadowMap.length = g),
          (r.spotShadow.length = v),
          (r.spotShadowMap.length = v),
          (r.directionalShadowMatrix.length = m),
          (r.pointShadowMatrix.length = g),
          (r.spotLightMatrix.length = v + _ - y),
          (r.spotLightMap.length = _),
          (r.numSpotLightShadowsWithMaps = y),
          (M.directionalLength = h),
          (M.pointLength = u),
          (M.spotLength = d),
          (M.rectAreaLength = p),
          (M.hemiLength = f),
          (M.numDirectionalShadows = m),
          (M.numPointShadows = g),
          (M.numSpotShadows = v),
          (M.numSpotMaps = _),
          (r.version = Mo++));
      },
      setupView: function (t, e) {
        let n = 0,
          i = 0,
          l = 0,
          c = 0,
          h = 0;
        const u = e.matrixWorldInverse;
        for (let d = 0, p = t.length; d < p; d++) {
          const e = t[d];
          if (e.isDirectionalLight) {
            const t = r.directional[n];
            t.direction.setFromMatrixPosition(e.matrixWorld),
              s.setFromMatrixPosition(e.target.matrixWorld),
              t.direction.sub(s),
              t.direction.transformDirection(u),
              n++;
          } else if (e.isSpotLight) {
            const t = r.spot[l];
            t.position.setFromMatrixPosition(e.matrixWorld),
              t.position.applyMatrix4(u),
              t.direction.setFromMatrixPosition(e.matrixWorld),
              s.setFromMatrixPosition(e.target.matrixWorld),
              t.direction.sub(s),
              t.direction.transformDirection(u),
              l++;
          } else if (e.isRectAreaLight) {
            const t = r.rectArea[c];
            t.position.setFromMatrixPosition(e.matrixWorld),
              t.position.applyMatrix4(u),
              o.identity(),
              a.copy(e.matrixWorld),
              a.premultiply(u),
              o.extractRotation(a),
              t.halfWidth.set(0.5 * e.width, 0, 0),
              t.halfHeight.set(0, 0.5 * e.height, 0),
              t.halfWidth.applyMatrix4(o),
              t.halfHeight.applyMatrix4(o),
              c++;
          } else if (e.isPointLight) {
            const t = r.point[i];
            t.position.setFromMatrixPosition(e.matrixWorld),
              t.position.applyMatrix4(u),
              i++;
          } else if (e.isHemisphereLight) {
            const t = r.hemi[h];
            t.direction.setFromMatrixPosition(e.matrixWorld),
              t.direction.transformDirection(u),
              h++;
          }
        }
      },
      state: r,
    };
  }
  function To(t, e) {
    const n = new bo(t, e),
      i = [],
      r = [];
    return {
      init: function () {
        (i.length = 0), (r.length = 0);
      },
      state: { lightsArray: i, shadowsArray: r, lights: n },
      setupLights: function (t) {
        n.setup(i, t);
      },
      setupLightsView: function (t) {
        n.setupView(i, t);
      },
      pushLight: function (t) {
        i.push(t);
      },
      pushShadow: function (t) {
        r.push(t);
      },
    };
  }
  function wo(t, e) {
    let n = new WeakMap();
    return {
      get: function (i, r = 0) {
        const s = n.get(i);
        let a;
        return (
          void 0 === s
            ? ((a = new To(t, e)), n.set(i, [a]))
            : r >= s.length
            ? ((a = new To(t, e)), s.push(a))
            : (a = s[r]),
          a
        );
      },
      dispose: function () {
        n = new WeakMap();
      },
    };
  }
  class Eo extends Ki {
    constructor(t) {
      super(),
        (this.isMeshDepthMaterial = !0),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = 3200),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.depthPacking = t.depthPacking),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        this
      );
    }
  }
  class Ao extends Ki {
    constructor(t) {
      super(),
        (this.isMeshDistanceMaterial = !0),
        (this.type = "MeshDistanceMaterial"),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        this
      );
    }
  }
  function Ro(t, e, n) {
    let i = new ss();
    const r = new sn(),
      s = new sn(),
      a = new Rn(),
      o = new Eo({ depthPacking: 3201 }),
      l = new Ao(),
      c = {},
      h = n.maxTextureSize,
      u = { [at]: ot, [ot]: at, 2: 2 },
      d = new Xr({
        defines: { VSM_SAMPLES: 8 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new sn() },
          radius: { value: 4 },
        },
        vertexShader:
          "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader:
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
      }),
      p = d.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const f = new Mr();
    f.setAttribute(
      "position",
      new hr(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
    );
    const m = new zr(f, d),
      g = this;
    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = it);
    let v = this.type;
    function _(n, i) {
      const s = e.update(m);
      d.defines.VSM_SAMPLES !== n.blurSamples &&
        ((d.defines.VSM_SAMPLES = n.blurSamples),
        (p.defines.VSM_SAMPLES = n.blurSamples),
        (d.needsUpdate = !0),
        (p.needsUpdate = !0)),
        null === n.mapPass && (n.mapPass = new Ln(r.x, r.y)),
        (d.uniforms.shadow_pass.value = n.map.texture),
        (d.uniforms.resolution.value = n.mapSize),
        (d.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.mapPass),
        t.clear(),
        t.renderBufferDirect(i, null, s, d, m, null),
        (p.uniforms.shadow_pass.value = n.mapPass.texture),
        (p.uniforms.resolution.value = n.mapSize),
        (p.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.map),
        t.clear(),
        t.renderBufferDirect(i, null, s, p, m, null);
    }
    function y(e, n, i, r) {
      let s = null;
      const a =
        !0 === i.isPointLight
          ? e.customDistanceMaterial
          : e.customDepthMaterial;
      if (void 0 !== a) s = a;
      else if (
        ((s = !0 === i.isPointLight ? l : o),
        (t.localClippingEnabled &&
          !0 === n.clipShadows &&
          Array.isArray(n.clippingPlanes) &&
          0 !== n.clippingPlanes.length) ||
          (n.displacementMap && 0 !== n.displacementScale) ||
          (n.alphaMap && n.alphaTest > 0) ||
          (n.map && n.alphaTest > 0))
      ) {
        const t = s.uuid,
          e = n.uuid;
        let i = c[t];
        void 0 === i && ((i = {}), (c[t] = i));
        let r = i[e];
        void 0 === r && ((r = s.clone()), (i[e] = r)), (s = r);
      }
      if (
        ((s.visible = n.visible),
        (s.wireframe = n.wireframe),
        (s.side =
          r === st
            ? null !== n.shadowSide
              ? n.shadowSide
              : n.side
            : null !== n.shadowSide
            ? n.shadowSide
            : u[n.side]),
        (s.alphaMap = n.alphaMap),
        (s.alphaTest = n.alphaTest),
        (s.map = n.map),
        (s.clipShadows = n.clipShadows),
        (s.clippingPlanes = n.clippingPlanes),
        (s.clipIntersection = n.clipIntersection),
        (s.displacementMap = n.displacementMap),
        (s.displacementScale = n.displacementScale),
        (s.displacementBias = n.displacementBias),
        (s.wireframeLinewidth = n.wireframeLinewidth),
        (s.linewidth = n.linewidth),
        !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial)
      ) {
        t.properties.get(s).light = i;
      }
      return s;
    }
    function x(n, r, s, a, o) {
      if (!1 === n.visible) return;
      if (
        n.layers.test(r.layers) &&
        (n.isMesh || n.isLine || n.isPoints) &&
        (n.castShadow || (n.receiveShadow && o === st)) &&
        (!n.frustumCulled || i.intersectsObject(n))
      ) {
        n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
        const i = e.update(n),
          r = n.material;
        if (Array.isArray(r)) {
          const e = i.groups;
          for (let l = 0, c = e.length; l < c; l++) {
            const c = e[l],
              h = r[c.materialIndex];
            if (h && h.visible) {
              const e = y(n, h, a, o);
              t.renderBufferDirect(s, null, i, e, n, c);
            }
          }
        } else if (r.visible) {
          const e = y(n, r, a, o);
          t.renderBufferDirect(s, null, i, e, n, null);
        }
      }
      const l = n.children;
      for (let t = 0, e = l.length; t < e; t++) x(l[t], r, s, a, o);
    }
    this.render = function (e, n, o) {
      if (!1 === g.enabled) return;
      if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
      if (0 === e.length) return;
      const l = t.getRenderTarget(),
        c = t.getActiveCubeFace(),
        u = t.getActiveMipmapLevel(),
        d = t.state;
      d.setBlending(0),
        d.buffers.color.setClear(1, 1, 1, 1),
        d.buffers.depth.setTest(!0),
        d.setScissorTest(!1);
      const p = v !== st && this.type === st,
        f = v === st && this.type !== st;
      for (let m = 0, g = e.length; m < g; m++) {
        const l = e[m],
          c = l.shadow;
        if (void 0 === c) {
          console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
          continue;
        }
        if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
        r.copy(c.mapSize);
        const u = c.getFrameExtents();
        if (
          (r.multiply(u),
          s.copy(c.mapSize),
          (r.x > h || r.y > h) &&
            (r.x > h &&
              ((s.x = Math.floor(h / u.x)),
              (r.x = s.x * u.x),
              (c.mapSize.x = s.x)),
            r.y > h &&
              ((s.y = Math.floor(h / u.y)),
              (r.y = s.y * u.y),
              (c.mapSize.y = s.y))),
          null === c.map || !0 === p || !0 === f)
        ) {
          const t = this.type !== st ? { minFilter: At, magFilter: At } : {};
          null !== c.map && c.map.dispose(),
            (c.map = new Ln(r.x, r.y, t)),
            (c.map.texture.name = l.name + ".shadowMap"),
            c.camera.updateProjectionMatrix();
        }
        t.setRenderTarget(c.map), t.clear();
        const g = c.getViewportCount();
        for (let t = 0; t < g; t++) {
          const e = c.getViewport(t);
          a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
            d.viewport(a),
            c.updateMatrices(l, t),
            (i = c.getFrustum()),
            x(n, o, c.camera, l, this.type);
        }
        !0 !== c.isPointLightShadow && this.type === st && _(c, o),
          (c.needsUpdate = !1);
      }
      (v = this.type), (g.needsUpdate = !1), t.setRenderTarget(l, c, u);
    };
  }
  function Co(t, e, n) {
    const i = n.isWebGL2;
    const r = new (function () {
        let e = !1;
        const n = new Rn();
        let i = null;
        const r = new Rn(0, 0, 0, 0);
        return {
          setMask: function (n) {
            i === n || e || (t.colorMask(n, n, n, n), (i = n));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e, i, s, a, o) {
            !0 === o && ((e *= a), (i *= a), (s *= a)),
              n.set(e, i, s, a),
              !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));
          },
          reset: function () {
            (e = !1), (i = null), r.set(-1, 0, 0, 0);
          },
        };
      })(),
      s = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null;
        return {
          setTest: function (e) {
            e ? k(t.DEPTH_TEST) : H(t.DEPTH_TEST);
          },
          setMask: function (i) {
            n === i || e || (t.depthMask(i), (n = i));
          },
          setFunc: function (e) {
            if (i !== e) {
              switch (e) {
                case 0:
                  t.depthFunc(t.NEVER);
                  break;
                case 1:
                  t.depthFunc(t.ALWAYS);
                  break;
                case 2:
                  t.depthFunc(t.LESS);
                  break;
                case 3:
                default:
                  t.depthFunc(t.LEQUAL);
                  break;
                case 4:
                  t.depthFunc(t.EQUAL);
                  break;
                case 5:
                  t.depthFunc(t.GEQUAL);
                  break;
                case 6:
                  t.depthFunc(t.GREATER);
                  break;
                case 7:
                  t.depthFunc(t.NOTEQUAL);
              }
              i = e;
            }
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            r !== e && (t.clearDepth(e), (r = e));
          },
          reset: function () {
            (e = !1), (n = null), (i = null), (r = null);
          },
        };
      })(),
      a = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null,
          s = null,
          a = null,
          o = null,
          l = null,
          c = null;
        return {
          setTest: function (n) {
            e || (n ? k(t.STENCIL_TEST) : H(t.STENCIL_TEST));
          },
          setMask: function (i) {
            n === i || e || (t.stencilMask(i), (n = i));
          },
          setFunc: function (e, n, a) {
            (i === e && r === n && s === a) ||
              (t.stencilFunc(e, n, a), (i = e), (r = n), (s = a));
          },
          setOp: function (e, n, i) {
            (a === e && o === n && l === i) ||
              (t.stencilOp(e, n, i), (a = e), (o = n), (l = i));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            c !== e && (t.clearStencil(e), (c = e));
          },
          reset: function () {
            (e = !1),
              (n = null),
              (i = null),
              (r = null),
              (s = null),
              (a = null),
              (o = null),
              (l = null),
              (c = null);
          },
        };
      })(),
      o = new WeakMap(),
      l = new WeakMap();
    let c = {},
      h = {},
      u = new WeakMap(),
      d = [],
      p = null,
      f = !1,
      m = null,
      g = null,
      v = null,
      _ = null,
      y = null,
      x = null,
      M = null,
      S = !1,
      b = null,
      T = null,
      w = null,
      E = null,
      A = null;
    const R = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let C = !1,
      L = 0;
    const I = t.getParameter(t.VERSION);
    -1 !== I.indexOf("WebGL")
      ? ((L = parseFloat(/^WebGL (\d)/.exec(I)[1])), (C = L >= 1))
      : -1 !== I.indexOf("OpenGL ES") &&
        ((L = parseFloat(/^OpenGL ES (\d)/.exec(I)[1])), (C = L >= 2));
    let P = null,
      U = {};
    const N = t.getParameter(t.SCISSOR_BOX),
      O = t.getParameter(t.VIEWPORT),
      D = new Rn().fromArray(N),
      F = new Rn().fromArray(O);
    function B(e, n, r, s) {
      const a = new Uint8Array(4),
        o = t.createTexture();
      t.bindTexture(e, o),
        t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
        t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
      for (let l = 0; l < r; l++)
        !i || (e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY)
          ? t.texImage2D(n + l, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, a)
          : t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, a);
      return o;
    }
    const z = {};
    function k(e) {
      !0 !== c[e] && (t.enable(e), (c[e] = !0));
    }
    function H(e) {
      !1 !== c[e] && (t.disable(e), (c[e] = !1));
    }
    (z[t.TEXTURE_2D] = B(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
      (z[t.TEXTURE_CUBE_MAP] = B(
        t.TEXTURE_CUBE_MAP,
        t.TEXTURE_CUBE_MAP_POSITIVE_X,
        6,
      )),
      i &&
        ((z[t.TEXTURE_2D_ARRAY] = B(
          t.TEXTURE_2D_ARRAY,
          t.TEXTURE_2D_ARRAY,
          1,
          1,
        )),
        (z[t.TEXTURE_3D] = B(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
      r.setClear(0, 0, 0, 1),
      s.setClear(1),
      a.setClear(0),
      k(t.DEPTH_TEST),
      s.setFunc(3),
      j(!1),
      X(1),
      k(t.CULL_FACE),
      W(0);
    const G = {
      [lt]: t.FUNC_ADD,
      101: t.FUNC_SUBTRACT,
      102: t.FUNC_REVERSE_SUBTRACT,
    };
    if (i) (G[103] = t.MIN), (G[104] = t.MAX);
    else {
      const t = e.get("EXT_blend_minmax");
      null !== t && ((G[103] = t.MIN_EXT), (G[104] = t.MAX_EXT));
    }
    const V = {
      200: t.ZERO,
      201: t.ONE,
      202: t.SRC_COLOR,
      204: t.SRC_ALPHA,
      210: t.SRC_ALPHA_SATURATE,
      208: t.DST_COLOR,
      206: t.DST_ALPHA,
      203: t.ONE_MINUS_SRC_COLOR,
      205: t.ONE_MINUS_SRC_ALPHA,
      209: t.ONE_MINUS_DST_COLOR,
      207: t.ONE_MINUS_DST_ALPHA,
    };
    function W(e, n, i, r, s, a, o, l) {
      if (0 !== e) {
        if ((!1 === f && (k(t.BLEND), (f = !0)), 5 === e))
          (s = s || n),
            (a = a || i),
            (o = o || r),
            (n === g && s === y) ||
              (t.blendEquationSeparate(G[n], G[s]), (g = n), (y = s)),
            (i === v && r === _ && a === x && o === M) ||
              (t.blendFuncSeparate(V[i], V[r], V[a], V[o]),
              (v = i),
              (_ = r),
              (x = a),
              (M = o)),
            (m = e),
            (S = !1);
        else if (e !== m || l !== S) {
          if (
            ((g === lt && y === lt) ||
              (t.blendEquation(t.FUNC_ADD), (g = lt), (y = lt)),
            l)
          )
            switch (e) {
              case 1:
                t.blendFuncSeparate(
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                );
                break;
              case 2:
                t.blendFunc(t.ONE, t.ONE);
                break;
              case 3:
                t.blendFuncSeparate(
                  t.ZERO,
                  t.ONE_MINUS_SRC_COLOR,
                  t.ZERO,
                  t.ONE,
                );
                break;
              case 4:
                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
          else
            switch (e) {
              case 1:
                t.blendFuncSeparate(
                  t.SRC_ALPHA,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                );
                break;
              case 2:
                t.blendFunc(t.SRC_ALPHA, t.ONE);
                break;
              case 3:
                t.blendFuncSeparate(
                  t.ZERO,
                  t.ONE_MINUS_SRC_COLOR,
                  t.ZERO,
                  t.ONE,
                );
                break;
              case 4:
                t.blendFunc(t.ZERO, t.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
          (v = null), (_ = null), (x = null), (M = null), (m = e), (S = l);
        }
      } else !0 === f && (H(t.BLEND), (f = !1));
    }
    function j(e) {
      b !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (b = e));
    }
    function X(e) {
      0 !== e
        ? (k(t.CULL_FACE),
          e !== T &&
            (1 === e
              ? t.cullFace(t.BACK)
              : 2 === e
              ? t.cullFace(t.FRONT)
              : t.cullFace(t.FRONT_AND_BACK)))
        : H(t.CULL_FACE),
        (T = e);
    }
    function q(e, n, i) {
      e
        ? (k(t.POLYGON_OFFSET_FILL),
          (E === n && A === i) || (t.polygonOffset(n, i), (E = n), (A = i)))
        : H(t.POLYGON_OFFSET_FILL);
    }
    return {
      buffers: { color: r, depth: s, stencil: a },
      enable: k,
      disable: H,
      bindFramebuffer: function (e, n) {
        return (
          h[e] !== n &&
          (t.bindFramebuffer(e, n),
          (h[e] = n),
          i &&
            (e === t.DRAW_FRAMEBUFFER && (h[t.FRAMEBUFFER] = n),
            e === t.FRAMEBUFFER && (h[t.DRAW_FRAMEBUFFER] = n)),
          !0)
        );
      },
      drawBuffers: function (i, r) {
        let s = d,
          a = !1;
        if (i)
          if (
            ((s = u.get(r)),
            void 0 === s && ((s = []), u.set(r, s)),
            i.isWebGLMultipleRenderTargets)
          ) {
            const e = i.texture;
            if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
              for (let n = 0, i = e.length; n < i; n++)
                s[n] = t.COLOR_ATTACHMENT0 + n;
              (s.length = e.length), (a = !0);
            }
          } else
            s[0] !== t.COLOR_ATTACHMENT0 &&
              ((s[0] = t.COLOR_ATTACHMENT0), (a = !0));
        else s[0] !== t.BACK && ((s[0] = t.BACK), (a = !0));
        a &&
          (n.isWebGL2
            ? t.drawBuffers(s)
            : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
      },
      useProgram: function (e) {
        return p !== e && (t.useProgram(e), (p = e), !0);
      },
      setBlending: W,
      setMaterial: function (e, n) {
        2 === e.side ? H(t.CULL_FACE) : k(t.CULL_FACE);
        let i = e.side === ot;
        n && (i = !i),
          j(i),
          1 === e.blending && !1 === e.transparent
            ? W(0)
            : W(
                e.blending,
                e.blendEquation,
                e.blendSrc,
                e.blendDst,
                e.blendEquationAlpha,
                e.blendSrcAlpha,
                e.blendDstAlpha,
                e.premultipliedAlpha,
              ),
          s.setFunc(e.depthFunc),
          s.setTest(e.depthTest),
          s.setMask(e.depthWrite),
          r.setMask(e.colorWrite);
        const o = e.stencilWrite;
        a.setTest(o),
          o &&
            (a.setMask(e.stencilWriteMask),
            a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
            a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
          q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
          !0 === e.alphaToCoverage
            ? k(t.SAMPLE_ALPHA_TO_COVERAGE)
            : H(t.SAMPLE_ALPHA_TO_COVERAGE);
      },
      setFlipSided: j,
      setCullFace: X,
      setLineWidth: function (e) {
        e !== w && (C && t.lineWidth(e), (w = e));
      },
      setPolygonOffset: q,
      setScissorTest: function (e) {
        e ? k(t.SCISSOR_TEST) : H(t.SCISSOR_TEST);
      },
      activeTexture: function (e) {
        void 0 === e && (e = t.TEXTURE0 + R - 1),
          P !== e && (t.activeTexture(e), (P = e));
      },
      bindTexture: function (e, n, i) {
        void 0 === i && (i = null === P ? t.TEXTURE0 + R - 1 : P);
        let r = U[i];
        void 0 === r && ((r = { type: void 0, texture: void 0 }), (U[i] = r)),
          (r.type === e && r.texture === n) ||
            (P !== i && (t.activeTexture(i), (P = i)),
            t.bindTexture(e, n || z[e]),
            (r.type = e),
            (r.texture = n));
      },
      unbindTexture: function () {
        const e = U[P];
        void 0 !== e &&
          void 0 !== e.type &&
          (t.bindTexture(e.type, null),
          (e.type = void 0),
          (e.texture = void 0));
      },
      compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      compressedTexImage3D: function () {
        try {
          t.compressedTexImage3D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      updateUBOMapping: function (e, n) {
        let i = l.get(n);
        void 0 === i && ((i = new WeakMap()), l.set(n, i));
        let r = i.get(e);
        void 0 === r && ((r = t.getUniformBlockIndex(n, e.name)), i.set(e, r));
      },
      uniformBlockBinding: function (e, n) {
        const i = l.get(n).get(e);
        o.get(n) !== i &&
          (t.uniformBlockBinding(n, i, e.__bindingPointIndex), o.set(n, i));
      },
      texStorage2D: function () {
        try {
          t.texStorage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texStorage3D: function () {
        try {
          t.texStorage3D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texSubImage2D: function () {
        try {
          t.texSubImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texSubImage3D: function () {
        try {
          t.texSubImage3D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      compressedTexSubImage2D: function () {
        try {
          t.compressedTexSubImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      compressedTexSubImage3D: function () {
        try {
          t.compressedTexSubImage3D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      scissor: function (e) {
        !1 === D.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), D.copy(e));
      },
      viewport: function (e) {
        !1 === F.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), F.copy(e));
      },
      reset: function () {
        t.disable(t.BLEND),
          t.disable(t.CULL_FACE),
          t.disable(t.DEPTH_TEST),
          t.disable(t.POLYGON_OFFSET_FILL),
          t.disable(t.SCISSOR_TEST),
          t.disable(t.STENCIL_TEST),
          t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
          t.blendEquation(t.FUNC_ADD),
          t.blendFunc(t.ONE, t.ZERO),
          t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
          t.colorMask(!0, !0, !0, !0),
          t.clearColor(0, 0, 0, 0),
          t.depthMask(!0),
          t.depthFunc(t.LESS),
          t.clearDepth(1),
          t.stencilMask(4294967295),
          t.stencilFunc(t.ALWAYS, 0, 4294967295),
          t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
          t.clearStencil(0),
          t.cullFace(t.BACK),
          t.frontFace(t.CCW),
          t.polygonOffset(0, 0),
          t.activeTexture(t.TEXTURE0),
          t.bindFramebuffer(t.FRAMEBUFFER, null),
          !0 === i &&
            (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
            t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
          t.useProgram(null),
          t.lineWidth(1),
          t.scissor(0, 0, t.canvas.width, t.canvas.height),
          t.viewport(0, 0, t.canvas.width, t.canvas.height),
          (c = {}),
          (P = null),
          (U = {}),
          (h = {}),
          (u = new WeakMap()),
          (d = []),
          (p = null),
          (f = !1),
          (m = null),
          (g = null),
          (v = null),
          (_ = null),
          (y = null),
          (x = null),
          (M = null),
          (S = !1),
          (b = null),
          (T = null),
          (w = null),
          (E = null),
          (A = null),
          D.set(0, 0, t.canvas.width, t.canvas.height),
          F.set(0, 0, t.canvas.width, t.canvas.height),
          r.reset(),
          s.reset(),
          a.reset();
      },
    };
  }
  function Lo(t, e, n, i, r, s, a) {
    const o = r.isWebGL2,
      l = r.maxTextures,
      c = r.maxCubemapSize,
      h = r.maxTextureSize,
      u = r.maxSamples,
      d = e.has("WEBGL_multisampled_render_to_texture")
        ? e.get("WEBGL_multisampled_render_to_texture")
        : null,
      p =
        "undefined" != typeof navigator &&
        /OculusBrowser/g.test(navigator.userAgent),
      f = new WeakMap();
    let m;
    const g = new WeakMap();
    let v = !1;
    try {
      v =
        "undefined" != typeof OffscreenCanvas &&
        null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (V) {}
    function _(t, e) {
      return v ? new OffscreenCanvas(t, e) : un("canvas");
    }
    function y(t, e, n, i) {
      let r = 1;
      if (
        ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
        r < 1 || !0 === e)
      ) {
        if (
          ("undefined" != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
        ) {
          const i = e ? tn : Math.floor,
            s = i(r * t.width),
            a = i(r * t.height);
          void 0 === m && (m = _(s, a));
          const o = n ? _(s, a) : m;
          (o.width = s), (o.height = a);
          return (
            o.getContext("2d").drawImage(t, 0, 0, s, a),
            console.warn(
              "THREE.WebGLRenderer: Texture has been resized from (" +
                t.width +
                "x" +
                t.height +
                ") to (" +
                s +
                "x" +
                a +
                ").",
            ),
            o
          );
        }
        return (
          "data" in t &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                t.width +
                "x" +
                t.height +
                ").",
            ),
          t
        );
      }
      return t;
    }
    function x(t) {
      return $e(t.width) && $e(t.height);
    }
    function M(t, e) {
      return t.generateMipmaps && e && t.minFilter !== At && t.minFilter !== Lt;
    }
    function S(e) {
      t.generateMipmap(e);
    }
    function b(n, i, r, s, a = !1) {
      if (!1 === o) return i;
      if (null !== n) {
        if (void 0 !== t[n]) return t[n];
        console.warn(
          "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
            n +
            "'",
        );
      }
      let l = i;
      return (
        i === t.RED &&
          (r === t.FLOAT && (l = t.R32F),
          r === t.HALF_FLOAT && (l = t.R16F),
          r === t.UNSIGNED_BYTE && (l = t.R8)),
        i === t.RED_INTEGER &&
          (r === t.UNSIGNED_BYTE && (l = t.R8UI),
          r === t.UNSIGNED_SHORT && (l = t.R16UI),
          r === t.UNSIGNED_INT && (l = t.R32UI),
          r === t.BYTE && (l = t.R8I),
          r === t.SHORT && (l = t.R16I),
          r === t.INT && (l = t.R32I)),
        i === t.RG &&
          (r === t.FLOAT && (l = t.RG32F),
          r === t.HALF_FLOAT && (l = t.RG16F),
          r === t.UNSIGNED_BYTE && (l = t.RG8)),
        i === t.RGBA &&
          (r === t.FLOAT && (l = t.RGBA32F),
          r === t.HALF_FLOAT && (l = t.RGBA16F),
          r === t.UNSIGNED_BYTE &&
            (l = s === Ne && !1 === a ? t.SRGB8_ALPHA8 : t.RGBA8),
          r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4),
          r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)),
        (l !== t.R16F &&
          l !== t.R32F &&
          l !== t.RG16F &&
          l !== t.RG32F &&
          l !== t.RGBA16F &&
          l !== t.RGBA32F) ||
          e.get("EXT_color_buffer_float"),
        l
      );
    }
    function T(t, e, n) {
      return !0 === M(t, n) ||
        (t.isFramebufferTexture && t.minFilter !== At && t.minFilter !== Lt)
        ? Math.log2(Math.max(e.width, e.height)) + 1
        : void 0 !== t.mipmaps && t.mipmaps.length > 0
        ? t.mipmaps.length
        : t.isCompressedTexture && Array.isArray(t.image)
        ? e.mipmaps.length
        : 1;
    }
    function w(e) {
      return e === At || e === Rt || e === Ct ? t.NEAREST : t.LINEAR;
    }
    function E(t) {
      const e = t.target;
      e.removeEventListener("dispose", E),
        (function (t) {
          const e = i.get(t);
          if (void 0 === e.__webglInit) return;
          const n = t.source,
            r = g.get(n);
          if (r) {
            const i = r[e.__cacheKey];
            i.usedTimes--,
              0 === i.usedTimes && R(t),
              0 === Object.keys(r).length && g.delete(n);
          }
          i.remove(t);
        })(e),
        e.isVideoTexture && f.delete(e);
    }
    function A(e) {
      const n = e.target;
      n.removeEventListener("dispose", A),
        (function (e) {
          const n = e.texture,
            r = i.get(e),
            s = i.get(n);
          void 0 !== s.__webglTexture &&
            (t.deleteTexture(s.__webglTexture), a.memory.textures--);
          e.depthTexture && e.depthTexture.dispose();
          if (e.isWebGLCubeRenderTarget)
            for (let i = 0; i < 6; i++) {
              if (Array.isArray(r.__webglFramebuffer[i]))
                for (let e = 0; e < r.__webglFramebuffer[i].length; e++)
                  t.deleteFramebuffer(r.__webglFramebuffer[i][e]);
              else t.deleteFramebuffer(r.__webglFramebuffer[i]);
              r.__webglDepthbuffer &&
                t.deleteRenderbuffer(r.__webglDepthbuffer[i]);
            }
          else {
            if (Array.isArray(r.__webglFramebuffer))
              for (let e = 0; e < r.__webglFramebuffer.length; e++)
                t.deleteFramebuffer(r.__webglFramebuffer[e]);
            else t.deleteFramebuffer(r.__webglFramebuffer);
            if (
              (r.__webglDepthbuffer &&
                t.deleteRenderbuffer(r.__webglDepthbuffer),
              r.__webglMultisampledFramebuffer &&
                t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
              r.__webglColorRenderbuffer)
            )
              for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                r.__webglColorRenderbuffer[e] &&
                  t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
            r.__webglDepthRenderbuffer &&
              t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
          }
          if (e.isWebGLMultipleRenderTargets)
            for (let o = 0, l = n.length; o < l; o++) {
              const e = i.get(n[o]);
              e.__webglTexture &&
                (t.deleteTexture(e.__webglTexture), a.memory.textures--),
                i.remove(n[o]);
            }
          i.remove(n), i.remove(e);
        })(n);
    }
    function R(e) {
      const n = i.get(e);
      t.deleteTexture(n.__webglTexture);
      const r = e.source;
      delete g.get(r)[n.__cacheKey], a.memory.textures--;
    }
    let C = 0;
    function L(e, r) {
      const s = i.get(e);
      if (
        (e.isVideoTexture &&
          (function (t) {
            const e = a.render.frame;
            f.get(t) !== e && (f.set(t, e), t.update());
          })(e),
        !1 === e.isRenderTargetTexture &&
          e.version > 0 &&
          s.__version !== e.version)
      ) {
        const t = e.image;
        if (null === t)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but no image data found.",
          );
        else {
          if (!1 !== t.complete) return void D(s, e, r);
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
          );
        }
      }
      n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r);
    }
    const I = {
        [Tt]: t.REPEAT,
        [wt]: t.CLAMP_TO_EDGE,
        [Et]: t.MIRRORED_REPEAT,
      },
      P = {
        [At]: t.NEAREST,
        [Rt]: t.NEAREST_MIPMAP_NEAREST,
        [Ct]: t.NEAREST_MIPMAP_LINEAR,
        [Lt]: t.LINEAR,
        [It]: t.LINEAR_MIPMAP_NEAREST,
        [Pt]: t.LINEAR_MIPMAP_LINEAR,
      },
      U = {
        512: t.NEVER,
        519: t.ALWAYS,
        513: t.LESS,
        515: t.LEQUAL,
        514: t.EQUAL,
        518: t.GEQUAL,
        516: t.GREATER,
        517: t.NOTEQUAL,
      };
    function N(n, s, a) {
      if (
        (a
          ? (t.texParameteri(n, t.TEXTURE_WRAP_S, I[s.wrapS]),
            t.texParameteri(n, t.TEXTURE_WRAP_T, I[s.wrapT]),
            (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
              t.texParameteri(n, t.TEXTURE_WRAP_R, I[s.wrapR]),
            t.texParameteri(n, t.TEXTURE_MAG_FILTER, P[s.magFilter]),
            t.texParameteri(n, t.TEXTURE_MIN_FILTER, P[s.minFilter]))
          : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
            t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
            (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
              t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
            (s.wrapS === wt && s.wrapT === wt) ||
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
              ),
            t.texParameteri(n, t.TEXTURE_MAG_FILTER, w(s.magFilter)),
            t.texParameteri(n, t.TEXTURE_MIN_FILTER, w(s.minFilter)),
            s.minFilter !== At &&
              s.minFilter !== Lt &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
              )),
        s.compareFunction &&
          (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
          t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, U[s.compareFunction])),
        !0 === e.has("EXT_texture_filter_anisotropic"))
      ) {
        const a = e.get("EXT_texture_filter_anisotropic");
        if (s.magFilter === At) return;
        if (s.minFilter !== Ct && s.minFilter !== Pt) return;
        if (s.type === Ft && !1 === e.has("OES_texture_float_linear")) return;
        if (
          !1 === o &&
          s.type === Bt &&
          !1 === e.has("OES_texture_half_float_linear")
        )
          return;
        (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
          (t.texParameterf(
            n,
            a.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(s.anisotropy, r.getMaxAnisotropy()),
          ),
          (i.get(s).__currentAnisotropy = s.anisotropy));
      }
    }
    function O(e, n) {
      let i = !1;
      void 0 === e.__webglInit &&
        ((e.__webglInit = !0), n.addEventListener("dispose", E));
      const r = n.source;
      let s = g.get(r);
      void 0 === s && ((s = {}), g.set(r, s));
      const o = (function (t) {
        const e = [];
        return (
          e.push(t.wrapS),
          e.push(t.wrapT),
          e.push(t.wrapR || 0),
          e.push(t.magFilter),
          e.push(t.minFilter),
          e.push(t.anisotropy),
          e.push(t.internalFormat),
          e.push(t.format),
          e.push(t.type),
          e.push(t.generateMipmaps),
          e.push(t.premultiplyAlpha),
          e.push(t.flipY),
          e.push(t.unpackAlignment),
          e.push(t.colorSpace),
          e.join()
        );
      })(n);
      if (o !== e.__cacheKey) {
        void 0 === s[o] &&
          ((s[o] = { texture: t.createTexture(), usedTimes: 0 }),
          a.memory.textures++,
          (i = !0)),
          s[o].usedTimes++;
        const r = s[e.__cacheKey];
        void 0 !== r &&
          (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && R(n)),
          (e.__cacheKey = o),
          (e.__webglTexture = s[o].texture);
      }
      return i;
    }
    function D(e, r, a) {
      let l = t.TEXTURE_2D;
      (r.isDataArrayTexture || r.isCompressedArrayTexture) &&
        (l = t.TEXTURE_2D_ARRAY),
        r.isData3DTexture && (l = t.TEXTURE_3D);
      const c = O(e, r),
        u = r.source;
      n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + a);
      const d = i.get(u);
      if (u.version !== d.__version || !0 === c) {
        n.activeTexture(t.TEXTURE0 + a),
          t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
          t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
          t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
          t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
        const e =
          (function (t) {
            return (
              !o &&
              (t.wrapS !== wt ||
                t.wrapT !== wt ||
                (t.minFilter !== At && t.minFilter !== Lt))
            );
          })(r) && !1 === x(r.image);
        let i = y(r.image, e, !1, h);
        i = G(r, i);
        const p = x(i) || o,
          f = s.convert(r.format, r.colorSpace);
        let m,
          g = s.convert(r.type),
          v = b(r.internalFormat, f, g, r.colorSpace);
        N(l, r, p);
        const _ = r.mipmaps,
          w = o && !0 !== r.isVideoTexture,
          E = void 0 === d.__version || !0 === c,
          A = T(r, i, p);
        if (r.isDepthTexture)
          (v = t.DEPTH_COMPONENT),
            o
              ? (v =
                  r.type === Ft
                    ? t.DEPTH_COMPONENT32F
                    : r.type === Dt
                    ? t.DEPTH_COMPONENT24
                    : r.type === Ht
                    ? t.DEPTH24_STENCIL8
                    : t.DEPTH_COMPONENT16)
              : r.type === Ft &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2.",
                ),
            r.format === Vt &&
              v === t.DEPTH_COMPONENT &&
              r.type !== Nt &&
              r.type !== Dt &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.",
              ),
              (r.type = Dt),
              (g = s.convert(r.type))),
            r.format === Wt &&
              v === t.DEPTH_COMPONENT &&
              ((v = t.DEPTH_STENCIL),
              r.type !== Ht &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
                ),
                (r.type = Ht),
                (g = s.convert(r.type)))),
            E &&
              (w
                ? n.texStorage2D(t.TEXTURE_2D, 1, v, i.width, i.height)
                : n.texImage2D(
                    t.TEXTURE_2D,
                    0,
                    v,
                    i.width,
                    i.height,
                    0,
                    f,
                    g,
                    null,
                  ));
        else if (r.isDataTexture)
          if (_.length > 0 && p) {
            w &&
              E &&
              n.texStorage2D(t.TEXTURE_2D, A, v, _[0].width, _[0].height);
            for (let e = 0, i = _.length; e < i; e++)
              (m = _[e]),
                w
                  ? n.texSubImage2D(
                      t.TEXTURE_2D,
                      e,
                      0,
                      0,
                      m.width,
                      m.height,
                      f,
                      g,
                      m.data,
                    )
                  : n.texImage2D(
                      t.TEXTURE_2D,
                      e,
                      v,
                      m.width,
                      m.height,
                      0,
                      f,
                      g,
                      m.data,
                    );
            r.generateMipmaps = !1;
          } else
            w
              ? (E && n.texStorage2D(t.TEXTURE_2D, A, v, i.width, i.height),
                n.texSubImage2D(
                  t.TEXTURE_2D,
                  0,
                  0,
                  0,
                  i.width,
                  i.height,
                  f,
                  g,
                  i.data,
                ))
              : n.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  v,
                  i.width,
                  i.height,
                  0,
                  f,
                  g,
                  i.data,
                );
        else if (r.isCompressedTexture)
          if (r.isCompressedArrayTexture) {
            w &&
              E &&
              n.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                A,
                v,
                _[0].width,
                _[0].height,
                i.depth,
              );
            for (let e = 0, s = _.length; e < s; e++)
              (m = _[e]),
                r.format !== Gt
                  ? null !== f
                    ? w
                      ? n.compressedTexSubImage3D(
                          t.TEXTURE_2D_ARRAY,
                          e,
                          0,
                          0,
                          0,
                          m.width,
                          m.height,
                          i.depth,
                          f,
                          m.data,
                          0,
                          0,
                        )
                      : n.compressedTexImage3D(
                          t.TEXTURE_2D_ARRAY,
                          e,
                          v,
                          m.width,
                          m.height,
                          i.depth,
                          0,
                          m.data,
                          0,
                          0,
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                      )
                  : w
                  ? n.texSubImage3D(
                      t.TEXTURE_2D_ARRAY,
                      e,
                      0,
                      0,
                      0,
                      m.width,
                      m.height,
                      i.depth,
                      f,
                      g,
                      m.data,
                    )
                  : n.texImage3D(
                      t.TEXTURE_2D_ARRAY,
                      e,
                      v,
                      m.width,
                      m.height,
                      i.depth,
                      0,
                      f,
                      g,
                      m.data,
                    );
          } else {
            w &&
              E &&
              n.texStorage2D(t.TEXTURE_2D, A, v, _[0].width, _[0].height);
            for (let e = 0, i = _.length; e < i; e++)
              (m = _[e]),
                r.format !== Gt
                  ? null !== f
                    ? w
                      ? n.compressedTexSubImage2D(
                          t.TEXTURE_2D,
                          e,
                          0,
                          0,
                          m.width,
                          m.height,
                          f,
                          m.data,
                        )
                      : n.compressedTexImage2D(
                          t.TEXTURE_2D,
                          e,
                          v,
                          m.width,
                          m.height,
                          0,
                          m.data,
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                      )
                  : w
                  ? n.texSubImage2D(
                      t.TEXTURE_2D,
                      e,
                      0,
                      0,
                      m.width,
                      m.height,
                      f,
                      g,
                      m.data,
                    )
                  : n.texImage2D(
                      t.TEXTURE_2D,
                      e,
                      v,
                      m.width,
                      m.height,
                      0,
                      f,
                      g,
                      m.data,
                    );
          }
        else if (r.isDataArrayTexture)
          w
            ? (E &&
                n.texStorage3D(
                  t.TEXTURE_2D_ARRAY,
                  A,
                  v,
                  i.width,
                  i.height,
                  i.depth,
                ),
              n.texSubImage3D(
                t.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                i.width,
                i.height,
                i.depth,
                f,
                g,
                i.data,
              ))
            : n.texImage3D(
                t.TEXTURE_2D_ARRAY,
                0,
                v,
                i.width,
                i.height,
                i.depth,
                0,
                f,
                g,
                i.data,
              );
        else if (r.isData3DTexture)
          w
            ? (E &&
                n.texStorage3D(t.TEXTURE_3D, A, v, i.width, i.height, i.depth),
              n.texSubImage3D(
                t.TEXTURE_3D,
                0,
                0,
                0,
                0,
                i.width,
                i.height,
                i.depth,
                f,
                g,
                i.data,
              ))
            : n.texImage3D(
                t.TEXTURE_3D,
                0,
                v,
                i.width,
                i.height,
                i.depth,
                0,
                f,
                g,
                i.data,
              );
        else if (r.isFramebufferTexture) {
          if (E)
            if (w) n.texStorage2D(t.TEXTURE_2D, A, v, i.width, i.height);
            else {
              let e = i.width,
                r = i.height;
              for (let i = 0; i < A; i++)
                n.texImage2D(t.TEXTURE_2D, i, v, e, r, 0, f, g, null),
                  (e >>= 1),
                  (r >>= 1);
            }
        } else if (_.length > 0 && p) {
          w && E && n.texStorage2D(t.TEXTURE_2D, A, v, _[0].width, _[0].height);
          for (let e = 0, i = _.length; e < i; e++)
            (m = _[e]),
              w
                ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f, g, m)
                : n.texImage2D(t.TEXTURE_2D, e, v, f, g, m);
          r.generateMipmaps = !1;
        } else
          w
            ? (E && n.texStorage2D(t.TEXTURE_2D, A, v, i.width, i.height),
              n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f, g, i))
            : n.texImage2D(t.TEXTURE_2D, 0, v, f, g, i);
        M(r, p) && S(l), (d.__version = u.version), r.onUpdate && r.onUpdate(r);
      }
      e.__version = r.version;
    }
    function F(e, r, a, o, l, c) {
      const h = s.convert(a.format, a.colorSpace),
        u = s.convert(a.type),
        p = b(a.internalFormat, h, u, a.colorSpace);
      if (!i.get(r).__hasExternalTextures) {
        const e = Math.max(1, r.width >> c),
          i = Math.max(1, r.height >> c);
        l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY
          ? n.texImage3D(l, c, p, e, i, r.depth, 0, h, u, null)
          : n.texImage2D(l, c, p, e, i, 0, h, u, null);
      }
      n.bindFramebuffer(t.FRAMEBUFFER, e),
        H(r)
          ? d.framebufferTexture2DMultisampleEXT(
              t.FRAMEBUFFER,
              o,
              l,
              i.get(a).__webglTexture,
              0,
              k(r),
            )
          : (l === t.TEXTURE_2D ||
              (l >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
                l <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
            t.framebufferTexture2D(
              t.FRAMEBUFFER,
              o,
              l,
              i.get(a).__webglTexture,
              c,
            ),
        n.bindFramebuffer(t.FRAMEBUFFER, null);
    }
    function B(e, n, i) {
      if (
        (t.bindRenderbuffer(t.RENDERBUFFER, e),
        n.depthBuffer && !n.stencilBuffer)
      ) {
        let r = t.DEPTH_COMPONENT16;
        if (i || H(n)) {
          const e = n.depthTexture;
          e &&
            e.isDepthTexture &&
            (e.type === Ft
              ? (r = t.DEPTH_COMPONENT32F)
              : e.type === Dt && (r = t.DEPTH_COMPONENT24));
          const i = k(n);
          H(n)
            ? d.renderbufferStorageMultisampleEXT(
                t.RENDERBUFFER,
                i,
                r,
                n.width,
                n.height,
              )
            : t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                i,
                r,
                n.width,
                n.height,
              );
        } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_ATTACHMENT,
          t.RENDERBUFFER,
          e,
        );
      } else if (n.depthBuffer && n.stencilBuffer) {
        const r = k(n);
        i && !1 === H(n)
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              r,
              t.DEPTH24_STENCIL8,
              n.width,
              n.height,
            )
          : H(n)
          ? d.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              r,
              t.DEPTH24_STENCIL8,
              n.width,
              n.height,
            )
          : t.renderbufferStorage(
              t.RENDERBUFFER,
              t.DEPTH_STENCIL,
              n.width,
              n.height,
            ),
          t.framebufferRenderbuffer(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.RENDERBUFFER,
            e,
          );
      } else {
        const e =
          !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
        for (let r = 0; r < e.length; r++) {
          const a = e[r],
            o = s.convert(a.format, a.colorSpace),
            l = s.convert(a.type),
            c = b(a.internalFormat, o, l, a.colorSpace),
            h = k(n);
          i && !1 === H(n)
            ? t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                h,
                c,
                n.width,
                n.height,
              )
            : H(n)
            ? d.renderbufferStorageMultisampleEXT(
                t.RENDERBUFFER,
                h,
                c,
                n.width,
                n.height,
              )
            : t.renderbufferStorage(t.RENDERBUFFER, c, n.width, n.height);
        }
      }
      t.bindRenderbuffer(t.RENDERBUFFER, null);
    }
    function z(e) {
      const r = i.get(e),
        s = !0 === e.isWebGLCubeRenderTarget;
      if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
        if (s)
          throw new Error(
            "target.depthTexture not supported in Cube render targets",
          );
        !(function (e, r) {
          if (r && r.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported",
            );
          if (
            (n.bindFramebuffer(t.FRAMEBUFFER, e),
            !r.depthTexture || !r.depthTexture.isDepthTexture)
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
            );
          (i.get(r.depthTexture).__webglTexture &&
            r.depthTexture.image.width === r.width &&
            r.depthTexture.image.height === r.height) ||
            ((r.depthTexture.image.width = r.width),
            (r.depthTexture.image.height = r.height),
            (r.depthTexture.needsUpdate = !0)),
            L(r.depthTexture, 0);
          const s = i.get(r.depthTexture).__webglTexture,
            a = k(r);
          if (r.depthTexture.format === Vt)
            H(r)
              ? d.framebufferTexture2DMultisampleEXT(
                  t.FRAMEBUFFER,
                  t.DEPTH_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0,
                  a,
                )
              : t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  t.DEPTH_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0,
                );
          else {
            if (r.depthTexture.format !== Wt)
              throw new Error("Unknown depthTexture format");
            H(r)
              ? d.framebufferTexture2DMultisampleEXT(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0,
                  a,
                )
              : t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0,
                );
          }
        })(r.__webglFramebuffer, e);
      } else if (s) {
        r.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++)
          n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
            (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
            B(r.__webglDepthbuffer[i], e, !1);
      } else
        n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
          (r.__webglDepthbuffer = t.createRenderbuffer()),
          B(r.__webglDepthbuffer, e, !1);
      n.bindFramebuffer(t.FRAMEBUFFER, null);
    }
    function k(t) {
      return Math.min(u, t.samples);
    }
    function H(t) {
      const n = i.get(t);
      return (
        o &&
        t.samples > 0 &&
        !0 === e.has("WEBGL_multisampled_render_to_texture") &&
        !1 !== n.__useRenderToTexture
      );
    }
    function G(t, n) {
      const i = t.colorSpace,
        r = t.format,
        s = t.type;
      return (
        !0 === t.isCompressedTexture ||
          t.format === ke ||
          (i !== Oe &&
            i !== Ue &&
            (i === Ne
              ? !1 === o
                ? !0 === e.has("EXT_sRGB") && r === Gt
                  ? ((t.format = ke),
                    (t.minFilter = Lt),
                    (t.generateMipmaps = !1))
                  : (n = Sn.sRGBToLinear(n))
                : (r === Gt && s === Ut) ||
                  console.warn(
                    "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
                  )
              : console.error(
                  "THREE.WebGLTextures: Unsupported texture color space:",
                  i,
                ))),
        n
      );
    }
    (this.allocateTextureUnit = function () {
      const t = C;
      return (
        t >= l &&
          console.warn(
            "THREE.WebGLTextures: Trying to use " +
              t +
              " texture units while this GPU supports only " +
              l,
          ),
        (C += 1),
        t
      );
    }),
      (this.resetTextureUnits = function () {
        C = 0;
      }),
      (this.setTexture2D = L),
      (this.setTexture2DArray = function (e, r) {
        const s = i.get(e);
        e.version > 0 && s.__version !== e.version
          ? D(s, e, r)
          : n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r);
      }),
      (this.setTexture3D = function (e, r) {
        const s = i.get(e);
        e.version > 0 && s.__version !== e.version
          ? D(s, e, r)
          : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r);
      }),
      (this.setTextureCube = function (e, r) {
        const a = i.get(e);
        e.version > 0 && a.__version !== e.version
          ? (function (e, r, a) {
              if (6 !== r.image.length) return;
              const l = O(e, r),
                h = r.source;
              n.bindTexture(
                t.TEXTURE_CUBE_MAP,
                e.__webglTexture,
                t.TEXTURE0 + a,
              );
              const u = i.get(h);
              if (h.version !== u.__version || !0 === l) {
                n.activeTexture(t.TEXTURE0 + a),
                  t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                  t.pixelStorei(
                    t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    r.premultiplyAlpha,
                  ),
                  t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
                  t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                const e =
                    r.isCompressedTexture || r.image[0].isCompressedTexture,
                  i = r.image[0] && r.image[0].isDataTexture,
                  d = [];
                for (let t = 0; t < 6; t++)
                  (d[t] =
                    e || i
                      ? i
                        ? r.image[t].image
                        : r.image[t]
                      : y(r.image[t], !1, !0, c)),
                    (d[t] = G(r, d[t]));
                const p = d[0],
                  f = x(p) || o,
                  m = s.convert(r.format, r.colorSpace),
                  g = s.convert(r.type),
                  v = b(r.internalFormat, m, g, r.colorSpace),
                  _ = o && !0 !== r.isVideoTexture,
                  w = void 0 === u.__version || !0 === l;
                let E,
                  A = T(r, p, f);
                if ((N(t.TEXTURE_CUBE_MAP, r, f), e)) {
                  _ &&
                    w &&
                    n.texStorage2D(t.TEXTURE_CUBE_MAP, A, v, p.width, p.height);
                  for (let e = 0; e < 6; e++) {
                    E = d[e].mipmaps;
                    for (let i = 0; i < E.length; i++) {
                      const s = E[i];
                      r.format !== Gt
                        ? null !== m
                          ? _
                            ? n.compressedTexSubImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i,
                                0,
                                0,
                                s.width,
                                s.height,
                                m,
                                s.data,
                              )
                            : n.compressedTexImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i,
                                v,
                                s.width,
                                s.height,
                                0,
                                s.data,
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                            )
                        : _
                        ? n.texSubImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            i,
                            0,
                            0,
                            s.width,
                            s.height,
                            m,
                            g,
                            s.data,
                          )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            i,
                            v,
                            s.width,
                            s.height,
                            0,
                            m,
                            g,
                            s.data,
                          );
                    }
                  }
                } else {
                  (E = r.mipmaps),
                    _ &&
                      w &&
                      (E.length > 0 && A++,
                      n.texStorage2D(
                        t.TEXTURE_CUBE_MAP,
                        A,
                        v,
                        d[0].width,
                        d[0].height,
                      ));
                  for (let e = 0; e < 6; e++)
                    if (i) {
                      _
                        ? n.texSubImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            0,
                            0,
                            d[e].width,
                            d[e].height,
                            m,
                            g,
                            d[e].data,
                          )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            v,
                            d[e].width,
                            d[e].height,
                            0,
                            m,
                            g,
                            d[e].data,
                          );
                      for (let i = 0; i < E.length; i++) {
                        const r = E[i].image[e].image;
                        _
                          ? n.texSubImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              0,
                              0,
                              r.width,
                              r.height,
                              m,
                              g,
                              r.data,
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              v,
                              r.width,
                              r.height,
                              0,
                              m,
                              g,
                              r.data,
                            );
                      }
                    } else {
                      _
                        ? n.texSubImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            0,
                            0,
                            m,
                            g,
                            d[e],
                          )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            v,
                            m,
                            g,
                            d[e],
                          );
                      for (let i = 0; i < E.length; i++) {
                        const r = E[i];
                        _
                          ? n.texSubImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              0,
                              0,
                              m,
                              g,
                              r.image[e],
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              v,
                              m,
                              g,
                              r.image[e],
                            );
                      }
                    }
                }
                M(r, f) && S(t.TEXTURE_CUBE_MAP),
                  (u.__version = h.version),
                  r.onUpdate && r.onUpdate(r);
              }
              e.__version = r.version;
            })(a, e, r)
          : n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture, t.TEXTURE0 + r);
      }),
      (this.rebindTextures = function (e, n, r) {
        const s = i.get(e);
        void 0 !== n &&
          F(
            s.__webglFramebuffer,
            e,
            e.texture,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_2D,
            0,
          ),
          void 0 !== r && z(e);
      }),
      (this.setupRenderTarget = function (e) {
        const l = e.texture,
          c = i.get(e),
          h = i.get(l);
        e.addEventListener("dispose", A),
          !0 !== e.isWebGLMultipleRenderTargets &&
            (void 0 === h.__webglTexture &&
              (h.__webglTexture = t.createTexture()),
            (h.__version = l.version),
            a.memory.textures++);
        const u = !0 === e.isWebGLCubeRenderTarget,
          d = !0 === e.isWebGLMultipleRenderTargets,
          p = x(e) || o;
        if (u) {
          c.__webglFramebuffer = [];
          for (let e = 0; e < 6; e++)
            if (o && l.mipmaps && l.mipmaps.length > 0) {
              c.__webglFramebuffer[e] = [];
              for (let n = 0; n < l.mipmaps.length; n++)
                c.__webglFramebuffer[e][n] = t.createFramebuffer();
            } else c.__webglFramebuffer[e] = t.createFramebuffer();
        } else {
          if (o && l.mipmaps && l.mipmaps.length > 0) {
            c.__webglFramebuffer = [];
            for (let e = 0; e < l.mipmaps.length; e++)
              c.__webglFramebuffer[e] = t.createFramebuffer();
          } else c.__webglFramebuffer = t.createFramebuffer();
          if (d)
            if (r.drawBuffers) {
              const n = e.texture;
              for (let e = 0, r = n.length; e < r; e++) {
                const r = i.get(n[e]);
                void 0 === r.__webglTexture &&
                  ((r.__webglTexture = t.createTexture()), a.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.",
              );
          if (o && e.samples > 0 && !1 === H(e)) {
            const i = d ? l : [l];
            (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
              (c.__webglColorRenderbuffer = []),
              n.bindFramebuffer(
                t.FRAMEBUFFER,
                c.__webglMultisampledFramebuffer,
              );
            for (let n = 0; n < i.length; n++) {
              const r = i[n];
              (c.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
                t.bindRenderbuffer(
                  t.RENDERBUFFER,
                  c.__webglColorRenderbuffer[n],
                );
              const a = s.convert(r.format, r.colorSpace),
                o = s.convert(r.type),
                l = b(
                  r.internalFormat,
                  a,
                  o,
                  r.colorSpace,
                  !0 === e.isXRRenderTarget,
                ),
                h = k(e);
              t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                h,
                l,
                e.width,
                e.height,
              ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + n,
                  t.RENDERBUFFER,
                  c.__webglColorRenderbuffer[n],
                );
            }
            t.bindRenderbuffer(t.RENDERBUFFER, null),
              e.depthBuffer &&
                ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                B(c.__webglDepthRenderbuffer, e, !0)),
              n.bindFramebuffer(t.FRAMEBUFFER, null);
          }
        }
        if (u) {
          n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture),
            N(t.TEXTURE_CUBE_MAP, l, p);
          for (let n = 0; n < 6; n++)
            if (o && l.mipmaps && l.mipmaps.length > 0)
              for (let i = 0; i < l.mipmaps.length; i++)
                F(
                  c.__webglFramebuffer[n][i],
                  e,
                  l,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                  i,
                );
            else
              F(
                c.__webglFramebuffer[n],
                e,
                l,
                t.COLOR_ATTACHMENT0,
                t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                0,
              );
          M(l, p) && S(t.TEXTURE_CUBE_MAP), n.unbindTexture();
        } else if (d) {
          const r = e.texture;
          for (let s = 0, a = r.length; s < a; s++) {
            const a = r[s],
              o = i.get(a);
            n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
              N(t.TEXTURE_2D, a, p),
              F(
                c.__webglFramebuffer,
                e,
                a,
                t.COLOR_ATTACHMENT0 + s,
                t.TEXTURE_2D,
                0,
              ),
              M(a, p) && S(t.TEXTURE_2D);
          }
          n.unbindTexture();
        } else {
          let i = t.TEXTURE_2D;
          if (
            ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
              (o
                ? (i = e.isWebGL3DRenderTarget
                    ? t.TEXTURE_3D
                    : t.TEXTURE_2D_ARRAY)
                : console.error(
                    "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.",
                  )),
            n.bindTexture(i, h.__webglTexture),
            N(i, l, p),
            o && l.mipmaps && l.mipmaps.length > 0)
          )
            for (let n = 0; n < l.mipmaps.length; n++)
              F(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
          else F(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
          M(l, p) && S(i), n.unbindTexture();
        }
        e.depthBuffer && z(e);
      }),
      (this.updateRenderTargetMipmap = function (e) {
        const r = x(e) || o,
          s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
        for (let a = 0, o = s.length; a < o; a++) {
          const o = s[a];
          if (M(o, r)) {
            const r = e.isWebGLCubeRenderTarget
                ? t.TEXTURE_CUBE_MAP
                : t.TEXTURE_2D,
              s = i.get(o).__webglTexture;
            n.bindTexture(r, s), S(r), n.unbindTexture();
          }
        }
      }),
      (this.updateMultisampleRenderTarget = function (e) {
        if (o && e.samples > 0 && !1 === H(e)) {
          const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
            s = e.width,
            a = e.height;
          let o = t.COLOR_BUFFER_BIT;
          const l = [],
            c = e.stencilBuffer
              ? t.DEPTH_STENCIL_ATTACHMENT
              : t.DEPTH_ATTACHMENT,
            h = i.get(e),
            u = !0 === e.isWebGLMultipleRenderTargets;
          if (u)
            for (let e = 0; e < r.length; e++)
              n.bindFramebuffer(
                t.FRAMEBUFFER,
                h.__webglMultisampledFramebuffer,
              ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + e,
                  t.RENDERBUFFER,
                  null,
                ),
                n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer),
                t.framebufferTexture2D(
                  t.DRAW_FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + e,
                  t.TEXTURE_2D,
                  null,
                  0,
                );
          n.bindFramebuffer(
            t.READ_FRAMEBUFFER,
            h.__webglMultisampledFramebuffer,
          ),
            n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
          for (let n = 0; n < r.length; n++) {
            l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(c);
            const d = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
            if (
              (!1 === d &&
                (e.depthBuffer && (o |= t.DEPTH_BUFFER_BIT),
                e.stencilBuffer && (o |= t.STENCIL_BUFFER_BIT)),
              u &&
                t.framebufferRenderbuffer(
                  t.READ_FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0,
                  t.RENDERBUFFER,
                  h.__webglColorRenderbuffer[n],
                ),
              !0 === d &&
                (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [c]),
                t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [c])),
              u)
            ) {
              const e = i.get(r[n]).__webglTexture;
              t.framebufferTexture2D(
                t.DRAW_FRAMEBUFFER,
                t.COLOR_ATTACHMENT0,
                t.TEXTURE_2D,
                e,
                0,
              );
            }
            t.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, t.NEAREST),
              p && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l);
          }
          if (
            (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
            n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
            u)
          )
            for (let e = 0; e < r.length; e++) {
              n.bindFramebuffer(
                t.FRAMEBUFFER,
                h.__webglMultisampledFramebuffer,
              ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + e,
                  t.RENDERBUFFER,
                  h.__webglColorRenderbuffer[e],
                );
              const s = i.get(r[e]).__webglTexture;
              n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer),
                t.framebufferTexture2D(
                  t.DRAW_FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + e,
                  t.TEXTURE_2D,
                  s,
                  0,
                );
            }
          n.bindFramebuffer(
            t.DRAW_FRAMEBUFFER,
            h.__webglMultisampledFramebuffer,
          );
        }
      }),
      (this.setupDepthRenderbuffer = z),
      (this.setupFrameBufferTexture = F),
      (this.useMultisampledRTT = H);
  }
  function Io(t, e, n) {
    const i = n.isWebGL2;
    return {
      convert: function (n, r = "") {
        let s;
        if (n === Ut) return t.UNSIGNED_BYTE;
        if (n === zt) return t.UNSIGNED_SHORT_4_4_4_4;
        if (n === kt) return t.UNSIGNED_SHORT_5_5_5_1;
        if (1010 === n) return t.BYTE;
        if (1011 === n) return t.SHORT;
        if (n === Nt) return t.UNSIGNED_SHORT;
        if (n === Ot) return t.INT;
        if (n === Dt) return t.UNSIGNED_INT;
        if (n === Ft) return t.FLOAT;
        if (n === Bt)
          return i
            ? t.HALF_FLOAT
            : ((s = e.get("OES_texture_half_float")),
              null !== s ? s.HALF_FLOAT_OES : null);
        if (1021 === n) return t.ALPHA;
        if (n === Gt) return t.RGBA;
        if (1024 === n) return t.LUMINANCE;
        if (1025 === n) return t.LUMINANCE_ALPHA;
        if (n === Vt) return t.DEPTH_COMPONENT;
        if (n === Wt) return t.DEPTH_STENCIL;
        if (n === ke)
          return (s = e.get("EXT_sRGB")), null !== s ? s.SRGB_ALPHA_EXT : null;
        if (1028 === n) return t.RED;
        if (n === jt) return t.RED_INTEGER;
        if (1030 === n) return t.RG;
        if (n === Xt) return t.RG_INTEGER;
        if (n === qt) return t.RGBA_INTEGER;
        if (n === Yt || n === Kt || n === Zt || n === Jt)
          if (r === Ne) {
            if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), null === s))
              return null;
            if (n === Yt) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (n === Kt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (n === Zt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (n === Jt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            if (((s = e.get("WEBGL_compressed_texture_s3tc")), null === s))
              return null;
            if (n === Yt) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (n === Kt) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (n === Zt) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (n === Jt) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
        if (n === $t || n === Qt || n === te || n === ee) {
          if (((s = e.get("WEBGL_compressed_texture_pvrtc")), null === s))
            return null;
          if (n === $t) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (n === Qt) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (n === te) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (n === ee) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (36196 === n)
          return (
            (s = e.get("WEBGL_compressed_texture_etc1")),
            null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
          );
        if (n === ne || n === ie) {
          if (((s = e.get("WEBGL_compressed_texture_etc")), null === s))
            return null;
          if (n === ne)
            return r === Ne ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
          if (n === ie)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
              : s.COMPRESSED_RGBA8_ETC2_EAC;
        }
        if (
          n === re ||
          n === se ||
          n === ae ||
          n === oe ||
          n === le ||
          n === ce ||
          n === he ||
          n === ue ||
          n === de ||
          n === pe ||
          n === fe ||
          n === me ||
          n === ge ||
          n === ve
        ) {
          if (((s = e.get("WEBGL_compressed_texture_astc")), null === s))
            return null;
          if (n === re)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
              : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (n === se)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
              : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (n === ae)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
              : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (n === oe)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
              : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (n === le)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
              : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (n === ce)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
              : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (n === he)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
              : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (n === ue)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
              : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (n === de)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
              : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (n === pe)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
              : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (n === fe)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
              : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (n === me)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
              : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (n === ge)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
              : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (n === ve)
            return r === Ne
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
              : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
        }
        if (n === _e) {
          if (((s = e.get("EXT_texture_compression_bptc")), null === s))
            return null;
          if (n === _e)
            return r === Ne
              ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
              : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        }
        if (36283 === n || n === ye || n === xe || n === Me) {
          if (((s = e.get("EXT_texture_compression_rgtc")), null === s))
            return null;
          if (n === _e) return s.COMPRESSED_RED_RGTC1_EXT;
          if (n === ye) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
          if (n === xe) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
          if (n === Me) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        }
        return n === Ht
          ? i
            ? t.UNSIGNED_INT_24_8
            : ((s = e.get("WEBGL_depth_texture")),
              null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
          : void 0 !== t[n]
          ? t[n]
          : null;
      },
    };
  }
  class Po extends Yr {
    constructor(t = []) {
      super(), (this.isArrayCamera = !0), (this.cameras = t);
    }
  }
  class Uo extends Oi {
    constructor() {
      super(), (this.isGroup = !0), (this.type = "Group");
    }
  }
  const No = { type: "move" };
  class Oo {
    constructor() {
      (this._targetRay = null), (this._grip = null), (this._hand = null);
    }
    getHandSpace() {
      return (
        null === this._hand &&
          ((this._hand = new Uo()),
          (this._hand.matrixAutoUpdate = !1),
          (this._hand.visible = !1),
          (this._hand.joints = {}),
          (this._hand.inputState = { pinching: !1 })),
        this._hand
      );
    }
    getTargetRaySpace() {
      return (
        null === this._targetRay &&
          ((this._targetRay = new Uo()),
          (this._targetRay.matrixAutoUpdate = !1),
          (this._targetRay.visible = !1),
          (this._targetRay.hasLinearVelocity = !1),
          (this._targetRay.linearVelocity = new Nn()),
          (this._targetRay.hasAngularVelocity = !1),
          (this._targetRay.angularVelocity = new Nn())),
        this._targetRay
      );
    }
    getGripSpace() {
      return (
        null === this._grip &&
          ((this._grip = new Uo()),
          (this._grip.matrixAutoUpdate = !1),
          (this._grip.visible = !1),
          (this._grip.hasLinearVelocity = !1),
          (this._grip.linearVelocity = new Nn()),
          (this._grip.hasAngularVelocity = !1),
          (this._grip.angularVelocity = new Nn())),
        this._grip
      );
    }
    dispatchEvent(t) {
      return (
        null !== this._targetRay && this._targetRay.dispatchEvent(t),
        null !== this._grip && this._grip.dispatchEvent(t),
        null !== this._hand && this._hand.dispatchEvent(t),
        this
      );
    }
    connect(t) {
      if (t && t.hand) {
        const e = this._hand;
        if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
      }
      return this.dispatchEvent({ type: "connected", data: t }), this;
    }
    disconnect(t) {
      return (
        this.dispatchEvent({ type: "disconnected", data: t }),
        null !== this._targetRay && (this._targetRay.visible = !1),
        null !== this._grip && (this._grip.visible = !1),
        null !== this._hand && (this._hand.visible = !1),
        this
      );
    }
    update(t, e, n) {
      let i = null,
        r = null,
        s = null;
      const a = this._targetRay,
        o = this._grip,
        l = this._hand;
      if (t && "visible-blurred" !== e.session.visibilityState) {
        if (l && t.hand) {
          s = !0;
          for (const s of t.hand.values()) {
            const t = e.getJointPose(s, n),
              i = this._getHandJoint(l, s);
            null !== t &&
              (i.matrix.fromArray(t.transform.matrix),
              i.matrix.decompose(i.position, i.rotation, i.scale),
              (i.matrixWorldNeedsUpdate = !0),
              (i.jointRadius = t.radius)),
              (i.visible = null !== t);
          }
          const i = l.joints["index-finger-tip"],
            r = l.joints["thumb-tip"],
            a = i.position.distanceTo(r.position),
            o = 0.02,
            c = 0.005;
          l.inputState.pinching && a > o + c
            ? ((l.inputState.pinching = !1),
              this.dispatchEvent({
                type: "pinchend",
                handedness: t.handedness,
                target: this,
              }))
            : !l.inputState.pinching &&
              a <= o - c &&
              ((l.inputState.pinching = !0),
              this.dispatchEvent({
                type: "pinchstart",
                handedness: t.handedness,
                target: this,
              }));
        } else
          null !== o &&
            t.gripSpace &&
            ((r = e.getPose(t.gripSpace, n)),
            null !== r &&
              (o.matrix.fromArray(r.transform.matrix),
              o.matrix.decompose(o.position, o.rotation, o.scale),
              (o.matrixWorldNeedsUpdate = !0),
              r.linearVelocity
                ? ((o.hasLinearVelocity = !0),
                  o.linearVelocity.copy(r.linearVelocity))
                : (o.hasLinearVelocity = !1),
              r.angularVelocity
                ? ((o.hasAngularVelocity = !0),
                  o.angularVelocity.copy(r.angularVelocity))
                : (o.hasAngularVelocity = !1)));
        null !== a &&
          ((i = e.getPose(t.targetRaySpace, n)),
          null === i && null !== r && (i = r),
          null !== i &&
            (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            (a.matrixWorldNeedsUpdate = !0),
            i.linearVelocity
              ? ((a.hasLinearVelocity = !0),
                a.linearVelocity.copy(i.linearVelocity))
              : (a.hasLinearVelocity = !1),
            i.angularVelocity
              ? ((a.hasAngularVelocity = !0),
                a.angularVelocity.copy(i.angularVelocity))
              : (a.hasAngularVelocity = !1),
            this.dispatchEvent(No)));
      }
      return (
        null !== a && (a.visible = null !== i),
        null !== o && (o.visible = null !== r),
        null !== l && (l.visible = null !== s),
        this
      );
    }
    _getHandJoint(t, e) {
      if (void 0 === t.joints[e.jointName]) {
        const n = new Uo();
        (n.matrixAutoUpdate = !1),
          (n.visible = !1),
          (t.joints[e.jointName] = n),
          t.add(n);
      }
      return t.joints[e.jointName];
    }
  }
  class Do extends An {
    constructor(t, e, n, i, r, s, a, o, l, c) {
      if ((c = void 0 !== c ? c : Vt) !== Vt && c !== Wt)
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
        );
      void 0 === n && c === Vt && (n = Dt),
        void 0 === n && c === Wt && (n = Ht),
        super(null, i, r, s, a, o, c, n, l),
        (this.isDepthTexture = !0),
        (this.image = { width: t, height: e }),
        (this.magFilter = void 0 !== a ? a : At),
        (this.minFilter = void 0 !== o ? o : At),
        (this.flipY = !1),
        (this.generateMipmaps = !1),
        (this.compareFunction = null);
    }
    copy(t) {
      return super.copy(t), (this.compareFunction = t.compareFunction), this;
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        null !== this.compareFunction &&
          (e.compareFunction = this.compareFunction),
        e
      );
    }
  }
  class Fo extends Ve {
    constructor(t, e) {
      super();
      const n = this;
      let i = null,
        r = 1,
        s = null,
        a = "local-floor",
        o = 1,
        l = null,
        h = null,
        u = null,
        d = null,
        p = null,
        f = null;
      const m = e.getContextAttributes();
      let g = null,
        v = null;
      const _ = [],
        y = [],
        x = new Yr();
      x.layers.enable(1), (x.viewport = new Rn());
      const M = new Yr();
      M.layers.enable(2), (M.viewport = new Rn());
      const S = [x, M],
        b = new Po();
      b.layers.enable(1), b.layers.enable(2);
      let T = null,
        w = null;
      function E(t) {
        const e = y.indexOf(t.inputSource);
        if (-1 === e) return;
        const n = _[e];
        void 0 !== n &&
          (n.update(t.inputSource, t.frame, l || s),
          n.dispatchEvent({ type: t.type, data: t.inputSource }));
      }
      function A() {
        i.removeEventListener("select", E),
          i.removeEventListener("selectstart", E),
          i.removeEventListener("selectend", E),
          i.removeEventListener("squeeze", E),
          i.removeEventListener("squeezestart", E),
          i.removeEventListener("squeezeend", E),
          i.removeEventListener("end", A),
          i.removeEventListener("inputsourceschange", R);
        for (let t = 0; t < _.length; t++) {
          const e = y[t];
          null !== e && ((y[t] = null), _[t].disconnect(e));
        }
        (T = null),
          (w = null),
          t.setRenderTarget(g),
          (p = null),
          (d = null),
          (u = null),
          (i = null),
          (v = null),
          U.stop(),
          (n.isPresenting = !1),
          n.dispatchEvent({ type: "sessionend" });
      }
      function R(t) {
        for (let e = 0; e < t.removed.length; e++) {
          const n = t.removed[e],
            i = y.indexOf(n);
          i >= 0 && ((y[i] = null), _[i].disconnect(n));
        }
        for (let e = 0; e < t.added.length; e++) {
          const n = t.added[e];
          let i = y.indexOf(n);
          if (-1 === i) {
            for (let t = 0; t < _.length; t++) {
              if (t >= y.length) {
                y.push(n), (i = t);
                break;
              }
              if (null === y[t]) {
                (y[t] = n), (i = t);
                break;
              }
            }
            if (-1 === i) break;
          }
          const r = _[i];
          r && r.connect(n);
        }
      }
      (this.cameraAutoUpdate = !0),
        (this.enabled = !1),
        (this.isPresenting = !1),
        (this.getController = function (t) {
          let e = _[t];
          return (
            void 0 === e && ((e = new Oo()), (_[t] = e)), e.getTargetRaySpace()
          );
        }),
        (this.getControllerGrip = function (t) {
          let e = _[t];
          return void 0 === e && ((e = new Oo()), (_[t] = e)), e.getGripSpace();
        }),
        (this.getHand = function (t) {
          let e = _[t];
          return void 0 === e && ((e = new Oo()), (_[t] = e)), e.getHandSpace();
        }),
        (this.setFramebufferScaleFactor = function (t) {
          (r = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
              );
        }),
        (this.setReferenceSpaceType = function (t) {
          (a = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change reference space type while presenting.",
              );
        }),
        (this.getReferenceSpace = function () {
          return l || s;
        }),
        (this.setReferenceSpace = function (t) {
          l = t;
        }),
        (this.getBaseLayer = function () {
          return null !== d ? d : p;
        }),
        (this.getBinding = function () {
          return u;
        }),
        (this.getFrame = function () {
          return f;
        }),
        (this.getSession = function () {
          return i;
        }),
        (this.setSession = function (h) {
          return c(this, null, function* () {
            if (((i = h), null !== i)) {
              if (
                ((g = t.getRenderTarget()),
                i.addEventListener("select", E),
                i.addEventListener("selectstart", E),
                i.addEventListener("selectend", E),
                i.addEventListener("squeeze", E),
                i.addEventListener("squeezestart", E),
                i.addEventListener("squeezeend", E),
                i.addEventListener("end", A),
                i.addEventListener("inputsourceschange", R),
                !0 !== m.xrCompatible && (yield e.makeXRCompatible()),
                void 0 === i.renderState.layers ||
                  !1 === t.capabilities.isWebGL2)
              ) {
                const n = {
                  antialias: void 0 !== i.renderState.layers || m.antialias,
                  alpha: !0,
                  depth: m.depth,
                  stencil: m.stencil,
                  framebufferScaleFactor: r,
                };
                (p = new XRWebGLLayer(i, e, n)),
                  i.updateRenderState({ baseLayer: p }),
                  (v = new Ln(p.framebufferWidth, p.framebufferHeight, {
                    format: Gt,
                    type: Ut,
                    colorSpace: t.outputColorSpace,
                    stencilBuffer: m.stencil,
                  }));
              } else {
                let n = null,
                  s = null,
                  a = null;
                m.depth &&
                  ((a = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
                  (n = m.stencil ? Wt : Vt),
                  (s = m.stencil ? Ht : Dt));
                const o = {
                  colorFormat: e.RGBA8,
                  depthFormat: a,
                  scaleFactor: r,
                };
                (u = new XRWebGLBinding(i, e)),
                  (d = u.createProjectionLayer(o)),
                  i.updateRenderState({ layers: [d] }),
                  (v = new Ln(d.textureWidth, d.textureHeight, {
                    format: Gt,
                    type: Ut,
                    depthTexture: new Do(
                      d.textureWidth,
                      d.textureHeight,
                      s,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      n,
                    ),
                    stencilBuffer: m.stencil,
                    colorSpace: t.outputColorSpace,
                    samples: m.antialias ? 4 : 0,
                  }));
                t.properties.get(v).__ignoreDepthValues = d.ignoreDepthValues;
              }
              (v.isXRRenderTarget = !0),
                this.setFoveation(o),
                (l = null),
                (s = yield i.requestReferenceSpace(a)),
                U.setContext(i),
                U.start(),
                (n.isPresenting = !0),
                n.dispatchEvent({ type: "sessionstart" });
            }
          });
        }),
        (this.getEnvironmentBlendMode = function () {
          if (null !== i) return i.environmentBlendMode;
        });
      const C = new Nn(),
        L = new Nn();
      function I(t, e) {
        null === e
          ? t.matrixWorld.copy(t.matrix)
          : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
          t.matrixWorldInverse.copy(t.matrixWorld).invert();
      }
      (this.updateCamera = function (t) {
        if (null === i) return;
        (b.near = M.near = x.near = t.near),
          (b.far = M.far = x.far = t.far),
          (T === b.near && w === b.far) ||
            (i.updateRenderState({ depthNear: b.near, depthFar: b.far }),
            (T = b.near),
            (w = b.far));
        const e = t.parent,
          n = b.cameras;
        I(b, e);
        for (let i = 0; i < n.length; i++) I(n[i], e);
        2 === n.length
          ? (function (t, e, n) {
              C.setFromMatrixPosition(e.matrixWorld),
                L.setFromMatrixPosition(n.matrixWorld);
              const i = C.distanceTo(L),
                r = e.projectionMatrix.elements,
                s = n.projectionMatrix.elements,
                a = r[14] / (r[10] - 1),
                o = r[14] / (r[10] + 1),
                l = (r[9] + 1) / r[5],
                c = (r[9] - 1) / r[5],
                h = (r[8] - 1) / r[0],
                u = (s[8] + 1) / s[0],
                d = a * h,
                p = a * u,
                f = i / (-h + u),
                m = f * -h;
              e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                t.translateX(m),
                t.translateZ(f),
                t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
              const g = a + f,
                v = o + f,
                _ = d - m,
                y = p + (i - m),
                x = ((l * o) / v) * g,
                M = ((c * o) / v) * g;
              t.projectionMatrix.makePerspective(_, y, x, M, g, v),
                t.projectionMatrixInverse.copy(t.projectionMatrix).invert();
            })(b, x, M)
          : b.projectionMatrix.copy(x.projectionMatrix),
          (function (t, e, n) {
            null === n
              ? t.matrix.copy(e.matrixWorld)
              : (t.matrix.copy(n.matrixWorld),
                t.matrix.invert(),
                t.matrix.multiply(e.matrixWorld));
            t.matrix.decompose(t.position, t.quaternion, t.scale),
              t.updateMatrixWorld(!0);
            const i = t.children;
            for (let r = 0, s = i.length; r < s; r++)
              i[r].updateMatrixWorld(!0);
            t.projectionMatrix.copy(e.projectionMatrix),
              t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
              t.isPerspectiveCamera &&
                ((t.fov =
                  2 * qe * Math.atan(1 / t.projectionMatrix.elements[5])),
                (t.zoom = 1));
          })(t, b, e);
      }),
        (this.getCamera = function () {
          return b;
        }),
        (this.getFoveation = function () {
          if (null !== d || null !== p) return o;
        }),
        (this.setFoveation = function (t) {
          (o = t),
            null !== d && (d.fixedFoveation = t),
            null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = t);
        });
      let P = null;
      const U = new as();
      U.setAnimationLoop(function (e, i) {
        if (((h = i.getViewerPose(l || s)), (f = i), null !== h)) {
          const e = h.views;
          null !== p &&
            (t.setRenderTargetFramebuffer(v, p.framebuffer),
            t.setRenderTarget(v));
          let n = !1;
          e.length !== b.cameras.length && ((b.cameras.length = 0), (n = !0));
          for (let i = 0; i < e.length; i++) {
            const r = e[i];
            let s = null;
            if (null !== p) s = p.getViewport(r);
            else {
              const e = u.getViewSubImage(d, r);
              (s = e.viewport),
                0 === i &&
                  (t.setRenderTargetTextures(
                    v,
                    e.colorTexture,
                    d.ignoreDepthValues ? void 0 : e.depthStencilTexture,
                  ),
                  t.setRenderTarget(v));
            }
            let a = S[i];
            void 0 === a &&
              ((a = new Yr()),
              a.layers.enable(i),
              (a.viewport = new Rn()),
              (S[i] = a)),
              a.matrix.fromArray(r.transform.matrix),
              a.matrix.decompose(a.position, a.quaternion, a.scale),
              a.projectionMatrix.fromArray(r.projectionMatrix),
              a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
              a.viewport.set(s.x, s.y, s.width, s.height),
              0 === i &&
                (b.matrix.copy(a.matrix),
                b.matrix.decompose(b.position, b.quaternion, b.scale)),
              !0 === n && b.cameras.push(a);
          }
        }
        for (let t = 0; t < _.length; t++) {
          const e = y[t],
            n = _[t];
          null !== e && void 0 !== n && n.update(e, i, l || s);
        }
        P && P(e, i),
          i.detectedPlanes &&
            n.dispatchEvent({ type: "planesdetected", data: i }),
          (f = null);
      }),
        (this.setAnimationLoop = function (t) {
          P = t;
        }),
        (this.dispose = function () {});
    }
  }
  function Bo(t, e) {
    function n(t, e) {
      !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix);
    }
    function i(i, r) {
      (i.opacity.value = r.opacity),
        r.color && i.diffuse.value.copy(r.color),
        r.emissive &&
          i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
        r.map && ((i.map.value = r.map), n(r.map, i.mapTransform)),
        r.alphaMap &&
          ((i.alphaMap.value = r.alphaMap), n(r.alphaMap, i.alphaMapTransform)),
        r.bumpMap &&
          ((i.bumpMap.value = r.bumpMap),
          n(r.bumpMap, i.bumpMapTransform),
          (i.bumpScale.value = r.bumpScale),
          r.side === ot && (i.bumpScale.value *= -1)),
        r.normalMap &&
          ((i.normalMap.value = r.normalMap),
          n(r.normalMap, i.normalMapTransform),
          i.normalScale.value.copy(r.normalScale),
          r.side === ot && i.normalScale.value.negate()),
        r.displacementMap &&
          ((i.displacementMap.value = r.displacementMap),
          n(r.displacementMap, i.displacementMapTransform),
          (i.displacementScale.value = r.displacementScale),
          (i.displacementBias.value = r.displacementBias)),
        r.emissiveMap &&
          ((i.emissiveMap.value = r.emissiveMap),
          n(r.emissiveMap, i.emissiveMapTransform)),
        r.specularMap &&
          ((i.specularMap.value = r.specularMap),
          n(r.specularMap, i.specularMapTransform)),
        r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
      const s = e.get(r).envMap;
      if (
        (s &&
          ((i.envMap.value = s),
          (i.flipEnvMap.value =
            s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
          (i.reflectivity.value = r.reflectivity),
          (i.ior.value = r.ior),
          (i.refractionRatio.value = r.refractionRatio)),
        r.lightMap)
      ) {
        i.lightMap.value = r.lightMap;
        const e = !0 === t._useLegacyLights ? Math.PI : 1;
        (i.lightMapIntensity.value = r.lightMapIntensity * e),
          n(r.lightMap, i.lightMapTransform);
      }
      r.aoMap &&
        ((i.aoMap.value = r.aoMap),
        (i.aoMapIntensity.value = r.aoMapIntensity),
        n(r.aoMap, i.aoMapTransform));
    }
    return {
      refreshFogUniforms: function (e, n) {
        n.color.getRGB(e.fogColor.value, Wr(t)),
          n.isFog
            ? ((e.fogNear.value = n.near), (e.fogFar.value = n.far))
            : n.isFogExp2 && (e.fogDensity.value = n.density);
      },
      refreshMaterialUniforms: function (t, r, s, a, o) {
        r.isMeshBasicMaterial || r.isMeshLambertMaterial
          ? i(t, r)
          : r.isMeshToonMaterial
          ? (i(t, r),
            (function (t, e) {
              e.gradientMap && (t.gradientMap.value = e.gradientMap);
            })(t, r))
          : r.isMeshPhongMaterial
          ? (i(t, r),
            (function (t, e) {
              t.specular.value.copy(e.specular),
                (t.shininess.value = Math.max(e.shininess, 1e-4));
            })(t, r))
          : r.isMeshStandardMaterial
          ? (i(t, r),
            (function (t, i) {
              (t.metalness.value = i.metalness),
                i.metalnessMap &&
                  ((t.metalnessMap.value = i.metalnessMap),
                  n(i.metalnessMap, t.metalnessMapTransform));
              (t.roughness.value = i.roughness),
                i.roughnessMap &&
                  ((t.roughnessMap.value = i.roughnessMap),
                  n(i.roughnessMap, t.roughnessMapTransform));
              const r = e.get(i).envMap;
              r && (t.envMapIntensity.value = i.envMapIntensity);
            })(t, r),
            r.isMeshPhysicalMaterial &&
              (function (t, e, i) {
                (t.ior.value = e.ior),
                  e.sheen > 0 &&
                    (t.sheenColor.value
                      .copy(e.sheenColor)
                      .multiplyScalar(e.sheen),
                    (t.sheenRoughness.value = e.sheenRoughness),
                    e.sheenColorMap &&
                      ((t.sheenColorMap.value = e.sheenColorMap),
                      n(e.sheenColorMap, t.sheenColorMapTransform)),
                    e.sheenRoughnessMap &&
                      ((t.sheenRoughnessMap.value = e.sheenRoughnessMap),
                      n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform)));
                e.clearcoat > 0 &&
                  ((t.clearcoat.value = e.clearcoat),
                  (t.clearcoatRoughness.value = e.clearcoatRoughness),
                  e.clearcoatMap &&
                    ((t.clearcoatMap.value = e.clearcoatMap),
                    n(e.clearcoatMap, t.clearcoatMapTransform)),
                  e.clearcoatRoughnessMap &&
                    ((t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                    n(
                      e.clearcoatRoughnessMap,
                      t.clearcoatRoughnessMapTransform,
                    )),
                  e.clearcoatNormalMap &&
                    ((t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                    n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform),
                    t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                    e.side === ot && t.clearcoatNormalScale.value.negate()));
                e.iridescence > 0 &&
                  ((t.iridescence.value = e.iridescence),
                  (t.iridescenceIOR.value = e.iridescenceIOR),
                  (t.iridescenceThicknessMinimum.value =
                    e.iridescenceThicknessRange[0]),
                  (t.iridescenceThicknessMaximum.value =
                    e.iridescenceThicknessRange[1]),
                  e.iridescenceMap &&
                    ((t.iridescenceMap.value = e.iridescenceMap),
                    n(e.iridescenceMap, t.iridescenceMapTransform)),
                  e.iridescenceThicknessMap &&
                    ((t.iridescenceThicknessMap.value =
                      e.iridescenceThicknessMap),
                    n(
                      e.iridescenceThicknessMap,
                      t.iridescenceThicknessMapTransform,
                    )));
                e.transmission > 0 &&
                  ((t.transmission.value = e.transmission),
                  (t.transmissionSamplerMap.value = i.texture),
                  t.transmissionSamplerSize.value.set(i.width, i.height),
                  e.transmissionMap &&
                    ((t.transmissionMap.value = e.transmissionMap),
                    n(e.transmissionMap, t.transmissionMapTransform)),
                  (t.thickness.value = e.thickness),
                  e.thicknessMap &&
                    ((t.thicknessMap.value = e.thicknessMap),
                    n(e.thicknessMap, t.thicknessMapTransform)),
                  (t.attenuationDistance.value = e.attenuationDistance),
                  t.attenuationColor.value.copy(e.attenuationColor));
                e.anisotropy > 0 &&
                  (t.anisotropyVector.value.set(
                    e.anisotropy * Math.cos(e.anisotropyRotation),
                    e.anisotropy * Math.sin(e.anisotropyRotation),
                  ),
                  e.anisotropyMap &&
                    ((t.anisotropyMap.value = e.anisotropyMap),
                    n(e.anisotropyMap, t.anisotropyMapTransform)));
                (t.specularIntensity.value = e.specularIntensity),
                  t.specularColor.value.copy(e.specularColor),
                  e.specularColorMap &&
                    ((t.specularColorMap.value = e.specularColorMap),
                    n(e.specularColorMap, t.specularColorMapTransform));
                e.specularIntensityMap &&
                  ((t.specularIntensityMap.value = e.specularIntensityMap),
                  n(e.specularIntensityMap, t.specularIntensityMapTransform));
              })(t, r, o))
          : r.isMeshMatcapMaterial
          ? (i(t, r),
            (function (t, e) {
              e.matcap && (t.matcap.value = e.matcap);
            })(t, r))
          : r.isMeshDepthMaterial
          ? i(t, r)
          : r.isMeshDistanceMaterial
          ? (i(t, r),
            (function (t, n) {
              const i = e.get(n).light;
              t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                (t.nearDistance.value = i.shadow.camera.near),
                (t.farDistance.value = i.shadow.camera.far);
            })(t, r))
          : r.isMeshNormalMaterial
          ? i(t, r)
          : r.isLineBasicMaterial
          ? ((function (t, e) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                e.map && ((t.map.value = e.map), n(e.map, t.mapTransform));
            })(t, r),
            r.isLineDashedMaterial &&
              (function (t, e) {
                (t.dashSize.value = e.dashSize),
                  (t.totalSize.value = e.dashSize + e.gapSize),
                  (t.scale.value = e.scale);
              })(t, r))
          : r.isPointsMaterial
          ? (function (t, e, i, r) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                (t.size.value = e.size * i),
                (t.scale.value = 0.5 * r),
                e.map && ((t.map.value = e.map), n(e.map, t.uvTransform));
              e.alphaMap &&
                ((t.alphaMap.value = e.alphaMap),
                n(e.alphaMap, t.alphaMapTransform));
              e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
            })(t, r, s, a)
          : r.isSpriteMaterial
          ? (function (t, e) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                (t.rotation.value = e.rotation),
                e.map && ((t.map.value = e.map), n(e.map, t.mapTransform));
              e.alphaMap &&
                ((t.alphaMap.value = e.alphaMap),
                n(e.alphaMap, t.alphaMapTransform));
              e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
            })(t, r)
          : r.isShadowMaterial
          ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
          : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
      },
    };
  }
  function zo(t, e, n, i) {
    let r = {},
      s = {},
      a = [];
    const o = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function l(t, e, n) {
      const i = t.value;
      if (void 0 === n[e]) {
        if ("number" == typeof i) n[e] = i;
        else {
          const t = Array.isArray(i) ? i : [i],
            r = [];
          for (let e = 0; e < t.length; e++) r.push(t[e].clone());
          n[e] = r;
        }
        return !0;
      }
      if ("number" == typeof i) {
        if (n[e] !== i) return (n[e] = i), !0;
      } else {
        const t = Array.isArray(n[e]) ? n[e] : [n[e]],
          r = Array.isArray(i) ? i : [i];
        for (let e = 0; e < t.length; e++) {
          const n = t[e];
          if (!1 === n.equals(r[e])) return n.copy(r[e]), !0;
        }
      }
      return !1;
    }
    function c(t) {
      const e = { boundary: 0, storage: 0 };
      return (
        "number" == typeof t
          ? ((e.boundary = 4), (e.storage = 4))
          : t.isVector2
          ? ((e.boundary = 8), (e.storage = 8))
          : t.isVector3 || t.isColor
          ? ((e.boundary = 16), (e.storage = 12))
          : t.isVector4
          ? ((e.boundary = 16), (e.storage = 16))
          : t.isMatrix3
          ? ((e.boundary = 48), (e.storage = 48))
          : t.isMatrix4
          ? ((e.boundary = 64), (e.storage = 64))
          : t.isTexture
          ? console.warn(
              "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
            )
          : console.warn(
              "THREE.WebGLRenderer: Unsupported uniform value type.",
              t,
            ),
        e
      );
    }
    function h(e) {
      const n = e.target;
      n.removeEventListener("dispose", h);
      const i = a.indexOf(n.__bindingPointIndex);
      a.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id];
    }
    return {
      bind: function (t, e) {
        const n = e.program;
        i.uniformBlockBinding(t, n);
      },
      update: function (n, u) {
        let d = r[n.id];
        void 0 === d &&
          (!(function (t) {
            const e = t.uniforms;
            let n = 0;
            const i = 16;
            let r = 0;
            for (let s = 0, a = e.length; s < a; s++) {
              const t = e[s],
                a = { boundary: 0, storage: 0 },
                o = Array.isArray(t.value) ? t.value : [t.value];
              for (let e = 0, n = o.length; e < n; e++) {
                const t = c(o[e]);
                (a.boundary += t.boundary), (a.storage += t.storage);
              }
              if (
                ((t.__data = new Float32Array(
                  a.storage / Float32Array.BYTES_PER_ELEMENT,
                )),
                (t.__offset = n),
                s > 0)
              ) {
                r = n % i;
                0 !== r &&
                  i - r - a.boundary < 0 &&
                  ((n += i - r), (t.__offset = n));
              }
              n += a.storage;
            }
            (r = n % i), r > 0 && (n += i - r);
            (t.__size = n), (t.__cache = {});
          })(n),
          (d = (function (e) {
            const n = (function () {
              for (let t = 0; t < o; t++)
                if (-1 === a.indexOf(t)) return a.push(t), t;
              return (
                console.error(
                  "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
                ),
                0
              );
            })();
            e.__bindingPointIndex = n;
            const i = t.createBuffer(),
              r = e.__size,
              s = e.usage;
            return (
              t.bindBuffer(t.UNIFORM_BUFFER, i),
              t.bufferData(t.UNIFORM_BUFFER, r, s),
              t.bindBuffer(t.UNIFORM_BUFFER, null),
              t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
              i
            );
          })(n)),
          (r[n.id] = d),
          n.addEventListener("dispose", h));
        const p = u.program;
        i.updateUBOMapping(n, p);
        const f = e.render.frame;
        s[n.id] !== f &&
          (!(function (e) {
            const n = r[e.id],
              i = e.uniforms,
              s = e.__cache;
            t.bindBuffer(t.UNIFORM_BUFFER, n);
            for (let r = 0, a = i.length; r < a; r++) {
              const e = i[r];
              if (!0 === l(e, r, s)) {
                const n = e.__offset,
                  i = Array.isArray(e.value) ? e.value : [e.value];
                let r = 0;
                for (let s = 0; s < i.length; s++) {
                  const a = i[s],
                    o = c(a);
                  "number" == typeof a
                    ? ((e.__data[0] = a),
                      t.bufferSubData(t.UNIFORM_BUFFER, n + r, e.__data))
                    : a.isMatrix3
                    ? ((e.__data[0] = a.elements[0]),
                      (e.__data[1] = a.elements[1]),
                      (e.__data[2] = a.elements[2]),
                      (e.__data[3] = a.elements[0]),
                      (e.__data[4] = a.elements[3]),
                      (e.__data[5] = a.elements[4]),
                      (e.__data[6] = a.elements[5]),
                      (e.__data[7] = a.elements[0]),
                      (e.__data[8] = a.elements[6]),
                      (e.__data[9] = a.elements[7]),
                      (e.__data[10] = a.elements[8]),
                      (e.__data[11] = a.elements[0]))
                    : (a.toArray(e.__data, r),
                      (r += o.storage / Float32Array.BYTES_PER_ELEMENT));
                }
                t.bufferSubData(t.UNIFORM_BUFFER, n, e.__data);
              }
            }
            t.bindBuffer(t.UNIFORM_BUFFER, null);
          })(n),
          (s[n.id] = f));
      },
      dispose: function () {
        for (const e in r) t.deleteBuffer(r[e]);
        (a = []), (r = {}), (s = {});
      },
    };
  }
  function ko() {
    const t = un("canvas");
    return (t.style.display = "block"), t;
  }
  class Ho {
    constructor(t = {}) {
      const {
        canvas: e = ko(),
        context: n = null,
        depth: i = !0,
        stencil: r = !0,
        alpha: s = !1,
        antialias: a = !1,
        premultipliedAlpha: o = !0,
        preserveDrawingBuffer: l = !1,
        powerPreference: c = "default",
        failIfMajorPerformanceCaveat: h = !1,
      } = t;
      let u;
      (this.isWebGLRenderer = !0),
        (u = null !== n ? n.getContextAttributes().alpha : s);
      const d = new Uint32Array(4),
        p = new Int32Array(4);
      let f = null,
        m = null;
      const g = [],
        v = [];
      (this.domElement = e),
        (this.debug = { checkShaderErrors: !0, onShaderError: null }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.outputColorSpace = Ne),
        (this._useLegacyLights = !1),
        (this.toneMapping = dt),
        (this.toneMappingExposure = 1);
      const _ = this;
      let y = !1,
        x = 0,
        M = 0,
        S = null,
        b = -1,
        T = null;
      const w = new Rn(),
        E = new Rn();
      let A = null;
      const R = new tr(0);
      let C = 0,
        L = e.width,
        I = e.height,
        P = 1,
        U = null,
        N = null;
      const O = new Rn(0, 0, L, I),
        D = new Rn(0, 0, L, I);
      let F = !1;
      const B = new ss();
      let z = !1,
        k = !1,
        H = null;
      const G = new hi(),
        V = new sn(),
        W = new Nn(),
        j = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };
      function X() {
        return null === S ? P : 1;
      }
      let q,
        Y,
        K,
        Z,
        J,
        $,
        Q,
        et,
        nt,
        it,
        rt,
        st,
        lt,
        ct,
        ht,
        ut,
        pt,
        ft,
        mt,
        gt,
        vt,
        _t,
        yt,
        xt,
        Mt = n;
      function St(t, n) {
        for (let i = 0; i < t.length; i++) {
          const r = t[i],
            s = e.getContext(r, n);
          if (null !== s) return s;
        }
        return null;
      }
      try {
        const t = {
          alpha: !0,
          depth: i,
          stencil: r,
          antialias: a,
          premultipliedAlpha: o,
          preserveDrawingBuffer: l,
          powerPreference: c,
          failIfMajorPerformanceCaveat: h,
        };
        if (
          ("setAttribute" in e &&
            e.setAttribute("data-engine", `three.js r${tt}`),
          e.addEventListener("webglcontextlost", wt, !1),
          e.addEventListener("webglcontextrestored", Et, !1),
          e.addEventListener("webglcontextcreationerror", At, !1),
          null === Mt)
        ) {
          const e = ["webgl2", "webgl", "experimental-webgl"];
          if (
            (!0 === _.isWebGL1Renderer && e.shift(),
            (Mt = St(e, t)),
            null === Mt)
          )
            throw St(e)
              ? new Error(
                  "Error creating WebGL context with your selected attributes.",
                )
              : new Error("Error creating WebGL context.");
        }
        "undefined" != typeof WebGLRenderingContext &&
          Mt instanceof WebGLRenderingContext &&
          console.warn(
            "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.",
          ),
          void 0 === Mt.getShaderPrecisionFormat &&
            (Mt.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
      } catch ($t) {
        throw (console.error("THREE.WebGLRenderer: " + $t.message), $t);
      }
      function bt() {
        (q = new Os(Mt)),
          (Y = new gs(Mt, q, t)),
          q.init(Y),
          (_t = new Io(Mt, q, Y)),
          (K = new Co(Mt, q, Y)),
          (Z = new Bs(Mt)),
          (J = new mo()),
          ($ = new Lo(Mt, q, K, J, Y, _t, Z)),
          (Q = new _s(_)),
          (et = new Ns(_)),
          (nt = new os(Mt, Y)),
          (yt = new fs(Mt, q, nt, Y)),
          (it = new Ds(Mt, nt, Z, yt)),
          (rt = new Gs(Mt, it, nt, Z)),
          (mt = new Hs(Mt, Y, $)),
          (ut = new vs(J)),
          (st = new fo(_, Q, et, q, Y, yt, ut)),
          (lt = new Bo(_, J)),
          (ct = new yo()),
          (ht = new wo(q, Y)),
          (ft = new ps(_, Q, et, K, rt, u, o)),
          (pt = new Ro(_, rt, Y)),
          (xt = new zo(Mt, Z, Y, K)),
          (gt = new ms(Mt, q, Z, Y)),
          (vt = new Fs(Mt, q, Z, Y)),
          (Z.programs = st.programs),
          (_.capabilities = Y),
          (_.extensions = q),
          (_.properties = J),
          (_.renderLists = ct),
          (_.shadowMap = pt),
          (_.state = K),
          (_.info = Z);
      }
      bt();
      const Tt = new Fo(_, Mt);
      function wt(t) {
        t.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (y = !0);
      }
      function Et() {
        console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
        const t = Z.autoReset,
          e = pt.enabled,
          n = pt.autoUpdate,
          i = pt.needsUpdate,
          r = pt.type;
        bt(),
          (Z.autoReset = t),
          (pt.enabled = e),
          (pt.autoUpdate = n),
          (pt.needsUpdate = i),
          (pt.type = r);
      }
      function At(t) {
        console.error(
          "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
          t.statusMessage,
        );
      }
      function Rt(t) {
        const e = t.target;
        e.removeEventListener("dispose", Rt),
          (function (t) {
            (function (t) {
              const e = J.get(t).programs;
              void 0 !== e &&
                (e.forEach(function (t) {
                  st.releaseProgram(t);
                }),
                t.isShaderMaterial && st.releaseShaderCache(t));
            })(t),
              J.remove(t);
          })(e);
      }
      (this.xr = Tt),
        (this.getContext = function () {
          return Mt;
        }),
        (this.getContextAttributes = function () {
          return Mt.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const t = q.get("WEBGL_lose_context");
          t && t.loseContext();
        }),
        (this.forceContextRestore = function () {
          const t = q.get("WEBGL_lose_context");
          t && t.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return P;
        }),
        (this.setPixelRatio = function (t) {
          void 0 !== t && ((P = t), this.setSize(L, I, !1));
        }),
        (this.getSize = function (t) {
          return t.set(L, I);
        }),
        (this.setSize = function (t, n, i = !0) {
          Tt.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
              )
            : ((L = t),
              (I = n),
              (e.width = Math.floor(t * P)),
              (e.height = Math.floor(n * P)),
              !0 === i &&
                ((e.style.width = t + "px"), (e.style.height = n + "px")),
              this.setViewport(0, 0, t, n));
        }),
        (this.getDrawingBufferSize = function (t) {
          return t.set(L * P, I * P).floor();
        }),
        (this.setDrawingBufferSize = function (t, n, i) {
          (L = t),
            (I = n),
            (P = i),
            (e.width = Math.floor(t * i)),
            (e.height = Math.floor(n * i)),
            this.setViewport(0, 0, t, n);
        }),
        (this.getCurrentViewport = function (t) {
          return t.copy(w);
        }),
        (this.getViewport = function (t) {
          return t.copy(O);
        }),
        (this.setViewport = function (t, e, n, i) {
          t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i),
            K.viewport(w.copy(O).multiplyScalar(P).floor());
        }),
        (this.getScissor = function (t) {
          return t.copy(D);
        }),
        (this.setScissor = function (t, e, n, i) {
          t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, n, i),
            K.scissor(E.copy(D).multiplyScalar(P).floor());
        }),
        (this.getScissorTest = function () {
          return F;
        }),
        (this.setScissorTest = function (t) {
          K.setScissorTest((F = t));
        }),
        (this.setOpaqueSort = function (t) {
          U = t;
        }),
        (this.setTransparentSort = function (t) {
          N = t;
        }),
        (this.getClearColor = function (t) {
          return t.copy(ft.getClearColor());
        }),
        (this.setClearColor = function () {
          ft.setClearColor.apply(ft, arguments);
        }),
        (this.getClearAlpha = function () {
          return ft.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          ft.setClearAlpha.apply(ft, arguments);
        }),
        (this.clear = function (t = !0, e = !0, n = !0) {
          let i = 0;
          if (t) {
            let t = !1;
            if (null !== S) {
              const e = S.texture.format;
              t = e === qt || e === Xt || e === jt;
            }
            if (t) {
              const t = S.texture.type,
                e =
                  t === Ut ||
                  t === Dt ||
                  t === Nt ||
                  t === Ht ||
                  t === zt ||
                  t === kt,
                n = ft.getClearColor(),
                i = ft.getClearAlpha(),
                r = n.r,
                s = n.g,
                a = n.b;
              e
                ? ((d[0] = r),
                  (d[1] = s),
                  (d[2] = a),
                  (d[3] = i),
                  Mt.clearBufferuiv(Mt.COLOR, 0, d))
                : ((p[0] = r),
                  (p[1] = s),
                  (p[2] = a),
                  (p[3] = i),
                  Mt.clearBufferiv(Mt.COLOR, 0, p));
            } else i |= Mt.COLOR_BUFFER_BIT;
          }
          e && (i |= Mt.DEPTH_BUFFER_BIT),
            n && (i |= Mt.STENCIL_BUFFER_BIT),
            Mt.clear(i);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          e.removeEventListener("webglcontextlost", wt, !1),
            e.removeEventListener("webglcontextrestored", Et, !1),
            e.removeEventListener("webglcontextcreationerror", At, !1),
            ct.dispose(),
            ht.dispose(),
            J.dispose(),
            Q.dispose(),
            et.dispose(),
            rt.dispose(),
            yt.dispose(),
            xt.dispose(),
            st.dispose(),
            Tt.dispose(),
            Tt.removeEventListener("sessionstart", Lt),
            Tt.removeEventListener("sessionend", It),
            H && (H.dispose(), (H = null)),
            Ot.stop();
        }),
        (this.renderBufferDirect = function (t, e, n, i, r, s) {
          null === e && (e = j);
          const a = r.isMesh && r.matrixWorld.determinant() < 0,
            o = (function (t, e, n, i, r) {
              !0 !== e.isScene && (e = j);
              $.resetTextureUnits();
              const s = e.fog,
                a = i.isMeshStandardMaterial ? e.environment : null,
                o =
                  null === S
                    ? _.outputColorSpace
                    : !0 === S.isXRRenderTarget
                    ? S.texture.colorSpace
                    : Oe,
                l = (i.isMeshStandardMaterial ? et : Q).get(i.envMap || a),
                c =
                  !0 === i.vertexColors &&
                  !!n.attributes.color &&
                  4 === n.attributes.color.itemSize,
                h =
                  !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                u = !!n.morphAttributes.position,
                d = !!n.morphAttributes.normal,
                p = !!n.morphAttributes.color;
              let f = dt;
              i.toneMapped &&
                ((null !== S && !0 !== S.isXRRenderTarget) ||
                  (f = _.toneMapping));
              const g =
                  n.morphAttributes.position ||
                  n.morphAttributes.normal ||
                  n.morphAttributes.color,
                v = void 0 !== g ? g.length : 0,
                y = J.get(i),
                x = m.state.lights;
              if (!0 === z && (!0 === k || t !== T)) {
                const e = t === T && i.id === b;
                ut.setState(i, t, e);
              }
              let M = !1;
              i.version === y.__version
                ? (y.needsLights && y.lightsStateVersion !== x.state.version) ||
                  y.outputColorSpace !== o ||
                  (r.isInstancedMesh && !1 === y.instancing)
                  ? (M = !0)
                  : r.isInstancedMesh || !0 !== y.instancing
                  ? r.isSkinnedMesh && !1 === y.skinning
                    ? (M = !0)
                    : r.isSkinnedMesh || !0 !== y.skinning
                    ? (r.isInstancedMesh &&
                        !0 === y.instancingColor &&
                        null === r.instanceColor) ||
                      (r.isInstancedMesh &&
                        !1 === y.instancingColor &&
                        null !== r.instanceColor) ||
                      y.envMap !== l ||
                      (!0 === i.fog && y.fog !== s)
                      ? (M = !0)
                      : void 0 === y.numClippingPlanes ||
                        (y.numClippingPlanes === ut.numPlanes &&
                          y.numIntersection === ut.numIntersection)
                      ? (y.vertexAlphas !== c ||
                          y.vertexTangents !== h ||
                          y.morphTargets !== u ||
                          y.morphNormals !== d ||
                          y.morphColors !== p ||
                          y.toneMapping !== f ||
                          (!0 === Y.isWebGL2 && y.morphTargetsCount !== v)) &&
                        (M = !0)
                      : (M = !0)
                    : (M = !0)
                  : (M = !0)
                : ((M = !0), (y.__version = i.version));
              let w = y.currentProgram;
              !0 === M && (w = Zt(i, e, r));
              let E = !1,
                A = !1,
                R = !1;
              const C = w.getUniforms(),
                L = y.uniforms;
              K.useProgram(w.program) && ((E = !0), (A = !0), (R = !0));
              i.id !== b && ((b = i.id), (A = !0));
              if (E || T !== t) {
                if (
                  (C.setValue(Mt, "projectionMatrix", t.projectionMatrix),
                  Y.logarithmicDepthBuffer &&
                    C.setValue(
                      Mt,
                      "logDepthBufFC",
                      2 / (Math.log(t.far + 1) / Math.LN2),
                    ),
                  T !== t && ((T = t), (A = !0), (R = !0)),
                  i.isShaderMaterial ||
                    i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshStandardMaterial ||
                    i.envMap)
                ) {
                  const e = C.map.cameraPosition;
                  void 0 !== e &&
                    e.setValue(Mt, W.setFromMatrixPosition(t.matrixWorld));
                }
                (i.isMeshPhongMaterial ||
                  i.isMeshToonMaterial ||
                  i.isMeshLambertMaterial ||
                  i.isMeshBasicMaterial ||
                  i.isMeshStandardMaterial ||
                  i.isShaderMaterial) &&
                  C.setValue(
                    Mt,
                    "isOrthographic",
                    !0 === t.isOrthographicCamera,
                  ),
                  (i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshLambertMaterial ||
                    i.isMeshBasicMaterial ||
                    i.isMeshStandardMaterial ||
                    i.isShaderMaterial ||
                    i.isShadowMaterial ||
                    r.isSkinnedMesh) &&
                    C.setValue(Mt, "viewMatrix", t.matrixWorldInverse);
              }
              if (r.isSkinnedMesh) {
                C.setOptional(Mt, r, "bindMatrix"),
                  C.setOptional(Mt, r, "bindMatrixInverse");
                const t = r.skeleton;
                t &&
                  (Y.floatVertexTextures
                    ? (null === t.boneTexture && t.computeBoneTexture(),
                      C.setValue(Mt, "boneTexture", t.boneTexture, $),
                      C.setValue(Mt, "boneTextureSize", t.boneTextureSize))
                    : console.warn(
                        "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.",
                      ));
              }
              const U = n.morphAttributes;
              (void 0 !== U.position ||
                void 0 !== U.normal ||
                (void 0 !== U.color && !0 === Y.isWebGL2)) &&
                mt.update(r, n, w);
              (A || y.receiveShadow !== r.receiveShadow) &&
                ((y.receiveShadow = r.receiveShadow),
                C.setValue(Mt, "receiveShadow", r.receiveShadow));
              i.isMeshGouraudMaterial &&
                null !== i.envMap &&
                ((L.envMap.value = l),
                (L.flipEnvMap.value =
                  l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1));
              A &&
                (C.setValue(Mt, "toneMappingExposure", _.toneMappingExposure),
                y.needsLights &&
                  ((O = R),
                  ((N = L).ambientLightColor.needsUpdate = O),
                  (N.lightProbe.needsUpdate = O),
                  (N.directionalLights.needsUpdate = O),
                  (N.directionalLightShadows.needsUpdate = O),
                  (N.pointLights.needsUpdate = O),
                  (N.pointLightShadows.needsUpdate = O),
                  (N.spotLights.needsUpdate = O),
                  (N.spotLightShadows.needsUpdate = O),
                  (N.rectAreaLights.needsUpdate = O),
                  (N.hemisphereLights.needsUpdate = O)),
                s && !0 === i.fog && lt.refreshFogUniforms(L, s),
                lt.refreshMaterialUniforms(L, i, P, I, H),
                Xa.upload(Mt, y.uniformsList, L, $));
              var N, O;
              i.isShaderMaterial &&
                !0 === i.uniformsNeedUpdate &&
                (Xa.upload(Mt, y.uniformsList, L, $),
                (i.uniformsNeedUpdate = !1));
              i.isSpriteMaterial && C.setValue(Mt, "center", r.center);
              if (
                (C.setValue(Mt, "modelViewMatrix", r.modelViewMatrix),
                C.setValue(Mt, "normalMatrix", r.normalMatrix),
                C.setValue(Mt, "modelMatrix", r.matrixWorld),
                i.isShaderMaterial || i.isRawShaderMaterial)
              ) {
                const t = i.uniformsGroups;
                for (let e = 0, n = t.length; e < n; e++)
                  if (Y.isWebGL2) {
                    const n = t[e];
                    xt.update(n, w), xt.bind(n, w);
                  } else
                    console.warn(
                      "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.",
                    );
              }
              return w;
            })(t, e, n, i, r);
          K.setMaterial(i, a);
          let l = n.index,
            c = 1;
          if (!0 === i.wireframe) {
            if (((l = it.getWireframeAttribute(n)), void 0 === l)) return;
            c = 2;
          }
          const h = n.drawRange,
            u = n.attributes.position;
          let d = h.start * c,
            p = (h.start + h.count) * c;
          null !== s &&
            ((d = Math.max(d, s.start * c)),
            (p = Math.min(p, (s.start + s.count) * c))),
            null !== l
              ? ((d = Math.max(d, 0)), (p = Math.min(p, l.count)))
              : null != u && ((d = Math.max(d, 0)), (p = Math.min(p, u.count)));
          const f = p - d;
          if (f < 0 || f === 1 / 0) return;
          let g;
          yt.setup(r, i, o, n, l);
          let v = gt;
          if (
            (null !== l && ((g = nt.get(l)), (v = vt), v.setIndex(g)), r.isMesh)
          )
            !0 === i.wireframe
              ? (K.setLineWidth(i.wireframeLinewidth * X()),
                v.setMode(Mt.LINES))
              : v.setMode(Mt.TRIANGLES);
          else if (r.isLine) {
            let t = i.linewidth;
            void 0 === t && (t = 1),
              K.setLineWidth(t * X()),
              r.isLineSegments
                ? v.setMode(Mt.LINES)
                : r.isLineLoop
                ? v.setMode(Mt.LINE_LOOP)
                : v.setMode(Mt.LINE_STRIP);
          } else
            r.isPoints
              ? v.setMode(Mt.POINTS)
              : r.isSprite && v.setMode(Mt.TRIANGLES);
          if (r.isInstancedMesh) v.renderInstances(d, f, r.count);
          else if (n.isInstancedBufferGeometry) {
            const t =
                void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
              e = Math.min(n.instanceCount, t);
            v.renderInstances(d, f, e);
          } else v.render(d, f);
        }),
        (this.compile = function (t, e) {
          function n(t, e, n) {
            !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass
              ? ((t.side = ot),
                (t.needsUpdate = !0),
                Zt(t, e, n),
                (t.side = at),
                (t.needsUpdate = !0),
                Zt(t, e, n),
                (t.side = 2))
              : Zt(t, e, n);
          }
          (m = ht.get(t)),
            m.init(),
            v.push(m),
            t.traverseVisible(function (t) {
              t.isLight &&
                t.layers.test(e.layers) &&
                (m.pushLight(t), t.castShadow && m.pushShadow(t));
            }),
            m.setupLights(_._useLegacyLights),
            t.traverse(function (e) {
              const i = e.material;
              if (i)
                if (Array.isArray(i))
                  for (let r = 0; r < i.length; r++) {
                    n(i[r], t, e);
                  }
                else n(i, t, e);
            }),
            v.pop(),
            (m = null);
        });
      let Ct = null;
      function Lt() {
        Ot.stop();
      }
      function It() {
        Ot.start();
      }
      const Ot = new as();
      function Vt(t, e, n, i) {
        if (!1 === t.visible) return;
        if (t.layers.test(e.layers))
          if (t.isGroup) n = t.renderOrder;
          else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
          else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);
          else if (t.isSprite) {
            if (!t.frustumCulled || B.intersectsSprite(t)) {
              i && W.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
              const e = rt.update(t),
                r = t.material;
              r.visible && f.push(t, e, r, n, W.z, null);
            }
          } else if (
            (t.isMesh || t.isLine || t.isPoints) &&
            (!t.frustumCulled || B.intersectsObject(t))
          ) {
            const e = rt.update(t),
              r = t.material;
            if (
              (i &&
                (void 0 !== t.boundingSphere
                  ? (null === t.boundingSphere && t.computeBoundingSphere(),
                    W.copy(t.boundingSphere.center))
                  : (null === e.boundingSphere && e.computeBoundingSphere(),
                    W.copy(e.boundingSphere.center)),
                W.applyMatrix4(t.matrixWorld).applyMatrix4(G)),
              Array.isArray(r))
            ) {
              const i = e.groups;
              for (let s = 0, a = i.length; s < a; s++) {
                const a = i[s],
                  o = r[a.materialIndex];
                o && o.visible && f.push(t, e, o, n, W.z, a);
              }
            } else r.visible && f.push(t, e, r, n, W.z, null);
          }
        const r = t.children;
        for (let s = 0, a = r.length; s < a; s++) Vt(r[s], e, n, i);
      }
      function Wt(t, e, n, i) {
        const r = t.opaque,
          s = t.transmissive,
          a = t.transparent;
        m.setupLightsView(n),
          !0 === z && ut.setGlobalState(_.clippingPlanes, n),
          s.length > 0 &&
            (function (t, e, n, i) {
              const r = Y.isWebGL2;
              null === H &&
                (H = new Ln(1, 1, {
                  generateMipmaps: !0,
                  type: q.has("EXT_color_buffer_half_float") ? Bt : Ut,
                  minFilter: Pt,
                  samples: r ? 4 : 0,
                }));
              _.getDrawingBufferSize(V),
                r ? H.setSize(V.x, V.y) : H.setSize(tn(V.x), tn(V.y));
              const s = _.getRenderTarget();
              _.setRenderTarget(H),
                _.getClearColor(R),
                (C = _.getClearAlpha()),
                C < 1 && _.setClearColor(16777215, 0.5);
              _.clear();
              const a = _.toneMapping;
              (_.toneMapping = dt),
                Yt(t, n, i),
                $.updateMultisampleRenderTarget(H),
                $.updateRenderTargetMipmap(H);
              let o = !1;
              for (let l = 0, c = e.length; l < c; l++) {
                const t = e[l],
                  r = t.object,
                  s = t.geometry,
                  a = t.material,
                  c = t.group;
                if (2 === a.side && r.layers.test(i.layers)) {
                  const t = a.side;
                  (a.side = ot),
                    (a.needsUpdate = !0),
                    Kt(r, n, i, s, a, c),
                    (a.side = t),
                    (a.needsUpdate = !0),
                    (o = !0);
                }
              }
              !0 === o &&
                ($.updateMultisampleRenderTarget(H),
                $.updateRenderTargetMipmap(H));
              _.setRenderTarget(s), _.setClearColor(R, C), (_.toneMapping = a);
            })(r, s, e, n),
          i && K.viewport(w.copy(i)),
          r.length > 0 && Yt(r, e, n),
          s.length > 0 && Yt(s, e, n),
          a.length > 0 && Yt(a, e, n),
          K.buffers.depth.setTest(!0),
          K.buffers.depth.setMask(!0),
          K.buffers.color.setMask(!0),
          K.setPolygonOffset(!1);
      }
      function Yt(t, e, n) {
        const i = !0 === e.isScene ? e.overrideMaterial : null;
        for (let r = 0, s = t.length; r < s; r++) {
          const s = t[r],
            a = s.object,
            o = s.geometry,
            l = null === i ? s.material : i,
            c = s.group;
          a.layers.test(n.layers) && Kt(a, e, n, o, l, c);
        }
      }
      function Kt(t, e, n, i, r, s) {
        t.onBeforeRender(_, e, n, i, r, s),
          t.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            t.matrixWorld,
          ),
          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
          r.onBeforeRender(_, e, n, i, t, s),
          !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass
            ? ((r.side = ot),
              (r.needsUpdate = !0),
              _.renderBufferDirect(n, e, i, r, t, s),
              (r.side = at),
              (r.needsUpdate = !0),
              _.renderBufferDirect(n, e, i, r, t, s),
              (r.side = 2))
            : _.renderBufferDirect(n, e, i, r, t, s),
          t.onAfterRender(_, e, n, i, r, s);
      }
      function Zt(t, e, n) {
        !0 !== e.isScene && (e = j);
        const i = J.get(t),
          r = m.state.lights,
          s = m.state.shadowsArray,
          a = r.state.version,
          o = st.getParameters(t, r.state, s, e, n),
          l = st.getProgramCacheKey(o);
        let c = i.programs;
        (i.environment = t.isMeshStandardMaterial ? e.environment : null),
          (i.fog = e.fog),
          (i.envMap = (t.isMeshStandardMaterial ? et : Q).get(
            t.envMap || i.environment,
          )),
          void 0 === c &&
            (t.addEventListener("dispose", Rt),
            (c = new Map()),
            (i.programs = c));
        let h = c.get(l);
        if (void 0 !== h) {
          if (i.currentProgram === h && i.lightsStateVersion === a)
            return Jt(t, o), h;
        } else (o.uniforms = st.getUniforms(t)), t.onBuild(n, o, _), t.onBeforeCompile(o, _), (h = st.acquireProgram(o, l)), c.set(l, h), (i.uniforms = o.uniforms);
        const u = i.uniforms;
        ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
          (u.clippingPlanes = ut.uniform),
          Jt(t, o),
          (i.needsLights = (function (t) {
            return (
              t.isMeshLambertMaterial ||
              t.isMeshToonMaterial ||
              t.isMeshPhongMaterial ||
              t.isMeshStandardMaterial ||
              t.isShadowMaterial ||
              (t.isShaderMaterial && !0 === t.lights)
            );
          })(t)),
          (i.lightsStateVersion = a),
          i.needsLights &&
            ((u.ambientLightColor.value = r.state.ambient),
            (u.lightProbe.value = r.state.probe),
            (u.directionalLights.value = r.state.directional),
            (u.directionalLightShadows.value = r.state.directionalShadow),
            (u.spotLights.value = r.state.spot),
            (u.spotLightShadows.value = r.state.spotShadow),
            (u.rectAreaLights.value = r.state.rectArea),
            (u.ltc_1.value = r.state.rectAreaLTC1),
            (u.ltc_2.value = r.state.rectAreaLTC2),
            (u.pointLights.value = r.state.point),
            (u.pointLightShadows.value = r.state.pointShadow),
            (u.hemisphereLights.value = r.state.hemi),
            (u.directionalShadowMap.value = r.state.directionalShadowMap),
            (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
            (u.spotShadowMap.value = r.state.spotShadowMap),
            (u.spotLightMatrix.value = r.state.spotLightMatrix),
            (u.spotLightMap.value = r.state.spotLightMap),
            (u.pointShadowMap.value = r.state.pointShadowMap),
            (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
        const d = h.getUniforms(),
          p = Xa.seqWithValue(d.seq, u);
        return (i.currentProgram = h), (i.uniformsList = p), h;
      }
      function Jt(t, e) {
        const n = J.get(t);
        (n.outputColorSpace = e.outputColorSpace),
          (n.instancing = e.instancing),
          (n.instancingColor = e.instancingColor),
          (n.skinning = e.skinning),
          (n.morphTargets = e.morphTargets),
          (n.morphNormals = e.morphNormals),
          (n.morphColors = e.morphColors),
          (n.morphTargetsCount = e.morphTargetsCount),
          (n.numClippingPlanes = e.numClippingPlanes),
          (n.numIntersection = e.numClipIntersection),
          (n.vertexAlphas = e.vertexAlphas),
          (n.vertexTangents = e.vertexTangents),
          (n.toneMapping = e.toneMapping);
      }
      Ot.setAnimationLoop(function (t) {
        Ct && Ct(t);
      }),
        "undefined" != typeof self && Ot.setContext(self),
        (this.setAnimationLoop = function (t) {
          (Ct = t), Tt.setAnimationLoop(t), null === t ? Ot.stop() : Ot.start();
        }),
        Tt.addEventListener("sessionstart", Lt),
        Tt.addEventListener("sessionend", It),
        (this.render = function (t, e) {
          if (void 0 !== e && !0 !== e.isCamera)
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
            );
          if (!0 === y) return;
          !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
            null === e.parent &&
              !0 === e.matrixWorldAutoUpdate &&
              e.updateMatrixWorld(),
            !0 === Tt.enabled &&
              !0 === Tt.isPresenting &&
              (!0 === Tt.cameraAutoUpdate && Tt.updateCamera(e),
              (e = Tt.getCamera())),
            !0 === t.isScene && t.onBeforeRender(_, t, e, S),
            (m = ht.get(t, v.length)),
            m.init(),
            v.push(m),
            G.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            B.setFromProjectionMatrix(G),
            (k = this.localClippingEnabled),
            (z = ut.init(this.clippingPlanes, k)),
            (f = ct.get(t, g.length)),
            f.init(),
            g.push(f),
            Vt(t, e, 0, _.sortObjects),
            f.finish(),
            !0 === _.sortObjects && f.sort(U, N),
            this.info.render.frame++,
            !0 === z && ut.beginShadows();
          const n = m.state.shadowsArray;
          if (
            (pt.render(n, t, e),
            !0 === z && ut.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            ft.render(f, t),
            m.setupLights(_._useLegacyLights),
            e.isArrayCamera)
          ) {
            const n = e.cameras;
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              Wt(f, t, i, i.viewport);
            }
          } else Wt(f, t, e);
          null !== S &&
            ($.updateMultisampleRenderTarget(S), $.updateRenderTargetMipmap(S)),
            !0 === t.isScene && t.onAfterRender(_, t, e),
            yt.resetDefaultState(),
            (b = -1),
            (T = null),
            v.pop(),
            (m = v.length > 0 ? v[v.length - 1] : null),
            g.pop(),
            (f = g.length > 0 ? g[g.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return x;
        }),
        (this.getActiveMipmapLevel = function () {
          return M;
        }),
        (this.getRenderTarget = function () {
          return S;
        }),
        (this.setRenderTargetTextures = function (t, e, n) {
          (J.get(t.texture).__webglTexture = e),
            (J.get(t.depthTexture).__webglTexture = n);
          const i = J.get(t);
          (i.__hasExternalTextures = !0),
            i.__hasExternalTextures &&
              ((i.__autoAllocateDepthBuffer = void 0 === n),
              i.__autoAllocateDepthBuffer ||
                (!0 === q.has("WEBGL_multisampled_render_to_texture") &&
                  (console.warn(
                    "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided",
                  ),
                  (i.__useRenderToTexture = !1))));
        }),
        (this.setRenderTargetFramebuffer = function (t, e) {
          const n = J.get(t);
          (n.__webglFramebuffer = e),
            (n.__useDefaultFramebuffer = void 0 === e);
        }),
        (this.setRenderTarget = function (t, e = 0, n = 0) {
          (S = t), (x = e), (M = n);
          let i = !0,
            r = null,
            s = !1,
            a = !1;
          if (t) {
            const o = J.get(t);
            void 0 !== o.__useDefaultFramebuffer
              ? (K.bindFramebuffer(Mt.FRAMEBUFFER, null), (i = !1))
              : void 0 === o.__webglFramebuffer
              ? $.setupRenderTarget(t)
              : o.__hasExternalTextures &&
                $.rebindTextures(
                  t,
                  J.get(t.texture).__webglTexture,
                  J.get(t.depthTexture).__webglTexture,
                );
            const l = t.texture;
            (l.isData3DTexture ||
              l.isDataArrayTexture ||
              l.isCompressedArrayTexture) &&
              (a = !0);
            const c = J.get(t).__webglFramebuffer;
            t.isWebGLCubeRenderTarget
              ? ((r = Array.isArray(c[e]) ? c[e][n] : c[e]), (s = !0))
              : (r =
                  Y.isWebGL2 && t.samples > 0 && !1 === $.useMultisampledRTT(t)
                    ? J.get(t).__webglMultisampledFramebuffer
                    : Array.isArray(c)
                    ? c[n]
                    : c),
              w.copy(t.viewport),
              E.copy(t.scissor),
              (A = t.scissorTest);
          } else
            w.copy(O).multiplyScalar(P).floor(),
              E.copy(D).multiplyScalar(P).floor(),
              (A = F);
          if (
            (K.bindFramebuffer(Mt.FRAMEBUFFER, r) &&
              Y.drawBuffers &&
              i &&
              K.drawBuffers(t, r),
            K.viewport(w),
            K.scissor(E),
            K.setScissorTest(A),
            s)
          ) {
            const i = J.get(t.texture);
            Mt.framebufferTexture2D(
              Mt.FRAMEBUFFER,
              Mt.COLOR_ATTACHMENT0,
              Mt.TEXTURE_CUBE_MAP_POSITIVE_X + e,
              i.__webglTexture,
              n,
            );
          } else if (a) {
            const i = J.get(t.texture),
              r = e || 0;
            Mt.framebufferTextureLayer(
              Mt.FRAMEBUFFER,
              Mt.COLOR_ATTACHMENT0,
              i.__webglTexture,
              n || 0,
              r,
            );
          }
          b = -1;
        }),
        (this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
          if (!t || !t.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
            );
          let o = J.get(t).__webglFramebuffer;
          if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
            K.bindFramebuffer(Mt.FRAMEBUFFER, o);
            try {
              const a = t.texture,
                o = a.format,
                l = a.type;
              if (
                o !== Gt &&
                _t.convert(o) !==
                  Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_FORMAT)
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
                );
              const c =
                l === Bt &&
                (q.has("EXT_color_buffer_half_float") ||
                  (Y.isWebGL2 && q.has("EXT_color_buffer_float")));
              if (
                !(
                  l === Ut ||
                  _t.convert(l) ===
                    Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_TYPE) ||
                  (l === Ft &&
                    (Y.isWebGL2 ||
                      q.has("OES_texture_float") ||
                      q.has("WEBGL_color_buffer_float"))) ||
                  c
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
                );
              e >= 0 &&
                e <= t.width - i &&
                n >= 0 &&
                n <= t.height - r &&
                Mt.readPixels(e, n, i, r, _t.convert(o), _t.convert(l), s);
            } finally {
              const t = null !== S ? J.get(S).__webglFramebuffer : null;
              K.bindFramebuffer(Mt.FRAMEBUFFER, t);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (t, e, n = 0) {
          const i = Math.pow(2, -n),
            r = Math.floor(e.image.width * i),
            s = Math.floor(e.image.height * i);
          $.setTexture2D(e, 0),
            Mt.copyTexSubImage2D(Mt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s),
            K.unbindTexture();
        }),
        (this.copyTextureToTexture = function (t, e, n, i = 0) {
          const r = e.image.width,
            s = e.image.height,
            a = _t.convert(n.format),
            o = _t.convert(n.type);
          $.setTexture2D(n, 0),
            Mt.pixelStorei(Mt.UNPACK_FLIP_Y_WEBGL, n.flipY),
            Mt.pixelStorei(
              Mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              n.premultiplyAlpha,
            ),
            Mt.pixelStorei(Mt.UNPACK_ALIGNMENT, n.unpackAlignment),
            e.isDataTexture
              ? Mt.texSubImage2D(
                  Mt.TEXTURE_2D,
                  i,
                  t.x,
                  t.y,
                  r,
                  s,
                  a,
                  o,
                  e.image.data,
                )
              : e.isCompressedTexture
              ? Mt.compressedTexSubImage2D(
                  Mt.TEXTURE_2D,
                  i,
                  t.x,
                  t.y,
                  e.mipmaps[0].width,
                  e.mipmaps[0].height,
                  a,
                  e.mipmaps[0].data,
                )
              : Mt.texSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, a, o, e.image),
            0 === i && n.generateMipmaps && Mt.generateMipmap(Mt.TEXTURE_2D),
            K.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
          if (_.isWebGL1Renderer)
            return void console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.",
            );
          const s = t.max.x - t.min.x + 1,
            a = t.max.y - t.min.y + 1,
            o = t.max.z - t.min.z + 1,
            l = _t.convert(i.format),
            c = _t.convert(i.type);
          let h;
          if (i.isData3DTexture) $.setTexture3D(i, 0), (h = Mt.TEXTURE_3D);
          else {
            if (!i.isDataArrayTexture)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.",
              );
            $.setTexture2DArray(i, 0), (h = Mt.TEXTURE_2D_ARRAY);
          }
          Mt.pixelStorei(Mt.UNPACK_FLIP_Y_WEBGL, i.flipY),
            Mt.pixelStorei(
              Mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              i.premultiplyAlpha,
            ),
            Mt.pixelStorei(Mt.UNPACK_ALIGNMENT, i.unpackAlignment);
          const u = Mt.getParameter(Mt.UNPACK_ROW_LENGTH),
            d = Mt.getParameter(Mt.UNPACK_IMAGE_HEIGHT),
            p = Mt.getParameter(Mt.UNPACK_SKIP_PIXELS),
            f = Mt.getParameter(Mt.UNPACK_SKIP_ROWS),
            m = Mt.getParameter(Mt.UNPACK_SKIP_IMAGES),
            g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
          Mt.pixelStorei(Mt.UNPACK_ROW_LENGTH, g.width),
            Mt.pixelStorei(Mt.UNPACK_IMAGE_HEIGHT, g.height),
            Mt.pixelStorei(Mt.UNPACK_SKIP_PIXELS, t.min.x),
            Mt.pixelStorei(Mt.UNPACK_SKIP_ROWS, t.min.y),
            Mt.pixelStorei(Mt.UNPACK_SKIP_IMAGES, t.min.z),
            n.isDataTexture || n.isData3DTexture
              ? Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data)
              : n.isCompressedArrayTexture
              ? (console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.",
                ),
                Mt.compressedTexSubImage3D(
                  h,
                  r,
                  e.x,
                  e.y,
                  e.z,
                  s,
                  a,
                  o,
                  l,
                  g.data,
                ))
              : Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g),
            Mt.pixelStorei(Mt.UNPACK_ROW_LENGTH, u),
            Mt.pixelStorei(Mt.UNPACK_IMAGE_HEIGHT, d),
            Mt.pixelStorei(Mt.UNPACK_SKIP_PIXELS, p),
            Mt.pixelStorei(Mt.UNPACK_SKIP_ROWS, f),
            Mt.pixelStorei(Mt.UNPACK_SKIP_IMAGES, m),
            0 === r && i.generateMipmaps && Mt.generateMipmap(h),
            K.unbindTexture();
        }),
        (this.initTexture = function (t) {
          t.isCubeTexture
            ? $.setTextureCube(t, 0)
            : t.isData3DTexture
            ? $.setTexture3D(t, 0)
            : t.isDataArrayTexture || t.isCompressedArrayTexture
            ? $.setTexture2DArray(t, 0)
            : $.setTexture2D(t, 0),
            K.unbindTexture();
        }),
        (this.resetState = function () {
          (x = 0), (M = 0), (S = null), K.reset(), yt.reset();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this }),
          );
    }
    get coordinateSystem() {
      return He;
    }
    get physicallyCorrectLights() {
      return (
        console.warn(
          "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.",
        ),
        !this.useLegacyLights
      );
    }
    set physicallyCorrectLights(t) {
      console.warn(
        "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.",
      ),
        (this.useLegacyLights = !t);
    }
    get outputEncoding() {
      return (
        console.warn(
          "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.",
        ),
        this.outputColorSpace === Ne ? Pe : Ie
      );
    }
    set outputEncoding(t) {
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.",
      ),
        (this.outputColorSpace = t === Pe ? Ne : Oe);
    }
    get useLegacyLights() {
      return (
        console.warn(
          "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.",
        ),
        this._useLegacyLights
      );
    }
    set useLegacyLights(t) {
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.",
      ),
        (this._useLegacyLights = t);
    }
  }
  class Go extends Ho {}
  Go.prototype.isWebGL1Renderer = !0;
  class Vo {
    constructor(t, e = 25e-5) {
      (this.isFogExp2 = !0),
        (this.name = ""),
        (this.color = new tr(t)),
        (this.density = e);
    }
    clone() {
      return new Vo(this.color, this.density);
    }
    toJSON() {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density,
      };
    }
  }
  class Wo {
    constructor(t, e = 1, n = 1e3) {
      (this.isFog = !0),
        (this.name = ""),
        (this.color = new tr(t)),
        (this.near = e),
        (this.far = n);
    }
    clone() {
      return new Wo(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far,
      };
    }
  }
  class jo extends Oi {
    constructor() {
      super(),
        (this.isScene = !0),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.backgroundBlurriness = 0),
        (this.backgroundIntensity = 1),
        (this.overrideMaterial = null),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this }),
          );
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        null !== t.background && (this.background = t.background.clone()),
        null !== t.environment && (this.environment = t.environment.clone()),
        null !== t.fog && (this.fog = t.fog.clone()),
        (this.backgroundBlurriness = t.backgroundBlurriness),
        (this.backgroundIntensity = t.backgroundIntensity),
        null !== t.overrideMaterial &&
          (this.overrideMaterial = t.overrideMaterial.clone()),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        null !== this.fog && (e.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 &&
          (e.object.backgroundBlurriness = this.backgroundBlurriness),
        1 !== this.backgroundIntensity &&
          (e.object.backgroundIntensity = this.backgroundIntensity),
        e
      );
    }
  }
  class Xo {
    constructor(t, e) {
      (this.isInterleavedBuffer = !0),
        (this.array = t),
        (this.stride = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.usage = Be),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0),
        (this.uuid = Ye());
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    setUsage(t) {
      return (this.usage = t), this;
    }
    copy(t) {
      return (
        (this.array = new t.array.constructor(t.array)),
        (this.count = t.count),
        (this.stride = t.stride),
        (this.usage = t.usage),
        this
      );
    }
    copyAt(t, e, n) {
      (t *= this.stride), (n *= e.stride);
      for (let i = 0, r = this.stride; i < r; i++)
        this.array[t + i] = e.array[n + i];
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    clone(t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ye()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] =
            this.array.slice(0).buffer);
      const e = new this.array.constructor(
          t.arrayBuffers[this.array.buffer._uuid],
        ),
        n = new this.constructor(e, this.stride);
      return n.setUsage(this.usage), n;
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this;
    }
    toJSON(t) {
      return (
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ye()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
            new Uint32Array(this.array.buffer),
          )),
        {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride,
        }
      );
    }
  }
  const qo = new Nn();
  class Yo {
    constructor(t, e, n, i = !1) {
      (this.isInterleavedBufferAttribute = !0),
        (this.name = ""),
        (this.data = t),
        (this.itemSize = e),
        (this.offset = n),
        (this.normalized = i);
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(t) {
      this.data.needsUpdate = t;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.data.count; e < n; e++)
        qo.fromBufferAttribute(this, e),
          qo.applyMatrix4(t),
          this.setXYZ(e, qo.x, qo.y, qo.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++)
        qo.fromBufferAttribute(this, e),
          qo.applyNormalMatrix(t),
          this.setXYZ(e, qo.x, qo.y, qo.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++)
        qo.fromBufferAttribute(this, e),
          qo.transformDirection(t),
          this.setXYZ(e, qo.x, qo.y, qo.z);
      return this;
    }
    setX(t, e) {
      return (
        this.normalized && (e = nn(e, this.array)),
        (this.data.array[t * this.data.stride + this.offset] = e),
        this
      );
    }
    setY(t, e) {
      return (
        this.normalized && (e = nn(e, this.array)),
        (this.data.array[t * this.data.stride + this.offset + 1] = e),
        this
      );
    }
    setZ(t, e) {
      return (
        this.normalized && (e = nn(e, this.array)),
        (this.data.array[t * this.data.stride + this.offset + 2] = e),
        this
      );
    }
    setW(t, e) {
      return (
        this.normalized && (e = nn(e, this.array)),
        (this.data.array[t * this.data.stride + this.offset + 3] = e),
        this
      );
    }
    getX(t) {
      let e = this.data.array[t * this.data.stride + this.offset];
      return this.normalized && (e = en(e, this.array)), e;
    }
    getY(t) {
      let e = this.data.array[t * this.data.stride + this.offset + 1];
      return this.normalized && (e = en(e, this.array)), e;
    }
    getZ(t) {
      let e = this.data.array[t * this.data.stride + this.offset + 2];
      return this.normalized && (e = en(e, this.array)), e;
    }
    getW(t) {
      let e = this.data.array[t * this.data.stride + this.offset + 3];
      return this.normalized && (e = en(e, this.array)), e;
    }
    setXY(t, e, n) {
      return (
        (t = t * this.data.stride + this.offset),
        this.normalized && ((e = nn(e, this.array)), (n = nn(n, this.array))),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        this
      );
    }
    setXYZ(t, e, n, i) {
      return (
        (t = t * this.data.stride + this.offset),
        this.normalized &&
          ((e = nn(e, this.array)),
          (n = nn(n, this.array)),
          (i = nn(i, this.array))),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        (this.data.array[t + 2] = i),
        this
      );
    }
    setXYZW(t, e, n, i, r) {
      return (
        (t = t * this.data.stride + this.offset),
        this.normalized &&
          ((e = nn(e, this.array)),
          (n = nn(n, this.array)),
          (i = nn(i, this.array)),
          (r = nn(r, this.array))),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        (this.data.array[t + 2] = i),
        (this.data.array[t + 3] = r),
        this
      );
    }
    clone(t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.",
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[n + e]);
        }
        return new hr(
          new this.array.constructor(t),
          this.itemSize,
          this.normalized,
        );
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new Yo(
          t.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized,
        )
      );
    }
    toJSON(t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.",
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[n + e]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized,
        };
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
    }
  }
  class Ko extends Ki {
    constructor(t) {
      super(),
        (this.isSpriteMaterial = !0),
        (this.type = "SpriteMaterial"),
        (this.color = new tr(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.rotation = 0),
        (this.sizeAttenuation = !0),
        (this.transparent = !0),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.rotation = t.rotation),
        (this.sizeAttenuation = t.sizeAttenuation),
        (this.fog = t.fog),
        this
      );
    }
  }
  let Zo;
  const Jo = new Nn(),
    $o = new Nn(),
    Qo = new Nn(),
    tl = new sn(),
    el = new sn(),
    nl = new hi(),
    il = new Nn(),
    rl = new Nn(),
    sl = new Nn(),
    al = new sn(),
    ol = new sn(),
    ll = new sn();
  class cl extends Oi {
    constructor(t) {
      if (
        (super(), (this.isSprite = !0), (this.type = "Sprite"), void 0 === Zo)
      ) {
        Zo = new Mr();
        const t = new Float32Array([
            -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,
            0.5, 0, 0, 1,
          ]),
          e = new Xo(t, 5);
        Zo.setIndex([0, 1, 2, 0, 2, 3]),
          Zo.setAttribute("position", new Yo(e, 3, 0, !1)),
          Zo.setAttribute("uv", new Yo(e, 2, 3, !1));
      }
      (this.geometry = Zo),
        (this.material = void 0 !== t ? t : new Ko()),
        (this.center = new sn(0.5, 0.5));
    }
    raycast(t, e) {
      null === t.camera &&
        console.error(
          'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
        ),
        $o.setFromMatrixScale(this.matrixWorld),
        nl.copy(t.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(
          t.camera.matrixWorldInverse,
          this.matrixWorld,
        ),
        Qo.setFromMatrixPosition(this.modelViewMatrix),
        t.camera.isPerspectiveCamera &&
          !1 === this.material.sizeAttenuation &&
          $o.multiplyScalar(-Qo.z);
      const n = this.material.rotation;
      let i, r;
      0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
      const s = this.center;
      hl(il.set(-0.5, -0.5, 0), Qo, s, $o, i, r),
        hl(rl.set(0.5, -0.5, 0), Qo, s, $o, i, r),
        hl(sl.set(0.5, 0.5, 0), Qo, s, $o, i, r),
        al.set(0, 0),
        ol.set(1, 0),
        ll.set(1, 1);
      let a = t.ray.intersectTriangle(il, rl, sl, !1, Jo);
      if (
        null === a &&
        (hl(rl.set(-0.5, 0.5, 0), Qo, s, $o, i, r),
        ol.set(0, 1),
        (a = t.ray.intersectTriangle(il, sl, rl, !1, Jo)),
        null === a)
      )
        return;
      const o = t.ray.origin.distanceTo(Jo);
      o < t.near ||
        o > t.far ||
        e.push({
          distance: o,
          point: Jo.clone(),
          uv: qi.getInterpolation(Jo, il, rl, sl, al, ol, ll, new sn()),
          face: null,
          object: this,
        });
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        void 0 !== t.center && this.center.copy(t.center),
        (this.material = t.material),
        this
      );
    }
  }
  function hl(t, e, n, i, r, s) {
    tl.subVectors(t, n).addScalar(0.5).multiply(i),
      void 0 !== r
        ? ((el.x = s * tl.x - r * tl.y), (el.y = r * tl.x + s * tl.y))
        : el.copy(tl),
      t.copy(e),
      (t.x += el.x),
      (t.y += el.y),
      t.applyMatrix4(nl);
  }
  const ul = new Nn(),
    dl = new Nn();
  class pl extends Oi {
    constructor() {
      super(),
        (this._currentLevel = 0),
        (this.type = "LOD"),
        Object.defineProperties(this, {
          levels: { enumerable: !0, value: [] },
          isLOD: { value: !0 },
        }),
        (this.autoUpdate = !0);
    }
    copy(t) {
      super.copy(t, !1);
      const e = t.levels;
      for (let n = 0, i = e.length; n < i; n++) {
        const t = e[n];
        this.addLevel(t.object.clone(), t.distance, t.hysteresis);
      }
      return (this.autoUpdate = t.autoUpdate), this;
    }
    addLevel(t, e = 0, n = 0) {
      e = Math.abs(e);
      const i = this.levels;
      let r;
      for (r = 0; r < i.length && !(e < i[r].distance); r++);
      return (
        i.splice(r, 0, { distance: e, hysteresis: n, object: t }),
        this.add(t),
        this
      );
    }
    getCurrentLevel() {
      return this._currentLevel;
    }
    getObjectForDistance(t) {
      const e = this.levels;
      if (e.length > 0) {
        let n, i;
        for (n = 1, i = e.length; n < i; n++) {
          let i = e[n].distance;
          if ((e[n].object.visible && (i -= i * e[n].hysteresis), t < i)) break;
        }
        return e[n - 1].object;
      }
      return null;
    }
    raycast(t, e) {
      if (this.levels.length > 0) {
        ul.setFromMatrixPosition(this.matrixWorld);
        const n = t.ray.origin.distanceTo(ul);
        this.getObjectForDistance(n).raycast(t, e);
      }
    }
    update(t) {
      const e = this.levels;
      if (e.length > 1) {
        ul.setFromMatrixPosition(t.matrixWorld),
          dl.setFromMatrixPosition(this.matrixWorld);
        const n = ul.distanceTo(dl) / t.zoom;
        let i, r;
        for (e[0].object.visible = !0, i = 1, r = e.length; i < r; i++) {
          let t = e[i].distance;
          if ((e[i].object.visible && (t -= t * e[i].hysteresis), !(n >= t)))
            break;
          (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
        }
        for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1;
      }
    }
    toJSON(t) {
      const e = super.toJSON(t);
      !1 === this.autoUpdate && (e.object.autoUpdate = !1),
        (e.object.levels = []);
      const n = this.levels;
      for (let i = 0, r = n.length; i < r; i++) {
        const t = n[i];
        e.object.levels.push({
          object: t.object.uuid,
          distance: t.distance,
          hysteresis: t.hysteresis,
        });
      }
      return e;
    }
  }
  const fl = new Nn(),
    ml = new Rn(),
    gl = new Rn(),
    vl = new Nn(),
    _l = new hi(),
    yl = new Nn(),
    xl = new ei(),
    Ml = new hi(),
    Sl = new ci();
  class bl extends zr {
    constructor(t, e) {
      super(t, e),
        (this.isSkinnedMesh = !0),
        (this.type = "SkinnedMesh"),
        (this.bindMode = "attached"),
        (this.bindMatrix = new hi()),
        (this.bindMatrixInverse = new hi()),
        (this.boundingBox = null),
        (this.boundingSphere = null);
    }
    computeBoundingBox() {
      const t = this.geometry;
      null === this.boundingBox && (this.boundingBox = new Fn()),
        this.boundingBox.makeEmpty();
      const e = t.getAttribute("position");
      for (let n = 0; n < e.count; n++)
        yl.fromBufferAttribute(e, n),
          this.applyBoneTransform(n, yl),
          this.boundingBox.expandByPoint(yl);
    }
    computeBoundingSphere() {
      const t = this.geometry;
      null === this.boundingSphere && (this.boundingSphere = new ei()),
        this.boundingSphere.makeEmpty();
      const e = t.getAttribute("position");
      for (let n = 0; n < e.count; n++)
        yl.fromBufferAttribute(e, n),
          this.applyBoneTransform(n, yl),
          this.boundingSphere.expandByPoint(yl);
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.bindMode = t.bindMode),
        this.bindMatrix.copy(t.bindMatrix),
        this.bindMatrixInverse.copy(t.bindMatrixInverse),
        (this.skeleton = t.skeleton),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        null !== t.boundingSphere &&
          (this.boundingSphere = t.boundingSphere.clone()),
        this
      );
    }
    raycast(t, e) {
      const n = this.material,
        i = this.matrixWorld;
      void 0 !== n &&
        (null === this.boundingSphere && this.computeBoundingSphere(),
        xl.copy(this.boundingSphere),
        xl.applyMatrix4(i),
        !1 !== t.ray.intersectsSphere(xl) &&
          (Ml.copy(i).invert(),
          Sl.copy(t.ray).applyMatrix4(Ml),
          (null !== this.boundingBox &&
            !1 === Sl.intersectsBox(this.boundingBox)) ||
            this._computeIntersections(t, e, Sl)));
    }
    getVertexPosition(t, e) {
      return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e;
    }
    bind(t, e) {
      (this.skeleton = t),
        void 0 === e &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (e = this.matrixWorld)),
        this.bindMatrix.copy(e),
        this.bindMatrixInverse.copy(e).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const t = new Rn(),
        e = this.geometry.attributes.skinWeight;
      for (let n = 0, i = e.count; n < i; n++) {
        t.fromBufferAttribute(e, n);
        const i = 1 / t.manhattanLength();
        i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
          e.setXYZW(n, t.x, t.y, t.z, t.w);
      }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        "attached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
          : "detached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode,
            );
    }
    applyBoneTransform(t, e) {
      const n = this.skeleton,
        i = this.geometry;
      ml.fromBufferAttribute(i.attributes.skinIndex, t),
        gl.fromBufferAttribute(i.attributes.skinWeight, t),
        fl.copy(e).applyMatrix4(this.bindMatrix),
        e.set(0, 0, 0);
      for (let r = 0; r < 4; r++) {
        const t = gl.getComponent(r);
        if (0 !== t) {
          const i = ml.getComponent(r);
          _l.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
            e.addScaledVector(vl.copy(fl).applyMatrix4(_l), t);
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse);
    }
    boneTransform(t, e) {
      return (
        console.warn(
          "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151.",
        ),
        this.applyBoneTransform(t, e)
      );
    }
  }
  class Tl extends Oi {
    constructor() {
      super(), (this.isBone = !0), (this.type = "Bone");
    }
  }
  class wl extends An {
    constructor(
      t = null,
      e = 1,
      n = 1,
      i,
      r,
      s,
      a,
      o,
      l = 1003,
      c = 1003,
      h,
      u,
    ) {
      super(null, s, a, o, l, c, i, r, h, u),
        (this.isDataTexture = !0),
        (this.image = { data: t, width: e, height: n }),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  const El = new hi(),
    Al = new hi();
  class Rl {
    constructor(t = [], e = []) {
      (this.uuid = Ye()),
        (this.bones = t.slice(0)),
        (this.boneInverses = e),
        (this.boneMatrices = null),
        (this.boneTexture = null),
        (this.boneTextureSize = 0),
        this.init();
    }
    init() {
      const t = this.bones,
        e = this.boneInverses;
      if (
        ((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length)
      )
        this.calculateInverses();
      else if (t.length !== e.length) {
        console.warn(
          "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.",
        ),
          (this.boneInverses = []);
        for (let t = 0, e = this.bones.length; t < e; t++)
          this.boneInverses.push(new hi());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = new hi();
        this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
          this.boneInverses.push(e);
      }
    }
    pose() {
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e && e.matrixWorld.copy(this.boneInverses[t]).invert();
      }
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e &&
          (e.parent && e.parent.isBone
            ? (e.matrix.copy(e.parent.matrixWorld).invert(),
              e.matrix.multiply(e.matrixWorld))
            : e.matrix.copy(e.matrixWorld),
          e.matrix.decompose(e.position, e.quaternion, e.scale));
      }
    }
    update() {
      const t = this.bones,
        e = this.boneInverses,
        n = this.boneMatrices,
        i = this.boneTexture;
      for (let r = 0, s = t.length; r < s; r++) {
        const i = t[r] ? t[r].matrixWorld : Al;
        El.multiplyMatrices(i, e[r]), El.toArray(n, 16 * r);
      }
      null !== i && (i.needsUpdate = !0);
    }
    clone() {
      return new Rl(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let t = Math.sqrt(4 * this.bones.length);
      (t = Qe(t)), (t = Math.max(t, 4));
      const e = new Float32Array(t * t * 4);
      e.set(this.boneMatrices);
      const n = new wl(e, t, t, Gt, Ft);
      return (
        (n.needsUpdate = !0),
        (this.boneMatrices = e),
        (this.boneTexture = n),
        (this.boneTextureSize = t),
        this
      );
    }
    getBoneByName(t) {
      for (let e = 0, n = this.bones.length; e < n; e++) {
        const n = this.bones[e];
        if (n.name === t) return n;
      }
    }
    dispose() {
      null !== this.boneTexture &&
        (this.boneTexture.dispose(), (this.boneTexture = null));
    }
    fromJSON(t, e) {
      this.uuid = t.uuid;
      for (let n = 0, i = t.bones.length; n < i; n++) {
        const i = t.bones[n];
        let r = e[i];
        void 0 === r &&
          (console.warn("THREE.Skeleton: No bone found with UUID:", i),
          (r = new Tl())),
          this.bones.push(r),
          this.boneInverses.push(new hi().fromArray(t.boneInverses[n]));
      }
      return this.init(), this;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.6,
          type: "Skeleton",
          generator: "Skeleton.toJSON",
        },
        bones: [],
        boneInverses: [],
      };
      t.uuid = this.uuid;
      const e = this.bones,
        n = this.boneInverses;
      for (let i = 0, r = e.length; i < r; i++) {
        const r = e[i];
        t.bones.push(r.uuid);
        const s = n[i];
        t.boneInverses.push(s.toArray());
      }
      return t;
    }
  }
  class Cl extends hr {
    constructor(t, e, n, i = 1) {
      super(t, e, n),
        (this.isInstancedBufferAttribute = !0),
        (this.meshPerAttribute = i);
    }
    copy(t) {
      return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
    }
    toJSON() {
      const t = super.toJSON();
      return (
        (t.meshPerAttribute = this.meshPerAttribute),
        (t.isInstancedBufferAttribute = !0),
        t
      );
    }
  }
  const Ll = new hi(),
    Il = new hi(),
    Pl = [],
    Ul = new Fn(),
    Nl = new hi(),
    Ol = new zr(),
    Dl = new ei();
  class Fl extends zr {
    constructor(t, e, n) {
      super(t, e),
        (this.isInstancedMesh = !0),
        (this.instanceMatrix = new Cl(new Float32Array(16 * n), 16)),
        (this.instanceColor = null),
        (this.count = n),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      for (let i = 0; i < n; i++) this.setMatrixAt(i, Nl);
    }
    computeBoundingBox() {
      const t = this.geometry,
        e = this.count;
      null === this.boundingBox && (this.boundingBox = new Fn()),
        null === t.boundingBox && t.computeBoundingBox(),
        this.boundingBox.makeEmpty();
      for (let n = 0; n < e; n++)
        this.getMatrixAt(n, Ll),
          Ul.copy(t.boundingBox).applyMatrix4(Ll),
          this.boundingBox.union(Ul);
    }
    computeBoundingSphere() {
      const t = this.geometry,
        e = this.count;
      null === this.boundingSphere && (this.boundingSphere = new ei()),
        null === t.boundingSphere && t.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
      for (let n = 0; n < e; n++)
        this.getMatrixAt(n, Ll),
          Dl.copy(t.boundingSphere).applyMatrix4(Ll),
          this.boundingSphere.union(Dl);
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        this.instanceMatrix.copy(t.instanceMatrix),
        null !== t.instanceColor &&
          (this.instanceColor = t.instanceColor.clone()),
        (this.count = t.count),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        null !== t.boundingSphere &&
          (this.boundingSphere = t.boundingSphere.clone()),
        this
      );
    }
    getColorAt(t, e) {
      e.fromArray(this.instanceColor.array, 3 * t);
    }
    getMatrixAt(t, e) {
      e.fromArray(this.instanceMatrix.array, 16 * t);
    }
    raycast(t, e) {
      const n = this.matrixWorld,
        i = this.count;
      if (
        ((Ol.geometry = this.geometry),
        (Ol.material = this.material),
        void 0 !== Ol.material &&
          (null === this.boundingSphere && this.computeBoundingSphere(),
          Dl.copy(this.boundingSphere),
          Dl.applyMatrix4(n),
          !1 !== t.ray.intersectsSphere(Dl)))
      )
        for (let r = 0; r < i; r++) {
          this.getMatrixAt(r, Ll),
            Il.multiplyMatrices(n, Ll),
            (Ol.matrixWorld = Il),
            Ol.raycast(t, Pl);
          for (let t = 0, n = Pl.length; t < n; t++) {
            const n = Pl[t];
            (n.instanceId = r), (n.object = this), e.push(n);
          }
          Pl.length = 0;
        }
    }
    setColorAt(t, e) {
      null === this.instanceColor &&
        (this.instanceColor = new Cl(
          new Float32Array(3 * this.instanceMatrix.count),
          3,
        )),
        e.toArray(this.instanceColor.array, 3 * t);
    }
    setMatrixAt(t, e) {
      e.toArray(this.instanceMatrix.array, 16 * t);
    }
    updateMorphTargets() {}
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class Bl extends Ki {
    constructor(t) {
      super(),
        (this.isLineBasicMaterial = !0),
        (this.type = "LineBasicMaterial"),
        (this.color = new tr(16777215)),
        (this.map = null),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.linewidth = t.linewidth),
        (this.linecap = t.linecap),
        (this.linejoin = t.linejoin),
        (this.fog = t.fog),
        this
      );
    }
  }
  const zl = new Nn(),
    kl = new Nn(),
    Hl = new hi(),
    Gl = new ci(),
    Vl = new ei();
  class Wl extends Oi {
    constructor(t = new Mr(), e = new Bl()) {
      super(),
        (this.isLine = !0),
        (this.type = "Line"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    computeLineDistances() {
      const t = this.geometry;
      if (null === t.index) {
        const e = t.attributes.position,
          n = [0];
        for (let t = 1, i = e.count; t < i; t++)
          zl.fromBufferAttribute(e, t - 1),
            kl.fromBufferAttribute(e, t),
            (n[t] = n[t - 1]),
            (n[t] += zl.distanceTo(kl));
        t.setAttribute("lineDistance", new pr(n, 1));
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Line.threshold,
        s = n.drawRange;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        Vl.copy(n.boundingSphere),
        Vl.applyMatrix4(i),
        (Vl.radius += r),
        !1 === t.ray.intersectsSphere(Vl))
      )
        return;
      Hl.copy(i).invert(), Gl.copy(t.ray).applyMatrix4(Hl);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        o = a * a,
        l = new Nn(),
        c = new Nn(),
        h = new Nn(),
        u = new Nn(),
        d = this.isLineSegments ? 2 : 1,
        p = n.index,
        f = n.attributes.position;
      if (null !== p) {
        for (
          let n = Math.max(0, s.start),
            i = Math.min(p.count, s.start + s.count) - 1;
          n < i;
          n += d
        ) {
          const i = p.getX(n),
            r = p.getX(n + 1);
          l.fromBufferAttribute(f, i), c.fromBufferAttribute(f, r);
          if (Gl.distanceSqToSegment(l, c, u, h) > o) continue;
          u.applyMatrix4(this.matrixWorld);
          const s = t.ray.origin.distanceTo(u);
          s < t.near ||
            s > t.far ||
            e.push({
              distance: s,
              point: h.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else {
        for (
          let n = Math.max(0, s.start),
            i = Math.min(f.count, s.start + s.count) - 1;
          n < i;
          n += d
        ) {
          l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1);
          if (Gl.distanceSqToSegment(l, c, u, h) > o) continue;
          u.applyMatrix4(this.matrixWorld);
          const i = t.ray.origin.distanceTo(u);
          i < t.near ||
            i > t.far ||
            e.push({
              distance: i,
              point: h.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
  }
  const jl = new Nn(),
    Xl = new Nn();
  class ql extends Wl {
    constructor(t, e) {
      super(t, e), (this.isLineSegments = !0), (this.type = "LineSegments");
    }
    computeLineDistances() {
      const t = this.geometry;
      if (null === t.index) {
        const e = t.attributes.position,
          n = [];
        for (let t = 0, i = e.count; t < i; t += 2)
          jl.fromBufferAttribute(e, t),
            Xl.fromBufferAttribute(e, t + 1),
            (n[t] = 0 === t ? 0 : n[t - 1]),
            (n[t + 1] = n[t] + jl.distanceTo(Xl));
        t.setAttribute("lineDistance", new pr(n, 1));
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
  }
  class Yl extends Wl {
    constructor(t, e) {
      super(t, e), (this.isLineLoop = !0), (this.type = "LineLoop");
    }
  }
  class Kl extends Ki {
    constructor(t) {
      super(),
        (this.isPointsMaterial = !0),
        (this.type = "PointsMaterial"),
        (this.color = new tr(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.size = 1),
        (this.sizeAttenuation = !0),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.size = t.size),
        (this.sizeAttenuation = t.sizeAttenuation),
        (this.fog = t.fog),
        this
      );
    }
  }
  const Zl = new hi(),
    Jl = new ci(),
    $l = new ei(),
    Ql = new Nn();
  class tc extends Oi {
    constructor(t = new Mr(), e = new Kl()) {
      super(),
        (this.isPoints = !0),
        (this.type = "Points"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Points.threshold,
        s = n.drawRange;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        $l.copy(n.boundingSphere),
        $l.applyMatrix4(i),
        ($l.radius += r),
        !1 === t.ray.intersectsSphere($l))
      )
        return;
      Zl.copy(i).invert(), Jl.copy(t.ray).applyMatrix4(Zl);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        o = a * a,
        l = n.index,
        c = n.attributes.position;
      if (null !== l) {
        for (
          let n = Math.max(0, s.start),
            r = Math.min(l.count, s.start + s.count);
          n < r;
          n++
        ) {
          const r = l.getX(n);
          Ql.fromBufferAttribute(c, r), ec(Ql, r, o, i, t, e, this);
        }
      } else {
        for (
          let n = Math.max(0, s.start),
            r = Math.min(c.count, s.start + s.count);
          n < r;
          n++
        )
          Ql.fromBufferAttribute(c, n), ec(Ql, n, o, i, t, e, this);
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
  }
  function ec(t, e, n, i, r, s, a) {
    const o = Jl.distanceSqToPoint(t);
    if (o < n) {
      const n = new Nn();
      Jl.closestPointToPoint(t, n), n.applyMatrix4(i);
      const l = r.ray.origin.distanceTo(n);
      if (l < r.near || l > r.far) return;
      s.push({
        distance: l,
        distanceToRay: Math.sqrt(o),
        point: n,
        index: e,
        face: null,
        object: a,
      });
    }
  }
  class nc extends An {
    constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
      super(null, s, a, o, l, c, i, r, h, u),
        (this.isCompressedTexture = !0),
        (this.image = { width: e, height: n }),
        (this.mipmaps = t),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
  }
  class ic {
    constructor() {
      (this.type = "Curve"), (this.arcLengthDivisions = 200);
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(t, e) {
      const n = this.getUtoTmapping(t);
      return this.getPoint(n, e);
    }
    getPoints(t = 5) {
      const e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
      return e;
    }
    getSpacedPoints(t = 5) {
      const e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
      return e;
    }
    getLength() {
      const t = this.getLengths();
      return t[t.length - 1];
    }
    getLengths(t = this.arcLengthDivisions) {
      if (
        this.cacheArcLengths &&
        this.cacheArcLengths.length === t + 1 &&
        !this.needsUpdate
      )
        return this.cacheArcLengths;
      this.needsUpdate = !1;
      const e = [];
      let n,
        i = this.getPoint(0),
        r = 0;
      e.push(0);
      for (let s = 1; s <= t; s++)
        (n = this.getPoint(s / t)), (r += n.distanceTo(i)), e.push(r), (i = n);
      return (this.cacheArcLengths = e), e;
    }
    updateArcLengths() {
      (this.needsUpdate = !0), this.getLengths();
    }
    getUtoTmapping(t, e) {
      const n = this.getLengths();
      let i = 0;
      const r = n.length;
      let s;
      s = e || t * n[r - 1];
      let a,
        o = 0,
        l = r - 1;
      for (; o <= l; )
        if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - s), a < 0))
          o = i + 1;
        else {
          if (!(a > 0)) {
            l = i;
            break;
          }
          l = i - 1;
        }
      if (((i = l), n[i] === s)) return i / (r - 1);
      const c = n[i];
      return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
    }
    getTangent(t, e) {
      const n = 1e-4;
      let i = t - n,
        r = t + n;
      i < 0 && (i = 0), r > 1 && (r = 1);
      const s = this.getPoint(i),
        a = this.getPoint(r),
        o = e || (s.isVector2 ? new sn() : new Nn());
      return o.copy(a).sub(s).normalize(), o;
    }
    getTangentAt(t, e) {
      const n = this.getUtoTmapping(t);
      return this.getTangent(n, e);
    }
    computeFrenetFrames(t, e) {
      const n = new Nn(),
        i = [],
        r = [],
        s = [],
        a = new Nn(),
        o = new hi();
      for (let d = 0; d <= t; d++) {
        const e = d / t;
        i[d] = this.getTangentAt(e, new Nn());
      }
      (r[0] = new Nn()), (s[0] = new Nn());
      let l = Number.MAX_VALUE;
      const c = Math.abs(i[0].x),
        h = Math.abs(i[0].y),
        u = Math.abs(i[0].z);
      c <= l && ((l = c), n.set(1, 0, 0)),
        h <= l && ((l = h), n.set(0, 1, 0)),
        u <= l && n.set(0, 0, 1),
        a.crossVectors(i[0], n).normalize(),
        r[0].crossVectors(i[0], a),
        s[0].crossVectors(i[0], r[0]);
      for (let d = 1; d <= t; d++) {
        if (
          ((r[d] = r[d - 1].clone()),
          (s[d] = s[d - 1].clone()),
          a.crossVectors(i[d - 1], i[d]),
          a.length() > Number.EPSILON)
        ) {
          a.normalize();
          const t = Math.acos(Ke(i[d - 1].dot(i[d]), -1, 1));
          r[d].applyMatrix4(o.makeRotationAxis(a, t));
        }
        s[d].crossVectors(i[d], r[d]);
      }
      if (!0 === e) {
        let e = Math.acos(Ke(r[0].dot(r[t]), -1, 1));
        (e /= t), i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
        for (let n = 1; n <= t; n++)
          r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)),
            s[n].crossVectors(i[n], r[n]);
      }
      return { tangents: i, normals: r, binormals: s };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return (this.arcLengthDivisions = t.arcLengthDivisions), this;
    }
    toJSON() {
      const t = {
        metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
      };
      return (
        (t.arcLengthDivisions = this.arcLengthDivisions),
        (t.type = this.type),
        t
      );
    }
    fromJSON(t) {
      return (this.arcLengthDivisions = t.arcLengthDivisions), this;
    }
  }
  class rc extends ic {
    constructor(
      t = 0,
      e = 0,
      n = 1,
      i = 1,
      r = 0,
      s = 2 * Math.PI,
      a = !1,
      o = 0,
    ) {
      super(),
        (this.isEllipseCurve = !0),
        (this.type = "EllipseCurve"),
        (this.aX = t),
        (this.aY = e),
        (this.xRadius = n),
        (this.yRadius = i),
        (this.aStartAngle = r),
        (this.aEndAngle = s),
        (this.aClockwise = a),
        (this.aRotation = o);
    }
    getPoint(t, e) {
      const n = e || new sn(),
        i = 2 * Math.PI;
      let r = this.aEndAngle - this.aStartAngle;
      const s = Math.abs(r) < Number.EPSILON;
      for (; r < 0; ) r += i;
      for (; r > i; ) r -= i;
      r < Number.EPSILON && (r = s ? 0 : i),
        !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));
      const a = this.aStartAngle + t * r;
      let o = this.aX + this.xRadius * Math.cos(a),
        l = this.aY + this.yRadius * Math.sin(a);
      if (0 !== this.aRotation) {
        const t = Math.cos(this.aRotation),
          e = Math.sin(this.aRotation),
          n = o - this.aX,
          i = l - this.aY;
        (o = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);
      }
      return n.set(o, l);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.aX = t.aX),
        (this.aY = t.aY),
        (this.xRadius = t.xRadius),
        (this.yRadius = t.yRadius),
        (this.aStartAngle = t.aStartAngle),
        (this.aEndAngle = t.aEndAngle),
        (this.aClockwise = t.aClockwise),
        (this.aRotation = t.aRotation),
        this
      );
    }
    toJSON() {
      const t = super.toJSON();
      return (
        (t.aX = this.aX),
        (t.aY = this.aY),
        (t.xRadius = this.xRadius),
        (t.yRadius = this.yRadius),
        (t.aStartAngle = this.aStartAngle),
        (t.aEndAngle = this.aEndAngle),
        (t.aClockwise = this.aClockwise),
        (t.aRotation = this.aRotation),
        t
      );
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        (this.aX = t.aX),
        (this.aY = t.aY),
        (this.xRadius = t.xRadius),
        (this.yRadius = t.yRadius),
        (this.aStartAngle = t.aStartAngle),
        (this.aEndAngle = t.aEndAngle),
        (this.aClockwise = t.aClockwise),
        (this.aRotation = t.aRotation),
        this
      );
    }
  }
  class sc extends rc {
    constructor(t, e, n, i, r, s) {
      super(t, e, n, n, i, r, s),
        (this.isArcCurve = !0),
        (this.type = "ArcCurve");
    }
  }
  function ac() {
    let t = 0,
      e = 0,
      n = 0,
      i = 0;
    function r(r, s, a, o) {
      (t = r),
        (e = a),
        (n = -3 * r + 3 * s - 2 * a - o),
        (i = 2 * r - 2 * s + a + o);
    }
    return {
      initCatmullRom: function (t, e, n, i, s) {
        r(e, n, s * (n - t), s * (i - e));
      },
      initNonuniformCatmullRom: function (t, e, n, i, s, a, o) {
        let l = (e - t) / s - (n - t) / (s + a) + (n - e) / a,
          c = (n - e) / a - (i - e) / (a + o) + (i - n) / o;
        (l *= a), (c *= a), r(e, n, l, c);
      },
      calc: function (r) {
        const s = r * r;
        return t + e * r + n * s + i * (s * r);
      },
    };
  }
  const oc = new Nn(),
    lc = new ac(),
    cc = new ac(),
    hc = new ac();
  class uc extends ic {
    constructor(t = [], e = !1, n = "centripetal", i = 0.5) {
      super(),
        (this.isCatmullRomCurve3 = !0),
        (this.type = "CatmullRomCurve3"),
        (this.points = t),
        (this.closed = e),
        (this.curveType = n),
        (this.tension = i);
    }
    getPoint(t, e = new Nn()) {
      const n = e,
        i = this.points,
        r = i.length,
        s = (r - (this.closed ? 0 : 1)) * t;
      let a,
        o,
        l = Math.floor(s),
        c = s - l;
      this.closed
        ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
        : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
        this.closed || l > 0
          ? (a = i[(l - 1) % r])
          : (oc.subVectors(i[0], i[1]).add(i[0]), (a = oc));
      const h = i[l % r],
        u = i[(l + 1) % r];
      if (
        (this.closed || l + 2 < r
          ? (o = i[(l + 2) % r])
          : (oc.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (o = oc)),
        "centripetal" === this.curveType || "chordal" === this.curveType)
      ) {
        const t = "chordal" === this.curveType ? 0.5 : 0.25;
        let e = Math.pow(a.distanceToSquared(h), t),
          n = Math.pow(h.distanceToSquared(u), t),
          i = Math.pow(u.distanceToSquared(o), t);
        n < 1e-4 && (n = 1),
          e < 1e-4 && (e = n),
          i < 1e-4 && (i = n),
          lc.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i),
          cc.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i),
          hc.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i);
      } else "catmullrom" === this.curveType && (lc.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), cc.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), hc.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
      return n.set(lc.calc(c), cc.calc(c), hc.calc(c)), n;
    }
    copy(t) {
      super.copy(t), (this.points = []);
      for (let e = 0, n = t.points.length; e < n; e++) {
        const n = t.points[e];
        this.points.push(n.clone());
      }
      return (
        (this.closed = t.closed),
        (this.curveType = t.curveType),
        (this.tension = t.tension),
        this
      );
    }
    toJSON() {
      const t = super.toJSON();
      t.points = [];
      for (let e = 0, n = this.points.length; e < n; e++) {
        const n = this.points[e];
        t.points.push(n.toArray());
      }
      return (
        (t.closed = this.closed),
        (t.curveType = this.curveType),
        (t.tension = this.tension),
        t
      );
    }
    fromJSON(t) {
      super.fromJSON(t), (this.points = []);
      for (let e = 0, n = t.points.length; e < n; e++) {
        const n = t.points[e];
        this.points.push(new Nn().fromArray(n));
      }
      return (
        (this.closed = t.closed),
        (this.curveType = t.curveType),
        (this.tension = t.tension),
        this
      );
    }
  }
  function dc(t, e, n, i, r) {
    const s = 0.5 * (i - e),
      a = 0.5 * (r - n),
      o = t * t;
    return (
      (2 * n - 2 * i + s + a) * (t * o) +
      (-3 * n + 3 * i - 2 * s - a) * o +
      s * t +
      n
    );
  }
  function pc(t, e, n, i) {
    return (
      (function (t, e) {
        const n = 1 - t;
        return n * n * e;
      })(t, e) +
      (function (t, e) {
        return 2 * (1 - t) * t * e;
      })(t, n) +
      (function (t, e) {
        return t * t * e;
      })(t, i)
    );
  }
  function fc(t, e, n, i, r) {
    return (
      (function (t, e) {
        const n = 1 - t;
        return n * n * n * e;
      })(t, e) +
      (function (t, e) {
        const n = 1 - t;
        return 3 * n * n * t * e;
      })(t, n) +
      (function (t, e) {
        return 3 * (1 - t) * t * t * e;
      })(t, i) +
      (function (t, e) {
        return t * t * t * e;
      })(t, r)
    );
  }
  class mc extends ic {
    constructor(t = new sn(), e = new sn(), n = new sn(), i = new sn()) {
      super(),
        (this.isCubicBezierCurve = !0),
        (this.type = "CubicBezierCurve"),
        (this.v0 = t),
        (this.v1 = e),
        (this.v2 = n),
        (this.v3 = i);
    }
    getPoint(t, e = new sn()) {
      const n = e,
        i = this.v0,
        r = this.v1,
        s = this.v2,
        a = this.v3;
      return n.set(fc(t, i.x, r.x, s.x, a.x), fc(t, i.y, r.y, s.y, a.y)), n;
    }
    copy(t) {
      return (
        super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      );
    }
    toJSON() {
      const t = super.toJSON();
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        (t.v3 = this.v3.toArray()),
        t
      );
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
      );
    }
  }
  class gc extends ic {
    constructor(t = new Nn(), e = new Nn(), n = new Nn(), i = new Nn()) {
      super(),
        (this.isCubicBezierCurve3 = !0),
        (this.type = "CubicBezierCurve3"),
        (this.v0 = t),
        (this.v1 = e),
        (this.v2 = n),
        (this.v3 = i);
    }
    getPoint(t, e = new Nn()) {
      const n = e,
        i = this.v0,
        r = this.v1,
        s = this.v2,
        a = this.v3;
      return (
        n.set(
          fc(t, i.x, r.x, s.x, a.x),
          fc(t, i.y, r.y, s.y, a.y),
          fc(t, i.z, r.z, s.z, a.z),
        ),
        n
      );
    }
    copy(t) {
      return (
        super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      );
    }
    toJSON() {
      const t = super.toJSON();
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        (t.v3 = this.v3.toArray()),
        t
      );
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
      );
    }
  }
  class vc extends ic {
    constructor(t = new sn(), e = new sn()) {
      super(),
        (this.isLineCurve = !0),
        (this.type = "LineCurve"),
        (this.v1 = t),
        (this.v2 = e);
    }
    getPoint(t, e = new sn()) {
      const n = e;
      return (
        1 === t
          ? n.copy(this.v2)
          : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
        n
      );
    }
    getPointAt(t, e) {
      return this.getPoint(t, e);
    }
    getTangent(t, e = new sn()) {
      return e.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(t, e) {
      return this.getTangent(t, e);
    }
    copy(t) {
      return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
    toJSON() {
      const t = super.toJSON();
      return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }
  }
  class _c extends ic {
    constructor(t = new Nn(), e = new Nn()) {
      super(),
        (this.isLineCurve3 = !0),
        (this.type = "LineCurve3"),
        (this.v1 = t),
        (this.v2 = e);
    }
    getPoint(t, e = new Nn()) {
      const n = e;
      return (
        1 === t
          ? n.copy(this.v2)
          : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
        n
      );
    }
    getPointAt(t, e) {
      return this.getPoint(t, e);
    }
    getTangent(t, e = new Nn()) {
      return e.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(t, e) {
      return this.getTangent(t, e);
    }
    copy(t) {
      return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
    toJSON() {
      const t = super.toJSON();
      return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }
  }
  class yc extends ic {
    constructor(t = new sn(), e = new sn(), n = new sn()) {
      super(),
        (this.isQuadraticBezierCurve = !0),
        (this.type = "QuadraticBezierCurve"),
        (this.v0 = t),
        (this.v1 = e),
        (this.v2 = n);
    }
    getPoint(t, e = new sn()) {
      const n = e,
        i = this.v0,
        r = this.v1,
        s = this.v2;
      return n.set(pc(t, i.x, r.x, s.x), pc(t, i.y, r.y, s.y)), n;
    }
    copy(t) {
      return (
        super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      );
    }
    toJSON() {
      const t = super.toJSON();
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        t
      );
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }
  }
  class xc extends ic {
    constructor(t = new Nn(), e = new Nn(), n = new Nn()) {
      super(),
        (this.isQuadraticBezierCurve3 = !0),
        (this.type = "QuadraticBezierCurve3"),
        (this.v0 = t),
        (this.v1 = e),
        (this.v2 = n);
    }
    getPoint(t, e = new Nn()) {
      const n = e,
        i = this.v0,
        r = this.v1,
        s = this.v2;
      return (
        n.set(pc(t, i.x, r.x, s.x), pc(t, i.y, r.y, s.y), pc(t, i.z, r.z, s.z)),
        n
      );
    }
    copy(t) {
      return (
        super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      );
    }
    toJSON() {
      const t = super.toJSON();
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        t
      );
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }
  }
  class Mc extends ic {
    constructor(t = []) {
      super(),
        (this.isSplineCurve = !0),
        (this.type = "SplineCurve"),
        (this.points = t);
    }
    getPoint(t, e = new sn()) {
      const n = e,
        i = this.points,
        r = (i.length - 1) * t,
        s = Math.floor(r),
        a = r - s,
        o = i[0 === s ? s : s - 1],
        l = i[s],
        c = i[s > i.length - 2 ? i.length - 1 : s + 1],
        h = i[s > i.length - 3 ? i.length - 1 : s + 2];
      return n.set(dc(a, o.x, l.x, c.x, h.x), dc(a, o.y, l.y, c.y, h.y)), n;
    }
    copy(t) {
      super.copy(t), (this.points = []);
      for (let e = 0, n = t.points.length; e < n; e++) {
        const n = t.points[e];
        this.points.push(n.clone());
      }
      return this;
    }
    toJSON() {
      const t = super.toJSON();
      t.points = [];
      for (let e = 0, n = this.points.length; e < n; e++) {
        const n = this.points[e];
        t.points.push(n.toArray());
      }
      return t;
    }
    fromJSON(t) {
      super.fromJSON(t), (this.points = []);
      for (let e = 0, n = t.points.length; e < n; e++) {
        const n = t.points[e];
        this.points.push(new sn().fromArray(n));
      }
      return this;
    }
  }
  var Sc = Object.freeze({
    __proto__: null,
    ArcCurve: sc,
    CatmullRomCurve3: uc,
    CubicBezierCurve: mc,
    CubicBezierCurve3: gc,
    EllipseCurve: rc,
    LineCurve: vc,
    LineCurve3: _c,
    QuadraticBezierCurve: yc,
    QuadraticBezierCurve3: xc,
    SplineCurve: Mc,
  });
  class bc extends ic {
    constructor() {
      super(),
        (this.type = "CurvePath"),
        (this.curves = []),
        (this.autoClose = !1);
    }
    add(t) {
      this.curves.push(t);
    }
    closePath() {
      const t = this.curves[0].getPoint(0),
        e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new vc(e, t));
    }
    getPoint(t, e) {
      const n = t * this.getLength(),
        i = this.getCurveLengths();
      let r = 0;
      for (; r < i.length; ) {
        if (i[r] >= n) {
          const t = i[r] - n,
            s = this.curves[r],
            a = s.getLength(),
            o = 0 === a ? 0 : 1 - t / a;
          return s.getPointAt(o, e);
        }
        r++;
      }
      return null;
    }
    getLength() {
      const t = this.getCurveLengths();
      return t[t.length - 1];
    }
    updateArcLengths() {
      (this.needsUpdate = !0),
        (this.cacheLengths = null),
        this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      const t = [];
      let e = 0;
      for (let n = 0, i = this.curves.length; n < i; n++)
        (e += this.curves[n].getLength()), t.push(e);
      return (this.cacheLengths = t), t;
    }
    getSpacedPoints(t = 40) {
      const e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
      return this.autoClose && e.push(e[0]), e;
    }
    getPoints(t = 12) {
      const e = [];
      let n;
      for (let i = 0, r = this.curves; i < r.length; i++) {
        const s = r[i],
          a = s.isEllipseCurve
            ? 2 * t
            : s.isLineCurve || s.isLineCurve3
            ? 1
            : s.isSplineCurve
            ? t * s.points.length
            : t,
          o = s.getPoints(a);
        for (let t = 0; t < o.length; t++) {
          const i = o[t];
          (n && n.equals(i)) || (e.push(i), (n = i));
        }
      }
      return (
        this.autoClose &&
          e.length > 1 &&
          !e[e.length - 1].equals(e[0]) &&
          e.push(e[0]),
        e
      );
    }
    copy(t) {
      super.copy(t), (this.curves = []);
      for (let e = 0, n = t.curves.length; e < n; e++) {
        const n = t.curves[e];
        this.curves.push(n.clone());
      }
      return (this.autoClose = t.autoClose), this;
    }
    toJSON() {
      const t = super.toJSON();
      (t.autoClose = this.autoClose), (t.curves = []);
      for (let e = 0, n = this.curves.length; e < n; e++) {
        const n = this.curves[e];
        t.curves.push(n.toJSON());
      }
      return t;
    }
    fromJSON(t) {
      super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
      for (let e = 0, n = t.curves.length; e < n; e++) {
        const n = t.curves[e];
        this.curves.push(new Sc[n.type]().fromJSON(n));
      }
      return this;
    }
  }
  class Tc extends bc {
    constructor(t) {
      super(),
        (this.type = "Path"),
        (this.currentPoint = new sn()),
        t && this.setFromPoints(t);
    }
    setFromPoints(t) {
      this.moveTo(t[0].x, t[0].y);
      for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
      return this;
    }
    moveTo(t, e) {
      return this.currentPoint.set(t, e), this;
    }
    lineTo(t, e) {
      const n = new vc(this.currentPoint.clone(), new sn(t, e));
      return this.curves.push(n), this.currentPoint.set(t, e), this;
    }
    quadraticCurveTo(t, e, n, i) {
      const r = new yc(this.currentPoint.clone(), new sn(t, e), new sn(n, i));
      return this.curves.push(r), this.currentPoint.set(n, i), this;
    }
    bezierCurveTo(t, e, n, i, r, s) {
      const a = new mc(
        this.currentPoint.clone(),
        new sn(t, e),
        new sn(n, i),
        new sn(r, s),
      );
      return this.curves.push(a), this.currentPoint.set(r, s), this;
    }
    splineThru(t) {
      const e = [this.currentPoint.clone()].concat(t),
        n = new Mc(e);
      return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
    }
    arc(t, e, n, i, r, s) {
      const a = this.currentPoint.x,
        o = this.currentPoint.y;
      return this.absarc(t + a, e + o, n, i, r, s), this;
    }
    absarc(t, e, n, i, r, s) {
      return this.absellipse(t, e, n, n, i, r, s), this;
    }
    ellipse(t, e, n, i, r, s, a, o) {
      const l = this.currentPoint.x,
        c = this.currentPoint.y;
      return this.absellipse(t + l, e + c, n, i, r, s, a, o), this;
    }
    absellipse(t, e, n, i, r, s, a, o) {
      const l = new rc(t, e, n, i, r, s, a, o);
      if (this.curves.length > 0) {
        const t = l.getPoint(0);
        t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
      }
      this.curves.push(l);
      const c = l.getPoint(1);
      return this.currentPoint.copy(c), this;
    }
    copy(t) {
      return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
    }
    toJSON() {
      const t = super.toJSON();
      return (t.currentPoint = this.currentPoint.toArray()), t;
    }
    fromJSON(t) {
      return (
        super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
      );
    }
  }
  class wc extends Mr {
    constructor(
      t = [new sn(0, -0.5), new sn(0.5, 0), new sn(0, 0.5)],
      e = 12,
      n = 0,
      i = 2 * Math.PI,
    ) {
      super(),
        (this.type = "LatheGeometry"),
        (this.parameters = {
          points: t,
          segments: e,
          phiStart: n,
          phiLength: i,
        }),
        (e = Math.floor(e)),
        (i = Ke(i, 0, 2 * Math.PI));
      const r = [],
        s = [],
        a = [],
        o = [],
        l = [],
        c = 1 / e,
        h = new Nn(),
        u = new sn(),
        d = new Nn(),
        p = new Nn(),
        f = new Nn();
      let m = 0,
        g = 0;
      for (let v = 0; v <= t.length - 1; v++)
        switch (v) {
          case 0:
            (m = t[v + 1].x - t[v].x),
              (g = t[v + 1].y - t[v].y),
              (d.x = 1 * g),
              (d.y = -m),
              (d.z = 0 * g),
              f.copy(d),
              d.normalize(),
              o.push(d.x, d.y, d.z);
            break;
          case t.length - 1:
            o.push(f.x, f.y, f.z);
            break;
          default:
            (m = t[v + 1].x - t[v].x),
              (g = t[v + 1].y - t[v].y),
              (d.x = 1 * g),
              (d.y = -m),
              (d.z = 0 * g),
              p.copy(d),
              (d.x += f.x),
              (d.y += f.y),
              (d.z += f.z),
              d.normalize(),
              o.push(d.x, d.y, d.z),
              f.copy(p);
        }
      for (let v = 0; v <= e; v++) {
        const r = n + v * c * i,
          d = Math.sin(r),
          p = Math.cos(r);
        for (let n = 0; n <= t.length - 1; n++) {
          (h.x = t[n].x * d),
            (h.y = t[n].y),
            (h.z = t[n].x * p),
            s.push(h.x, h.y, h.z),
            (u.x = v / e),
            (u.y = n / (t.length - 1)),
            a.push(u.x, u.y);
          const i = o[3 * n + 0] * d,
            r = o[3 * n + 1],
            c = o[3 * n + 0] * p;
          l.push(i, r, c);
        }
      }
      for (let v = 0; v < e; v++)
        for (let e = 0; e < t.length - 1; e++) {
          const n = e + v * t.length,
            i = n,
            s = n + t.length,
            a = n + t.length + 1,
            o = n + 1;
          r.push(i, s, o), r.push(a, o, s);
        }
      this.setIndex(r),
        this.setAttribute("position", new pr(s, 3)),
        this.setAttribute("uv", new pr(a, 2)),
        this.setAttribute("normal", new pr(l, 3));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new wc(t.points, t.segments, t.phiStart, t.phiLength);
    }
  }
  class Ec extends wc {
    constructor(t = 1, e = 1, n = 4, i = 8) {
      const r = new Tc();
      r.absarc(0, -e / 2, t, 1.5 * Math.PI, 0),
        r.absarc(0, e / 2, t, 0, 0.5 * Math.PI),
        super(r.getPoints(n), i),
        (this.type = "CapsuleGeometry"),
        (this.parameters = {
          radius: t,
          length: e,
          capSegments: n,
          radialSegments: i,
        });
    }
    static fromJSON(t) {
      return new Ec(t.radius, t.length, t.capSegments, t.radialSegments);
    }
  }
  class Ac extends Mr {
    constructor(t = 1, e = 32, n = 0, i = 2 * Math.PI) {
      super(),
        (this.type = "CircleGeometry"),
        (this.parameters = {
          radius: t,
          segments: e,
          thetaStart: n,
          thetaLength: i,
        }),
        (e = Math.max(3, e));
      const r = [],
        s = [],
        a = [],
        o = [],
        l = new Nn(),
        c = new sn();
      s.push(0, 0, 0), a.push(0, 0, 1), o.push(0.5, 0.5);
      for (let h = 0, u = 3; h <= e; h++, u += 3) {
        const r = n + (h / e) * i;
        (l.x = t * Math.cos(r)),
          (l.y = t * Math.sin(r)),
          s.push(l.x, l.y, l.z),
          a.push(0, 0, 1),
          (c.x = (s[u] / t + 1) / 2),
          (c.y = (s[u + 1] / t + 1) / 2),
          o.push(c.x, c.y);
      }
      for (let h = 1; h <= e; h++) r.push(h, h + 1, 0);
      this.setIndex(r),
        this.setAttribute("position", new pr(s, 3)),
        this.setAttribute("normal", new pr(a, 3)),
        this.setAttribute("uv", new pr(o, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new Ac(t.radius, t.segments, t.thetaStart, t.thetaLength);
    }
  }
  class Rc extends Mr {
    constructor(
      t = 1,
      e = 1,
      n = 1,
      i = 32,
      r = 1,
      s = !1,
      a = 0,
      o = 2 * Math.PI,
    ) {
      super(),
        (this.type = "CylinderGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: i,
          heightSegments: r,
          openEnded: s,
          thetaStart: a,
          thetaLength: o,
        });
      const l = this;
      (i = Math.floor(i)), (r = Math.floor(r));
      const c = [],
        h = [],
        u = [],
        d = [];
      let p = 0;
      const f = [],
        m = n / 2;
      let g = 0;
      function v(n) {
        const r = p,
          s = new sn(),
          f = new Nn();
        let v = 0;
        const _ = !0 === n ? t : e,
          y = !0 === n ? 1 : -1;
        for (let t = 1; t <= i; t++)
          h.push(0, m * y, 0), u.push(0, y, 0), d.push(0.5, 0.5), p++;
        const x = p;
        for (let t = 0; t <= i; t++) {
          const e = (t / i) * o + a,
            n = Math.cos(e),
            r = Math.sin(e);
          (f.x = _ * r),
            (f.y = m * y),
            (f.z = _ * n),
            h.push(f.x, f.y, f.z),
            u.push(0, y, 0),
            (s.x = 0.5 * n + 0.5),
            (s.y = 0.5 * r * y + 0.5),
            d.push(s.x, s.y),
            p++;
        }
        for (let t = 0; t < i; t++) {
          const e = r + t,
            i = x + t;
          !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), (v += 3);
        }
        l.addGroup(g, v, !0 === n ? 1 : 2), (g += v);
      }
      !(function () {
        const s = new Nn(),
          v = new Nn();
        let _ = 0;
        const y = (e - t) / n;
        for (let l = 0; l <= r; l++) {
          const c = [],
            g = l / r,
            _ = g * (e - t) + t;
          for (let t = 0; t <= i; t++) {
            const e = t / i,
              r = e * o + a,
              l = Math.sin(r),
              f = Math.cos(r);
            (v.x = _ * l),
              (v.y = -g * n + m),
              (v.z = _ * f),
              h.push(v.x, v.y, v.z),
              s.set(l, y, f).normalize(),
              u.push(s.x, s.y, s.z),
              d.push(e, 1 - g),
              c.push(p++);
          }
          f.push(c);
        }
        for (let t = 0; t < i; t++)
          for (let e = 0; e < r; e++) {
            const n = f[e][t],
              i = f[e + 1][t],
              r = f[e + 1][t + 1],
              s = f[e][t + 1];
            c.push(n, i, s), c.push(i, r, s), (_ += 6);
          }
        l.addGroup(g, _, 0), (g += _);
      })(),
        !1 === s && (t > 0 && v(!0), e > 0 && v(!1)),
        this.setIndex(c),
        this.setAttribute("position", new pr(h, 3)),
        this.setAttribute("normal", new pr(u, 3)),
        this.setAttribute("uv", new pr(d, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new Rc(
        t.radiusTop,
        t.radiusBottom,
        t.height,
        t.radialSegments,
        t.heightSegments,
        t.openEnded,
        t.thetaStart,
        t.thetaLength,
      );
    }
  }
  class Cc extends Rc {
    constructor(t = 1, e = 1, n = 32, i = 1, r = !1, s = 0, a = 2 * Math.PI) {
      super(0, t, e, n, i, r, s, a),
        (this.type = "ConeGeometry"),
        (this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: i,
          openEnded: r,
          thetaStart: s,
          thetaLength: a,
        });
    }
    static fromJSON(t) {
      return new Cc(
        t.radius,
        t.height,
        t.radialSegments,
        t.heightSegments,
        t.openEnded,
        t.thetaStart,
        t.thetaLength,
      );
    }
  }
  class Lc extends Mr {
    constructor(t = [], e = [], n = 1, i = 0) {
      super(),
        (this.type = "PolyhedronGeometry"),
        (this.parameters = { vertices: t, indices: e, radius: n, detail: i });
      const r = [],
        s = [];
      function a(t, e, n, i) {
        const r = i + 1,
          s = [];
        for (let a = 0; a <= r; a++) {
          s[a] = [];
          const i = t.clone().lerp(n, a / r),
            o = e.clone().lerp(n, a / r),
            l = r - a;
          for (let t = 0; t <= l; t++)
            s[a][t] = 0 === t && a === r ? i : i.clone().lerp(o, t / l);
        }
        for (let a = 0; a < r; a++)
          for (let t = 0; t < 2 * (r - a) - 1; t++) {
            const e = Math.floor(t / 2);
            t % 2 == 0
              ? (o(s[a][e + 1]), o(s[a + 1][e]), o(s[a][e]))
              : (o(s[a][e + 1]), o(s[a + 1][e + 1]), o(s[a + 1][e]));
          }
      }
      function o(t) {
        r.push(t.x, t.y, t.z);
      }
      function l(e, n) {
        const i = 3 * e;
        (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
      }
      function c(t, e, n, i) {
        i < 0 && 1 === t.x && (s[e] = t.x - 1),
          0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + 0.5);
      }
      function h(t) {
        return Math.atan2(t.z, -t.x);
      }
      !(function (t) {
        const n = new Nn(),
          i = new Nn(),
          r = new Nn();
        for (let s = 0; s < e.length; s += 3)
          l(e[s + 0], n), l(e[s + 1], i), l(e[s + 2], r), a(n, i, r, t);
      })(i),
        (function (t) {
          const e = new Nn();
          for (let n = 0; n < r.length; n += 3)
            (e.x = r[n + 0]),
              (e.y = r[n + 1]),
              (e.z = r[n + 2]),
              e.normalize().multiplyScalar(t),
              (r[n + 0] = e.x),
              (r[n + 1] = e.y),
              (r[n + 2] = e.z);
        })(n),
        (function () {
          const t = new Nn();
          for (let n = 0; n < r.length; n += 3) {
            (t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);
            const i = h(t) / 2 / Math.PI + 0.5,
              a =
                ((e = t),
                Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI +
                  0.5);
            s.push(i, 1 - a);
          }
          var e;
          (function () {
            const t = new Nn(),
              e = new Nn(),
              n = new Nn(),
              i = new Nn(),
              a = new sn(),
              o = new sn(),
              l = new sn();
            for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
              t.set(r[u + 0], r[u + 1], r[u + 2]),
                e.set(r[u + 3], r[u + 4], r[u + 5]),
                n.set(r[u + 6], r[u + 7], r[u + 8]),
                a.set(s[d + 0], s[d + 1]),
                o.set(s[d + 2], s[d + 3]),
                l.set(s[d + 4], s[d + 5]),
                i.copy(t).add(e).add(n).divideScalar(3);
              const p = h(i);
              c(a, d + 0, t, p), c(o, d + 2, e, p), c(l, d + 4, n, p);
            }
          })(),
            (function () {
              for (let t = 0; t < s.length; t += 6) {
                const e = s[t + 0],
                  n = s[t + 2],
                  i = s[t + 4],
                  r = Math.max(e, n, i),
                  a = Math.min(e, n, i);
                r > 0.9 &&
                  a < 0.1 &&
                  (e < 0.2 && (s[t + 0] += 1),
                  n < 0.2 && (s[t + 2] += 1),
                  i < 0.2 && (s[t + 4] += 1));
              }
            })();
        })(),
        this.setAttribute("position", new pr(r, 3)),
        this.setAttribute("normal", new pr(r.slice(), 3)),
        this.setAttribute("uv", new pr(s, 2)),
        0 === i ? this.computeVertexNormals() : this.normalizeNormals();
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new Lc(t.vertices, t.indices, t.radius, t.details);
    }
  }
  class Ic extends Lc {
    constructor(t = 1, e = 0) {
      const n = (1 + Math.sqrt(5)) / 2,
        i = 1 / n;
      super(
        [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -i,
          -n,
          0,
          -i,
          n,
          0,
          i,
          -n,
          0,
          i,
          n,
          -i,
          -n,
          0,
          -i,
          n,
          0,
          i,
          -n,
          0,
          i,
          n,
          0,
          -n,
          0,
          -i,
          n,
          0,
          -i,
          -n,
          0,
          i,
          n,
          0,
          i,
        ],
        [
          3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
          8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1,
          18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2,
          3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8,
          11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1,
          12, 14, 1, 14, 5, 1, 5, 9,
        ],
        t,
        e,
      ),
        (this.type = "DodecahedronGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    static fromJSON(t) {
      return new Ic(t.radius, t.detail);
    }
  }
  const Pc = new Nn(),
    Uc = new Nn(),
    Nc = new Nn(),
    Oc = new qi();
  class Dc extends Mr {
    constructor(t = null, e = 1) {
      if (
        (super(),
        (this.type = "EdgesGeometry"),
        (this.parameters = { geometry: t, thresholdAngle: e }),
        null !== t)
      ) {
        const n = 4,
          i = Math.pow(10, n),
          r = Math.cos(Xe * e),
          s = t.getIndex(),
          a = t.getAttribute("position"),
          o = s ? s.count : a.count,
          l = [0, 0, 0],
          c = ["a", "b", "c"],
          h = new Array(3),
          u = {},
          d = [];
        for (let t = 0; t < o; t += 3) {
          s
            ? ((l[0] = s.getX(t)),
              (l[1] = s.getX(t + 1)),
              (l[2] = s.getX(t + 2)))
            : ((l[0] = t), (l[1] = t + 1), (l[2] = t + 2));
          const { a: e, b: n, c: o } = Oc;
          if (
            (e.fromBufferAttribute(a, l[0]),
            n.fromBufferAttribute(a, l[1]),
            o.fromBufferAttribute(a, l[2]),
            Oc.getNormal(Nc),
            (h[0] = `${Math.round(e.x * i)},${Math.round(e.y * i)},${Math.round(
              e.z * i,
            )}`),
            (h[1] = `${Math.round(n.x * i)},${Math.round(n.y * i)},${Math.round(
              n.z * i,
            )}`),
            (h[2] = `${Math.round(o.x * i)},${Math.round(o.y * i)},${Math.round(
              o.z * i,
            )}`),
            h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
          )
            for (let t = 0; t < 3; t++) {
              const e = (t + 1) % 3,
                n = h[t],
                i = h[e],
                s = Oc[c[t]],
                a = Oc[c[e]],
                o = `${n}_${i}`,
                p = `${i}_${n}`;
              p in u && u[p]
                ? (Nc.dot(u[p].normal) <= r &&
                    (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)),
                  (u[p] = null))
                : o in u ||
                  (u[o] = { index0: l[t], index1: l[e], normal: Nc.clone() });
            }
        }
        for (const t in u)
          if (u[t]) {
            const { index0: e, index1: n } = u[t];
            Pc.fromBufferAttribute(a, e),
              Uc.fromBufferAttribute(a, n),
              d.push(Pc.x, Pc.y, Pc.z),
              d.push(Uc.x, Uc.y, Uc.z);
          }
        this.setAttribute("position", new pr(d, 3));
      }
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
  }
  class Fc extends Tc {
    constructor(t) {
      super(t), (this.uuid = Ye()), (this.type = "Shape"), (this.holes = []);
    }
    getPointsHoles(t) {
      const e = [];
      for (let n = 0, i = this.holes.length; n < i; n++)
        e[n] = this.holes[n].getPoints(t);
      return e;
    }
    extractPoints(t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
    }
    copy(t) {
      super.copy(t), (this.holes = []);
      for (let e = 0, n = t.holes.length; e < n; e++) {
        const n = t.holes[e];
        this.holes.push(n.clone());
      }
      return this;
    }
    toJSON() {
      const t = super.toJSON();
      (t.uuid = this.uuid), (t.holes = []);
      for (let e = 0, n = this.holes.length; e < n; e++) {
        const n = this.holes[e];
        t.holes.push(n.toJSON());
      }
      return t;
    }
    fromJSON(t) {
      super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
      for (let e = 0, n = t.holes.length; e < n; e++) {
        const n = t.holes[e];
        this.holes.push(new Tc().fromJSON(n));
      }
      return this;
    }
  }
  const Bc = function (t, e, n = 2) {
    const i = e && e.length,
      r = i ? e[0] * n : t.length;
    let s = zc(t, 0, r, n, !0);
    const a = [];
    if (!s || s.next === s.prev) return a;
    let o, l, c, h, u, d, p;
    if (
      (i &&
        (s = (function (t, e, n, i) {
          const r = [];
          let s, a, o, l, c;
          for (s = 0, a = e.length; s < a; s++)
            (o = e[s] * i),
              (l = s < a - 1 ? e[s + 1] * i : t.length),
              (c = zc(t, o, l, i, !1)),
              c === c.next && (c.steiner = !0),
              r.push(Zc(c));
          for (r.sort(Xc), s = 0; s < r.length; s++) n = qc(r[s], n);
          return n;
        })(t, e, s, n)),
      t.length > 80 * n)
    ) {
      (o = c = t[0]), (l = h = t[1]);
      for (let e = n; e < r; e += n)
        (u = t[e]),
          (d = t[e + 1]),
          u < o && (o = u),
          d < l && (l = d),
          u > c && (c = u),
          d > h && (h = d);
      (p = Math.max(c - o, h - l)), (p = 0 !== p ? 32767 / p : 0);
    }
    return Hc(s, a, n, o, l, p, 0), a;
  };
  function zc(t, e, n, i, r) {
    let s, a;
    if (
      r ===
      (function (t, e, n, i) {
        let r = 0;
        for (let s = e, a = n - i; s < n; s += i)
          (r += (t[a] - t[s]) * (t[s + 1] + t[a + 1])), (a = s);
        return r;
      })(t, e, n, i) >
        0
    )
      for (s = e; s < n; s += i) a = ah(s, t[s], t[s + 1], a);
    else for (s = n - i; s >= e; s -= i) a = ah(s, t[s], t[s + 1], a);
    return a && th(a, a.next) && (oh(a), (a = a.next)), a;
  }
  function kc(t, e) {
    if (!t) return t;
    e || (e = t);
    let n,
      i = t;
    do {
      if (
        ((n = !1), i.steiner || (!th(i, i.next) && 0 !== Qc(i.prev, i, i.next)))
      )
        i = i.next;
      else {
        if ((oh(i), (i = e = i.prev), i === i.next)) break;
        n = !0;
      }
    } while (n || i !== e);
    return e;
  }
  function Hc(t, e, n, i, r, s, a) {
    if (!t) return;
    !a &&
      s &&
      (function (t, e, n, i) {
        let r = t;
        do {
          0 === r.z && (r.z = Kc(r.x, r.y, e, n, i)),
            (r.prevZ = r.prev),
            (r.nextZ = r.next),
            (r = r.next);
        } while (r !== t);
        (r.prevZ.nextZ = null),
          (r.prevZ = null),
          (function (t) {
            let e,
              n,
              i,
              r,
              s,
              a,
              o,
              l,
              c = 1;
            do {
              for (n = t, t = null, s = null, a = 0; n; ) {
                for (
                  a++, i = n, o = 0, e = 0;
                  e < c && (o++, (i = i.nextZ), i);
                  e++
                );
                for (l = c; o > 0 || (l > 0 && i); )
                  0 !== o && (0 === l || !i || n.z <= i.z)
                    ? ((r = n), (n = n.nextZ), o--)
                    : ((r = i), (i = i.nextZ), l--),
                    s ? (s.nextZ = r) : (t = r),
                    (r.prevZ = s),
                    (s = r);
                n = i;
              }
              (s.nextZ = null), (c *= 2);
            } while (a > 1);
          })(r);
      })(t, i, r, s);
    let o,
      l,
      c = t;
    for (; t.prev !== t.next; )
      if (((o = t.prev), (l = t.next), s ? Vc(t, i, r, s) : Gc(t)))
        e.push((o.i / n) | 0),
          e.push((t.i / n) | 0),
          e.push((l.i / n) | 0),
          oh(t),
          (t = l.next),
          (c = l.next);
      else if ((t = l) === c) {
        a
          ? 1 === a
            ? Hc((t = Wc(kc(t), e, n)), e, n, i, r, s, 2)
            : 2 === a && jc(t, e, n, i, r, s)
          : Hc(kc(t), e, n, i, r, s, 1);
        break;
      }
  }
  function Gc(t) {
    const e = t.prev,
      n = t,
      i = t.next;
    if (Qc(e, n, i) >= 0) return !1;
    const r = e.x,
      s = n.x,
      a = i.x,
      o = e.y,
      l = n.y,
      c = i.y,
      h = r < s ? (r < a ? r : a) : s < a ? s : a,
      u = o < l ? (o < c ? o : c) : l < c ? l : c,
      d = r > s ? (r > a ? r : a) : s > a ? s : a,
      p = o > l ? (o > c ? o : c) : l > c ? l : c;
    let f = i.next;
    for (; f !== e; ) {
      if (
        f.x >= h &&
        f.x <= d &&
        f.y >= u &&
        f.y <= p &&
        Jc(r, o, s, l, a, c, f.x, f.y) &&
        Qc(f.prev, f, f.next) >= 0
      )
        return !1;
      f = f.next;
    }
    return !0;
  }
  function Vc(t, e, n, i) {
    const r = t.prev,
      s = t,
      a = t.next;
    if (Qc(r, s, a) >= 0) return !1;
    const o = r.x,
      l = s.x,
      c = a.x,
      h = r.y,
      u = s.y,
      d = a.y,
      p = o < l ? (o < c ? o : c) : l < c ? l : c,
      f = h < u ? (h < d ? h : d) : u < d ? u : d,
      m = o > l ? (o > c ? o : c) : l > c ? l : c,
      g = h > u ? (h > d ? h : d) : u > d ? u : d,
      v = Kc(p, f, e, n, i),
      _ = Kc(m, g, e, n, i);
    let y = t.prevZ,
      x = t.nextZ;
    for (; y && y.z >= v && x && x.z <= _; ) {
      if (
        y.x >= p &&
        y.x <= m &&
        y.y >= f &&
        y.y <= g &&
        y !== r &&
        y !== a &&
        Jc(o, h, l, u, c, d, y.x, y.y) &&
        Qc(y.prev, y, y.next) >= 0
      )
        return !1;
      if (
        ((y = y.prevZ),
        x.x >= p &&
          x.x <= m &&
          x.y >= f &&
          x.y <= g &&
          x !== r &&
          x !== a &&
          Jc(o, h, l, u, c, d, x.x, x.y) &&
          Qc(x.prev, x, x.next) >= 0)
      )
        return !1;
      x = x.nextZ;
    }
    for (; y && y.z >= v; ) {
      if (
        y.x >= p &&
        y.x <= m &&
        y.y >= f &&
        y.y <= g &&
        y !== r &&
        y !== a &&
        Jc(o, h, l, u, c, d, y.x, y.y) &&
        Qc(y.prev, y, y.next) >= 0
      )
        return !1;
      y = y.prevZ;
    }
    for (; x && x.z <= _; ) {
      if (
        x.x >= p &&
        x.x <= m &&
        x.y >= f &&
        x.y <= g &&
        x !== r &&
        x !== a &&
        Jc(o, h, l, u, c, d, x.x, x.y) &&
        Qc(x.prev, x, x.next) >= 0
      )
        return !1;
      x = x.nextZ;
    }
    return !0;
  }
  function Wc(t, e, n) {
    let i = t;
    do {
      const r = i.prev,
        s = i.next.next;
      !th(r, s) &&
        eh(r, i, i.next, s) &&
        rh(r, s) &&
        rh(s, r) &&
        (e.push((r.i / n) | 0),
        e.push((i.i / n) | 0),
        e.push((s.i / n) | 0),
        oh(i),
        oh(i.next),
        (i = t = s)),
        (i = i.next);
    } while (i !== t);
    return kc(i);
  }
  function jc(t, e, n, i, r, s) {
    let a = t;
    do {
      let t = a.next.next;
      for (; t !== a.prev; ) {
        if (a.i !== t.i && $c(a, t)) {
          let o = sh(a, t);
          return (
            (a = kc(a, a.next)),
            (o = kc(o, o.next)),
            Hc(a, e, n, i, r, s, 0),
            void Hc(o, e, n, i, r, s, 0)
          );
        }
        t = t.next;
      }
      a = a.next;
    } while (a !== t);
  }
  function Xc(t, e) {
    return t.x - e.x;
  }
  function qc(t, e) {
    const n = (function (t, e) {
      let n,
        i = e,
        r = -1 / 0;
      const s = t.x,
        a = t.y;
      do {
        if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
          const t = i.x + ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
          if (
            t <= s &&
            t > r &&
            ((r = t), (n = i.x < i.next.x ? i : i.next), t === s)
          )
            return n;
        }
        i = i.next;
      } while (i !== e);
      if (!n) return null;
      const o = n,
        l = n.x,
        c = n.y;
      let h,
        u = 1 / 0;
      i = n;
      do {
        s >= i.x &&
          i.x >= l &&
          s !== i.x &&
          Jc(a < c ? s : r, a, l, c, a < c ? r : s, a, i.x, i.y) &&
          ((h = Math.abs(a - i.y) / (s - i.x)),
          rh(i, t) &&
            (h < u || (h === u && (i.x > n.x || (i.x === n.x && Yc(n, i))))) &&
            ((n = i), (u = h))),
          (i = i.next);
      } while (i !== o);
      return n;
    })(t, e);
    if (!n) return e;
    const i = sh(n, t);
    return kc(i, i.next), kc(n, n.next);
  }
  function Yc(t, e) {
    return Qc(t.prev, t, e.prev) < 0 && Qc(e.next, t, t.next) < 0;
  }
  function Kc(t, e, n, i, r) {
    return (
      (t =
        1431655765 &
        ((t =
          858993459 &
          ((t =
            252645135 &
            ((t = 16711935 & ((t = ((t - n) * r) | 0) | (t << 8))) |
              (t << 4))) |
            (t << 2))) |
          (t << 1))) |
      ((e =
        1431655765 &
        ((e =
          858993459 &
          ((e =
            252645135 &
            ((e = 16711935 & ((e = ((e - i) * r) | 0) | (e << 8))) |
              (e << 4))) |
            (e << 2))) |
          (e << 1))) <<
        1)
    );
  }
  function Zc(t) {
    let e = t,
      n = t;
    do {
      (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
    } while (e !== t);
    return n;
  }
  function Jc(t, e, n, i, r, s, a, o) {
    return (
      (r - a) * (e - o) >= (t - a) * (s - o) &&
      (t - a) * (i - o) >= (n - a) * (e - o) &&
      (n - a) * (s - o) >= (r - a) * (i - o)
    );
  }
  function $c(t, e) {
    return (
      t.next.i !== e.i &&
      t.prev.i !== e.i &&
      !(function (t, e) {
        let n = t;
        do {
          if (
            n.i !== t.i &&
            n.next.i !== t.i &&
            n.i !== e.i &&
            n.next.i !== e.i &&
            eh(n, n.next, t, e)
          )
            return !0;
          n = n.next;
        } while (n !== t);
        return !1;
      })(t, e) &&
      ((rh(t, e) &&
        rh(e, t) &&
        (function (t, e) {
          let n = t,
            i = !1;
          const r = (t.x + e.x) / 2,
            s = (t.y + e.y) / 2;
          do {
            n.y > s != n.next.y > s &&
              n.next.y !== n.y &&
              r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
              (i = !i),
              (n = n.next);
          } while (n !== t);
          return i;
        })(t, e) &&
        (Qc(t.prev, t, e.prev) || Qc(t, e.prev, e))) ||
        (th(t, e) && Qc(t.prev, t, t.next) > 0 && Qc(e.prev, e, e.next) > 0))
    );
  }
  function Qc(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
  }
  function th(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function eh(t, e, n, i) {
    const r = ih(Qc(t, e, n)),
      s = ih(Qc(t, e, i)),
      a = ih(Qc(n, i, t)),
      o = ih(Qc(n, i, e));
    return (
      (r !== s && a !== o) ||
      !(0 !== r || !nh(t, n, e)) ||
      !(0 !== s || !nh(t, i, e)) ||
      !(0 !== a || !nh(n, t, i)) ||
      !(0 !== o || !nh(n, e, i))
    );
  }
  function nh(t, e, n) {
    return (
      e.x <= Math.max(t.x, n.x) &&
      e.x >= Math.min(t.x, n.x) &&
      e.y <= Math.max(t.y, n.y) &&
      e.y >= Math.min(t.y, n.y)
    );
  }
  function ih(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0;
  }
  function rh(t, e) {
    return Qc(t.prev, t, t.next) < 0
      ? Qc(t, e, t.next) >= 0 && Qc(t, t.prev, e) >= 0
      : Qc(t, e, t.prev) < 0 || Qc(t, t.next, e) < 0;
  }
  function sh(t, e) {
    const n = new lh(t.i, t.x, t.y),
      i = new lh(e.i, e.x, e.y),
      r = t.next,
      s = e.prev;
    return (
      (t.next = e),
      (e.prev = t),
      (n.next = r),
      (r.prev = n),
      (i.next = n),
      (n.prev = i),
      (s.next = i),
      (i.prev = s),
      i
    );
  }
  function ah(t, e, n, i) {
    const r = new lh(t, e, n);
    return (
      i
        ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
        : ((r.prev = r), (r.next = r)),
      r
    );
  }
  function oh(t) {
    (t.next.prev = t.prev),
      (t.prev.next = t.next),
      t.prevZ && (t.prevZ.nextZ = t.nextZ),
      t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function lh(t, e, n) {
    (this.i = t),
      (this.x = e),
      (this.y = n),
      (this.prev = null),
      (this.next = null),
      (this.z = 0),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }
  class ch {
    static area(t) {
      const e = t.length;
      let n = 0;
      for (let i = e - 1, r = 0; r < e; i = r++)
        n += t[i].x * t[r].y - t[r].x * t[i].y;
      return 0.5 * n;
    }
    static isClockWise(t) {
      return ch.area(t) < 0;
    }
    static triangulateShape(t, e) {
      const n = [],
        i = [],
        r = [];
      hh(t), uh(n, t);
      let s = t.length;
      e.forEach(hh);
      for (let o = 0; o < e.length; o++)
        i.push(s), (s += e[o].length), uh(n, e[o]);
      const a = Bc(n, i);
      for (let o = 0; o < a.length; o += 3) r.push(a.slice(o, o + 3));
      return r;
    }
  }
  function hh(t) {
    const e = t.length;
    e > 2 && t[e - 1].equals(t[0]) && t.pop();
  }
  function uh(t, e) {
    for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
  }
  class dh extends Mr {
    constructor(
      t = new Fc([
        new sn(0.5, 0.5),
        new sn(-0.5, 0.5),
        new sn(-0.5, -0.5),
        new sn(0.5, -0.5),
      ]),
      e = {},
    ) {
      super(),
        (this.type = "ExtrudeGeometry"),
        (this.parameters = { shapes: t, options: e }),
        (t = Array.isArray(t) ? t : [t]);
      const n = this,
        i = [],
        r = [];
      for (let a = 0, o = t.length; a < o; a++) {
        s(t[a]);
      }
      function s(t) {
        const s = [],
          a = void 0 !== e.curveSegments ? e.curveSegments : 12,
          o = void 0 !== e.steps ? e.steps : 1,
          l = void 0 !== e.depth ? e.depth : 1;
        let c = void 0 === e.bevelEnabled || e.bevelEnabled,
          h = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
          u = void 0 !== e.bevelSize ? e.bevelSize : h - 0.1,
          d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
          p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
        const f = e.extrudePath,
          m = void 0 !== e.UVGenerator ? e.UVGenerator : ph;
        let g,
          v,
          _,
          y,
          x,
          M = !1;
        f &&
          ((g = f.getSpacedPoints(o)),
          (M = !0),
          (c = !1),
          (v = f.computeFrenetFrames(o, !1)),
          (_ = new Nn()),
          (y = new Nn()),
          (x = new Nn())),
          c || ((p = 0), (h = 0), (u = 0), (d = 0));
        const S = t.extractPoints(a);
        let b = S.shape;
        const T = S.holes;
        if (!ch.isClockWise(b)) {
          b = b.reverse();
          for (let t = 0, e = T.length; t < e; t++) {
            const e = T[t];
            ch.isClockWise(e) && (T[t] = e.reverse());
          }
        }
        const w = ch.triangulateShape(b, T),
          E = b;
        for (let e = 0, n = T.length; e < n; e++) {
          const t = T[e];
          b = b.concat(t);
        }
        function A(t, e, n) {
          return (
            e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
            t.clone().addScaledVector(e, n)
          );
        }
        const R = b.length,
          C = w.length;
        function L(t, e, n) {
          let i, r, s;
          const a = t.x - e.x,
            o = t.y - e.y,
            l = n.x - t.x,
            c = n.y - t.y,
            h = a * a + o * o,
            u = a * c - o * l;
          if (Math.abs(u) > Number.EPSILON) {
            const u = Math.sqrt(h),
              d = Math.sqrt(l * l + c * c),
              p = e.x - o / u,
              f = e.y + a / u,
              m =
                ((n.x - c / d - p) * c - (n.y + l / d - f) * l) /
                (a * c - o * l);
            (i = p + a * m - t.x), (r = f + o * m - t.y);
            const g = i * i + r * r;
            if (g <= 2) return new sn(i, r);
            s = Math.sqrt(g / 2);
          } else {
            let t = !1;
            a > Number.EPSILON
              ? l > Number.EPSILON && (t = !0)
              : a < -Number.EPSILON
              ? l < -Number.EPSILON && (t = !0)
              : Math.sign(o) === Math.sign(c) && (t = !0),
              t
                ? ((i = -o), (r = a), (s = Math.sqrt(h)))
                : ((i = a), (r = o), (s = Math.sqrt(h / 2)));
          }
          return new sn(i / s, r / s);
        }
        const I = [];
        for (
          let e = 0, n = E.length, i = n - 1, r = e + 1;
          e < n;
          e++, i++, r++
        )
          i === n && (i = 0), r === n && (r = 0), (I[e] = L(E[e], E[i], E[r]));
        const P = [];
        let U,
          N = I.concat();
        for (let e = 0, n = T.length; e < n; e++) {
          const t = T[e];
          U = [];
          for (
            let e = 0, n = t.length, i = n - 1, r = e + 1;
            e < n;
            e++, i++, r++
          )
            i === n && (i = 0),
              r === n && (r = 0),
              (U[e] = L(t[e], t[i], t[r]));
          P.push(U), (N = N.concat(U));
        }
        for (let e = 0; e < p; e++) {
          const t = e / p,
            n = h * Math.cos((t * Math.PI) / 2),
            i = u * Math.sin((t * Math.PI) / 2) + d;
          for (let e = 0, r = E.length; e < r; e++) {
            const t = A(E[e], I[e], i);
            F(t.x, t.y, -n);
          }
          for (let e = 0, r = T.length; e < r; e++) {
            const t = T[e];
            U = P[e];
            for (let e = 0, r = t.length; e < r; e++) {
              const r = A(t[e], U[e], i);
              F(r.x, r.y, -n);
            }
          }
        }
        const O = u + d;
        for (let e = 0; e < R; e++) {
          const t = c ? A(b[e], N[e], O) : b[e];
          M
            ? (y.copy(v.normals[0]).multiplyScalar(t.x),
              _.copy(v.binormals[0]).multiplyScalar(t.y),
              x.copy(g[0]).add(y).add(_),
              F(x.x, x.y, x.z))
            : F(t.x, t.y, 0);
        }
        for (let e = 1; e <= o; e++)
          for (let t = 0; t < R; t++) {
            const n = c ? A(b[t], N[t], O) : b[t];
            M
              ? (y.copy(v.normals[e]).multiplyScalar(n.x),
                _.copy(v.binormals[e]).multiplyScalar(n.y),
                x.copy(g[e]).add(y).add(_),
                F(x.x, x.y, x.z))
              : F(n.x, n.y, (l / o) * e);
          }
        for (let e = p - 1; e >= 0; e--) {
          const t = e / p,
            n = h * Math.cos((t * Math.PI) / 2),
            i = u * Math.sin((t * Math.PI) / 2) + d;
          for (let e = 0, r = E.length; e < r; e++) {
            const t = A(E[e], I[e], i);
            F(t.x, t.y, l + n);
          }
          for (let e = 0, r = T.length; e < r; e++) {
            const t = T[e];
            U = P[e];
            for (let e = 0, r = t.length; e < r; e++) {
              const r = A(t[e], U[e], i);
              M ? F(r.x, r.y + g[o - 1].y, g[o - 1].x + n) : F(r.x, r.y, l + n);
            }
          }
        }
        function D(t, e) {
          let n = t.length;
          for (; --n >= 0; ) {
            const i = n;
            let r = n - 1;
            r < 0 && (r = t.length - 1);
            for (let t = 0, n = o + 2 * p; t < n; t++) {
              const n = R * t,
                s = R * (t + 1);
              z(e + i + n, e + r + n, e + r + s, e + i + s);
            }
          }
        }
        function F(t, e, n) {
          s.push(t), s.push(e), s.push(n);
        }
        function B(t, e, r) {
          k(t), k(e), k(r);
          const s = i.length / 3,
            a = m.generateTopUV(n, i, s - 3, s - 2, s - 1);
          H(a[0]), H(a[1]), H(a[2]);
        }
        function z(t, e, r, s) {
          k(t), k(e), k(s), k(e), k(r), k(s);
          const a = i.length / 3,
            o = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
          H(o[0]), H(o[1]), H(o[3]), H(o[1]), H(o[2]), H(o[3]);
        }
        function k(t) {
          i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2]);
        }
        function H(t) {
          r.push(t.x), r.push(t.y);
        }
        !(function () {
          const t = i.length / 3;
          if (c) {
            let t = 0,
              e = R * t;
            for (let n = 0; n < C; n++) {
              const t = w[n];
              B(t[2] + e, t[1] + e, t[0] + e);
            }
            (t = o + 2 * p), (e = R * t);
            for (let n = 0; n < C; n++) {
              const t = w[n];
              B(t[0] + e, t[1] + e, t[2] + e);
            }
          } else {
            for (let t = 0; t < C; t++) {
              const e = w[t];
              B(e[2], e[1], e[0]);
            }
            for (let t = 0; t < C; t++) {
              const e = w[t];
              B(e[0] + R * o, e[1] + R * o, e[2] + R * o);
            }
          }
          n.addGroup(t, i.length / 3 - t, 0);
        })(),
          (function () {
            const t = i.length / 3;
            let e = 0;
            D(E, e), (e += E.length);
            for (let n = 0, i = T.length; n < i; n++) {
              const t = T[n];
              D(t, e), (e += t.length);
            }
            n.addGroup(t, i.length / 3 - t, 1);
          })();
      }
      this.setAttribute("position", new pr(i, 3)),
        this.setAttribute("uv", new pr(r, 2)),
        this.computeVertexNormals();
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    toJSON() {
      const t = super.toJSON();
      return (function (t, e, n) {
        if (((n.shapes = []), Array.isArray(t)))
          for (let i = 0, r = t.length; i < r; i++) {
            const e = t[i];
            n.shapes.push(e.uuid);
          }
        else n.shapes.push(t.uuid);
        (n.options = Object.assign({}, e)),
          void 0 !== e.extrudePath &&
            (n.options.extrudePath = e.extrudePath.toJSON());
        return n;
      })(this.parameters.shapes, this.parameters.options, t);
    }
    static fromJSON(t, e) {
      const n = [];
      for (let r = 0, s = t.shapes.length; r < s; r++) {
        const i = e[t.shapes[r]];
        n.push(i);
      }
      const i = t.options.extrudePath;
      return (
        void 0 !== i && (t.options.extrudePath = new Sc[i.type]().fromJSON(i)),
        new dh(n, t.options)
      );
    }
  }
  const ph = {
    generateTopUV: function (t, e, n, i, r) {
      const s = e[3 * n],
        a = e[3 * n + 1],
        o = e[3 * i],
        l = e[3 * i + 1],
        c = e[3 * r],
        h = e[3 * r + 1];
      return [new sn(s, a), new sn(o, l), new sn(c, h)];
    },
    generateSideWallUV: function (t, e, n, i, r, s) {
      const a = e[3 * n],
        o = e[3 * n + 1],
        l = e[3 * n + 2],
        c = e[3 * i],
        h = e[3 * i + 1],
        u = e[3 * i + 2],
        d = e[3 * r],
        p = e[3 * r + 1],
        f = e[3 * r + 2],
        m = e[3 * s],
        g = e[3 * s + 1],
        v = e[3 * s + 2];
      return Math.abs(o - h) < Math.abs(a - c)
        ? [
            new sn(a, 1 - l),
            new sn(c, 1 - u),
            new sn(d, 1 - f),
            new sn(m, 1 - v),
          ]
        : [
            new sn(o, 1 - l),
            new sn(h, 1 - u),
            new sn(p, 1 - f),
            new sn(g, 1 - v),
          ];
    },
  };
  class fh extends Lc {
    constructor(t = 1, e = 0) {
      const n = (1 + Math.sqrt(5)) / 2;
      super(
        [
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          0,
          0,
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          n,
          0,
          -1,
          n,
          0,
          1,
          -n,
          0,
          -1,
          -n,
          0,
          1,
        ],
        [
          0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
          11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
          8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
        ],
        t,
        e,
      ),
        (this.type = "IcosahedronGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    static fromJSON(t) {
      return new fh(t.radius, t.detail);
    }
  }
  class mh extends Lc {
    constructor(t = 1, e = 0) {
      super(
        [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
        [
          0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4,
          2,
        ],
        t,
        e,
      ),
        (this.type = "OctahedronGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    static fromJSON(t) {
      return new mh(t.radius, t.detail);
    }
  }
  class gh extends Mr {
    constructor(t = 0.5, e = 1, n = 32, i = 1, r = 0, s = 2 * Math.PI) {
      super(),
        (this.type = "RingGeometry"),
        (this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: n,
          phiSegments: i,
          thetaStart: r,
          thetaLength: s,
        }),
        (n = Math.max(3, n));
      const a = [],
        o = [],
        l = [],
        c = [];
      let h = t;
      const u = (e - t) / (i = Math.max(1, i)),
        d = new Nn(),
        p = new sn();
      for (let f = 0; f <= i; f++) {
        for (let t = 0; t <= n; t++) {
          const i = r + (t / n) * s;
          (d.x = h * Math.cos(i)),
            (d.y = h * Math.sin(i)),
            o.push(d.x, d.y, d.z),
            l.push(0, 0, 1),
            (p.x = (d.x / e + 1) / 2),
            (p.y = (d.y / e + 1) / 2),
            c.push(p.x, p.y);
        }
        h += u;
      }
      for (let f = 0; f < i; f++) {
        const t = f * (n + 1);
        for (let e = 0; e < n; e++) {
          const i = e + t,
            r = i,
            s = i + n + 1,
            o = i + n + 2,
            l = i + 1;
          a.push(r, s, l), a.push(s, o, l);
        }
      }
      this.setIndex(a),
        this.setAttribute("position", new pr(o, 3)),
        this.setAttribute("normal", new pr(l, 3)),
        this.setAttribute("uv", new pr(c, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new gh(
        t.innerRadius,
        t.outerRadius,
        t.thetaSegments,
        t.phiSegments,
        t.thetaStart,
        t.thetaLength,
      );
    }
  }
  class vh extends Mr {
    constructor(
      t = new Fc([new sn(0, 0.5), new sn(-0.5, -0.5), new sn(0.5, -0.5)]),
      e = 12,
    ) {
      super(),
        (this.type = "ShapeGeometry"),
        (this.parameters = { shapes: t, curveSegments: e });
      const n = [],
        i = [],
        r = [],
        s = [];
      let a = 0,
        o = 0;
      if (!1 === Array.isArray(t)) l(t);
      else
        for (let c = 0; c < t.length; c++)
          l(t[c]), this.addGroup(a, o, c), (a += o), (o = 0);
      function l(t) {
        const a = i.length / 3,
          l = t.extractPoints(e);
        let c = l.shape;
        const h = l.holes;
        !1 === ch.isClockWise(c) && (c = c.reverse());
        for (let e = 0, n = h.length; e < n; e++) {
          const t = h[e];
          !0 === ch.isClockWise(t) && (h[e] = t.reverse());
        }
        const u = ch.triangulateShape(c, h);
        for (let e = 0, n = h.length; e < n; e++) {
          const t = h[e];
          c = c.concat(t);
        }
        for (let e = 0, n = c.length; e < n; e++) {
          const t = c[e];
          i.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y);
        }
        for (let e = 0, i = u.length; e < i; e++) {
          const t = u[e],
            i = t[0] + a,
            r = t[1] + a,
            s = t[2] + a;
          n.push(i, r, s), (o += 3);
        }
      }
      this.setIndex(n),
        this.setAttribute("position", new pr(i, 3)),
        this.setAttribute("normal", new pr(r, 3)),
        this.setAttribute("uv", new pr(s, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    toJSON() {
      const t = super.toJSON();
      return (function (t, e) {
        if (((e.shapes = []), Array.isArray(t)))
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            e.shapes.push(i.uuid);
          }
        else e.shapes.push(t.uuid);
        return e;
      })(this.parameters.shapes, t);
    }
    static fromJSON(t, e) {
      const n = [];
      for (let i = 0, r = t.shapes.length; i < r; i++) {
        const r = e[t.shapes[i]];
        n.push(r);
      }
      return new vh(n, t.curveSegments);
    }
  }
  class _h extends Mr {
    constructor(
      t = 1,
      e = 32,
      n = 16,
      i = 0,
      r = 2 * Math.PI,
      s = 0,
      a = Math.PI,
    ) {
      super(),
        (this.type = "SphereGeometry"),
        (this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: i,
          phiLength: r,
          thetaStart: s,
          thetaLength: a,
        }),
        (e = Math.max(3, Math.floor(e))),
        (n = Math.max(2, Math.floor(n)));
      const o = Math.min(s + a, Math.PI);
      let l = 0;
      const c = [],
        h = new Nn(),
        u = new Nn(),
        d = [],
        p = [],
        f = [],
        m = [];
      for (let g = 0; g <= n; g++) {
        const d = [],
          v = g / n;
        let _ = 0;
        0 === g && 0 === s
          ? (_ = 0.5 / e)
          : g === n && o === Math.PI && (_ = -0.5 / e);
        for (let n = 0; n <= e; n++) {
          const o = n / e;
          (h.x = -t * Math.cos(i + o * r) * Math.sin(s + v * a)),
            (h.y = t * Math.cos(s + v * a)),
            (h.z = t * Math.sin(i + o * r) * Math.sin(s + v * a)),
            p.push(h.x, h.y, h.z),
            u.copy(h).normalize(),
            f.push(u.x, u.y, u.z),
            m.push(o + _, 1 - v),
            d.push(l++);
        }
        c.push(d);
      }
      for (let g = 0; g < n; g++)
        for (let t = 0; t < e; t++) {
          const e = c[g][t + 1],
            i = c[g][t],
            r = c[g + 1][t],
            a = c[g + 1][t + 1];
          (0 !== g || s > 0) && d.push(e, i, a),
            (g !== n - 1 || o < Math.PI) && d.push(i, r, a);
        }
      this.setIndex(d),
        this.setAttribute("position", new pr(p, 3)),
        this.setAttribute("normal", new pr(f, 3)),
        this.setAttribute("uv", new pr(m, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new _h(
        t.radius,
        t.widthSegments,
        t.heightSegments,
        t.phiStart,
        t.phiLength,
        t.thetaStart,
        t.thetaLength,
      );
    }
  }
  class yh extends Lc {
    constructor(t = 1, e = 0) {
      super(
        [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
        [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
        t,
        e,
      ),
        (this.type = "TetrahedronGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    static fromJSON(t) {
      return new yh(t.radius, t.detail);
    }
  }
  class xh extends Mr {
    constructor(t = 1, e = 0.4, n = 12, i = 48, r = 2 * Math.PI) {
      super(),
        (this.type = "TorusGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: i,
          arc: r,
        }),
        (n = Math.floor(n)),
        (i = Math.floor(i));
      const s = [],
        a = [],
        o = [],
        l = [],
        c = new Nn(),
        h = new Nn(),
        u = new Nn();
      for (let d = 0; d <= n; d++)
        for (let s = 0; s <= i; s++) {
          const p = (s / i) * r,
            f = (d / n) * Math.PI * 2;
          (h.x = (t + e * Math.cos(f)) * Math.cos(p)),
            (h.y = (t + e * Math.cos(f)) * Math.sin(p)),
            (h.z = e * Math.sin(f)),
            a.push(h.x, h.y, h.z),
            (c.x = t * Math.cos(p)),
            (c.y = t * Math.sin(p)),
            u.subVectors(h, c).normalize(),
            o.push(u.x, u.y, u.z),
            l.push(s / i),
            l.push(d / n);
        }
      for (let d = 1; d <= n; d++)
        for (let t = 1; t <= i; t++) {
          const e = (i + 1) * d + t - 1,
            n = (i + 1) * (d - 1) + t - 1,
            r = (i + 1) * (d - 1) + t,
            a = (i + 1) * d + t;
          s.push(e, n, a), s.push(n, r, a);
        }
      this.setIndex(s),
        this.setAttribute("position", new pr(a, 3)),
        this.setAttribute("normal", new pr(o, 3)),
        this.setAttribute("uv", new pr(l, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new xh(
        t.radius,
        t.tube,
        t.radialSegments,
        t.tubularSegments,
        t.arc,
      );
    }
  }
  class Mh extends Mr {
    constructor(t = 1, e = 0.4, n = 64, i = 8, r = 2, s = 3) {
      super(),
        (this.type = "TorusKnotGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: i,
          p: r,
          q: s,
        }),
        (n = Math.floor(n)),
        (i = Math.floor(i));
      const a = [],
        o = [],
        l = [],
        c = [],
        h = new Nn(),
        u = new Nn(),
        d = new Nn(),
        p = new Nn(),
        f = new Nn(),
        m = new Nn(),
        g = new Nn();
      for (let _ = 0; _ <= n; ++_) {
        const a = (_ / n) * r * Math.PI * 2;
        v(a, r, s, t, d),
          v(a + 0.01, r, s, t, p),
          m.subVectors(p, d),
          g.addVectors(p, d),
          f.crossVectors(m, g),
          g.crossVectors(f, m),
          f.normalize(),
          g.normalize();
        for (let t = 0; t <= i; ++t) {
          const r = (t / i) * Math.PI * 2,
            s = -e * Math.cos(r),
            a = e * Math.sin(r);
          (h.x = d.x + (s * g.x + a * f.x)),
            (h.y = d.y + (s * g.y + a * f.y)),
            (h.z = d.z + (s * g.z + a * f.z)),
            o.push(h.x, h.y, h.z),
            u.subVectors(h, d).normalize(),
            l.push(u.x, u.y, u.z),
            c.push(_ / n),
            c.push(t / i);
        }
      }
      for (let _ = 1; _ <= n; _++)
        for (let t = 1; t <= i; t++) {
          const e = (i + 1) * (_ - 1) + (t - 1),
            n = (i + 1) * _ + (t - 1),
            r = (i + 1) * _ + t,
            s = (i + 1) * (_ - 1) + t;
          a.push(e, n, s), a.push(n, r, s);
        }
      function v(t, e, n, i, r) {
        const s = Math.cos(t),
          a = Math.sin(t),
          o = (n / e) * t,
          l = Math.cos(o);
        (r.x = i * (2 + l) * 0.5 * s),
          (r.y = i * (2 + l) * a * 0.5),
          (r.z = i * Math.sin(o) * 0.5);
      }
      this.setIndex(a),
        this.setAttribute("position", new pr(o, 3)),
        this.setAttribute("normal", new pr(l, 3)),
        this.setAttribute("uv", new pr(c, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new Mh(
        t.radius,
        t.tube,
        t.tubularSegments,
        t.radialSegments,
        t.p,
        t.q,
      );
    }
  }
  class Sh extends Mr {
    constructor(
      t = new xc(new Nn(-1, -1, 0), new Nn(-1, 1, 0), new Nn(1, 1, 0)),
      e = 64,
      n = 1,
      i = 8,
      r = !1,
    ) {
      super(),
        (this.type = "TubeGeometry"),
        (this.parameters = {
          path: t,
          tubularSegments: e,
          radius: n,
          radialSegments: i,
          closed: r,
        });
      const s = t.computeFrenetFrames(e, r);
      (this.tangents = s.tangents),
        (this.normals = s.normals),
        (this.binormals = s.binormals);
      const a = new Nn(),
        o = new Nn(),
        l = new sn();
      let c = new Nn();
      const h = [],
        u = [],
        d = [],
        p = [];
      function f(r) {
        c = t.getPointAt(r / e, c);
        const l = s.normals[r],
          d = s.binormals[r];
        for (let t = 0; t <= i; t++) {
          const e = (t / i) * Math.PI * 2,
            r = Math.sin(e),
            s = -Math.cos(e);
          (o.x = s * l.x + r * d.x),
            (o.y = s * l.y + r * d.y),
            (o.z = s * l.z + r * d.z),
            o.normalize(),
            u.push(o.x, o.y, o.z),
            (a.x = c.x + n * o.x),
            (a.y = c.y + n * o.y),
            (a.z = c.z + n * o.z),
            h.push(a.x, a.y, a.z);
        }
      }
      !(function () {
        for (let t = 0; t < e; t++) f(t);
        f(!1 === r ? e : 0),
          (function () {
            for (let t = 0; t <= e; t++)
              for (let n = 0; n <= i; n++)
                (l.x = t / e), (l.y = n / i), d.push(l.x, l.y);
          })(),
          (function () {
            for (let t = 1; t <= e; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * (t - 1) + (e - 1),
                  r = (i + 1) * t + (e - 1),
                  s = (i + 1) * t + e,
                  a = (i + 1) * (t - 1) + e;
                p.push(n, r, a), p.push(r, s, a);
              }
          })();
      })(),
        this.setIndex(p),
        this.setAttribute("position", new pr(h, 3)),
        this.setAttribute("normal", new pr(u, 3)),
        this.setAttribute("uv", new pr(d, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    toJSON() {
      const t = super.toJSON();
      return (t.path = this.parameters.path.toJSON()), t;
    }
    static fromJSON(t) {
      return new Sh(
        new Sc[t.path.type]().fromJSON(t.path),
        t.tubularSegments,
        t.radius,
        t.radialSegments,
        t.closed,
      );
    }
  }
  class bh extends Mr {
    constructor(t = null) {
      if (
        (super(),
        (this.type = "WireframeGeometry"),
        (this.parameters = { geometry: t }),
        null !== t)
      ) {
        const e = [],
          n = new Set(),
          i = new Nn(),
          r = new Nn();
        if (null !== t.index) {
          const s = t.attributes.position,
            a = t.index;
          let o = t.groups;
          0 === o.length &&
            (o = [{ start: 0, count: a.count, materialIndex: 0 }]);
          for (let t = 0, l = o.length; t < l; ++t) {
            const l = o[t],
              c = l.start;
            for (let t = c, o = c + l.count; t < o; t += 3)
              for (let l = 0; l < 3; l++) {
                const o = a.getX(t + l),
                  c = a.getX(t + ((l + 1) % 3));
                i.fromBufferAttribute(s, o),
                  r.fromBufferAttribute(s, c),
                  !0 === Th(i, r, n) &&
                    (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));
              }
          }
        } else {
          const s = t.attributes.position;
          for (let t = 0, a = s.count / 3; t < a; t++)
            for (let o = 0; o < 3; o++) {
              const a = 3 * t + o,
                l = 3 * t + ((o + 1) % 3);
              i.fromBufferAttribute(s, a),
                r.fromBufferAttribute(s, l),
                !0 === Th(i, r, n) &&
                  (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));
            }
        }
        this.setAttribute("position", new pr(e, 3));
      }
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
  }
  function Th(t, e, n) {
    const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
      r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
    return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i), n.add(r), !0);
  }
  var wh = Object.freeze({
    __proto__: null,
    BoxGeometry: Hr,
    CapsuleGeometry: Ec,
    CircleGeometry: Ac,
    ConeGeometry: Cc,
    CylinderGeometry: Rc,
    DodecahedronGeometry: Ic,
    EdgesGeometry: Dc,
    ExtrudeGeometry: dh,
    IcosahedronGeometry: fh,
    LatheGeometry: wc,
    OctahedronGeometry: mh,
    PlaneGeometry: ls,
    PolyhedronGeometry: Lc,
    RingGeometry: gh,
    ShapeGeometry: vh,
    SphereGeometry: _h,
    TetrahedronGeometry: yh,
    TorusGeometry: xh,
    TorusKnotGeometry: Mh,
    TubeGeometry: Sh,
    WireframeGeometry: bh,
  });
  class Eh extends Ki {
    constructor(t) {
      super(),
        (this.isShadowMaterial = !0),
        (this.type = "ShadowMaterial"),
        (this.color = new tr(0)),
        (this.transparent = !0),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), (this.fog = t.fog), this;
    }
  }
  class Ah extends Xr {
    constructor(t) {
      super(t),
        (this.isRawShaderMaterial = !0),
        (this.type = "RawShaderMaterial");
    }
  }
  class Rh extends Ki {
    constructor(t) {
      super(),
        (this.isMeshStandardMaterial = !0),
        (this.defines = { STANDARD: "" }),
        (this.type = "MeshStandardMaterial"),
        (this.color = new tr(16777215)),
        (this.roughness = 1),
        (this.metalness = 0),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new tr(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new sn(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.roughnessMap = null),
        (this.metalnessMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapIntensity = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.defines = { STANDARD: "" }),
        this.color.copy(t.color),
        (this.roughness = t.roughness),
        (this.metalness = t.metalness),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.roughnessMap = t.roughnessMap),
        (this.metalnessMap = t.metalnessMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.envMapIntensity = t.envMapIntensity),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.flatShading = t.flatShading),
        (this.fog = t.fog),
        this
      );
    }
  }
  class Ch extends Rh {
    constructor(t) {
      super(),
        (this.isMeshPhysicalMaterial = !0),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.type = "MeshPhysicalMaterial"),
        (this.anisotropyRotation = 0),
        (this.anisotropyMap = null),
        (this.clearcoatMap = null),
        (this.clearcoatRoughness = 0),
        (this.clearcoatRoughnessMap = null),
        (this.clearcoatNormalScale = new sn(1, 1)),
        (this.clearcoatNormalMap = null),
        (this.ior = 1.5),
        Object.defineProperty(this, "reflectivity", {
          get: function () {
            return Ke((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
          },
          set: function (t) {
            this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
          },
        }),
        (this.iridescenceMap = null),
        (this.iridescenceIOR = 1.3),
        (this.iridescenceThicknessRange = [100, 400]),
        (this.iridescenceThicknessMap = null),
        (this.sheenColor = new tr(0)),
        (this.sheenColorMap = null),
        (this.sheenRoughness = 1),
        (this.sheenRoughnessMap = null),
        (this.transmissionMap = null),
        (this.thickness = 0),
        (this.thicknessMap = null),
        (this.attenuationDistance = 1 / 0),
        (this.attenuationColor = new tr(1, 1, 1)),
        (this.specularIntensity = 1),
        (this.specularIntensityMap = null),
        (this.specularColor = new tr(1, 1, 1)),
        (this.specularColorMap = null),
        (this._anisotropy = 0),
        (this._clearcoat = 0),
        (this._iridescence = 0),
        (this._sheen = 0),
        (this._transmission = 0),
        this.setValues(t);
    }
    get anisotropy() {
      return this._anisotropy;
    }
    set anisotropy(t) {
      this._anisotropy > 0 != t > 0 && this.version++, (this._anisotropy = t);
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(t) {
      this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(t) {
      this._iridescence > 0 != t > 0 && this.version++, (this._iridescence = t);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(t) {
      this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(t) {
      this._transmission > 0 != t > 0 && this.version++,
        (this._transmission = t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.anisotropy = t.anisotropy),
        (this.anisotropyRotation = t.anisotropyRotation),
        (this.anisotropyMap = t.anisotropyMap),
        (this.clearcoat = t.clearcoat),
        (this.clearcoatMap = t.clearcoatMap),
        (this.clearcoatRoughness = t.clearcoatRoughness),
        (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
        (this.clearcoatNormalMap = t.clearcoatNormalMap),
        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
        (this.ior = t.ior),
        (this.iridescence = t.iridescence),
        (this.iridescenceMap = t.iridescenceMap),
        (this.iridescenceIOR = t.iridescenceIOR),
        (this.iridescenceThicknessRange = [...t.iridescenceThicknessRange]),
        (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
        (this.sheen = t.sheen),
        this.sheenColor.copy(t.sheenColor),
        (this.sheenColorMap = t.sheenColorMap),
        (this.sheenRoughness = t.sheenRoughness),
        (this.sheenRoughnessMap = t.sheenRoughnessMap),
        (this.transmission = t.transmission),
        (this.transmissionMap = t.transmissionMap),
        (this.thickness = t.thickness),
        (this.thicknessMap = t.thicknessMap),
        (this.attenuationDistance = t.attenuationDistance),
        this.attenuationColor.copy(t.attenuationColor),
        (this.specularIntensity = t.specularIntensity),
        (this.specularIntensityMap = t.specularIntensityMap),
        this.specularColor.copy(t.specularColor),
        (this.specularColorMap = t.specularColorMap),
        this
      );
    }
  }
  class Lh extends Ki {
    constructor(t) {
      super(),
        (this.isMeshPhongMaterial = !0),
        (this.type = "MeshPhongMaterial"),
        (this.color = new tr(16777215)),
        (this.specular = new tr(1118481)),
        (this.shininess = 30),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new tr(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new sn(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = ct),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        (this.shininess = t.shininess),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.flatShading = t.flatShading),
        (this.fog = t.fog),
        this
      );
    }
  }
  class Ih extends Ki {
    constructor(t) {
      super(),
        (this.isMeshToonMaterial = !0),
        (this.defines = { TOON: "" }),
        (this.type = "MeshToonMaterial"),
        (this.color = new tr(16777215)),
        (this.map = null),
        (this.gradientMap = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new tr(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new sn(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.alphaMap = null),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.gradientMap = t.gradientMap),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.alphaMap = t.alphaMap),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.fog = t.fog),
        this
      );
    }
  }
  class Ph extends Ki {
    constructor(t) {
      super(),
        (this.isMeshNormalMaterial = !0),
        (this.type = "MeshNormalMaterial"),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new sn(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.flatShading = !1),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.flatShading = t.flatShading),
        this
      );
    }
  }
  class Uh extends Ki {
    constructor(t) {
      super(),
        (this.isMeshLambertMaterial = !0),
        (this.type = "MeshLambertMaterial"),
        (this.color = new tr(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new tr(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new sn(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = ct),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.flatShading = t.flatShading),
        (this.fog = t.fog),
        this
      );
    }
  }
  class Nh extends Ki {
    constructor(t) {
      super(),
        (this.isMeshMatcapMaterial = !0),
        (this.defines = { MATCAP: "" }),
        (this.type = "MeshMatcapMaterial"),
        (this.color = new tr(16777215)),
        (this.matcap = null),
        (this.map = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new sn(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.alphaMap = null),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.defines = { MATCAP: "" }),
        this.color.copy(t.color),
        (this.matcap = t.matcap),
        (this.map = t.map),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.alphaMap = t.alphaMap),
        (this.flatShading = t.flatShading),
        (this.fog = t.fog),
        this
      );
    }
  }
  class Oh extends Bl {
    constructor(t) {
      super(),
        (this.isLineDashedMaterial = !0),
        (this.type = "LineDashedMaterial"),
        (this.scale = 1),
        (this.dashSize = 3),
        (this.gapSize = 1),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.scale = t.scale),
        (this.dashSize = t.dashSize),
        (this.gapSize = t.gapSize),
        this
      );
    }
  }
  function Dh(t, e, n) {
    return Bh(t)
      ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
      : t.slice(e, n);
  }
  function Fh(t, e, n) {
    return !t || (!n && t.constructor === e)
      ? t
      : "number" == typeof e.BYTES_PER_ELEMENT
      ? new e(t)
      : Array.prototype.slice.call(t);
  }
  function Bh(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  }
  function zh(t) {
    const e = t.length,
      n = new Array(e);
    for (let i = 0; i !== e; ++i) n[i] = i;
    return (
      n.sort(function (e, n) {
        return t[e] - t[n];
      }),
      n
    );
  }
  function kh(t, e, n) {
    const i = t.length,
      r = new t.constructor(i);
    for (let s = 0, a = 0; a !== i; ++s) {
      const i = n[s] * e;
      for (let n = 0; n !== e; ++n) r[a++] = t[i + n];
    }
    return r;
  }
  function Hh(t, e, n, i) {
    let r = 1,
      s = t[0];
    for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];
    if (void 0 === s) return;
    let a = s[i];
    if (void 0 !== a)
      if (Array.isArray(a))
        do {
          (a = s[i]),
            void 0 !== a && (e.push(s.time), n.push.apply(n, a)),
            (s = t[r++]);
        } while (void 0 !== s);
      else if (void 0 !== a.toArray)
        do {
          (a = s[i]),
            void 0 !== a && (e.push(s.time), a.toArray(n, n.length)),
            (s = t[r++]);
        } while (void 0 !== s);
      else
        do {
          (a = s[i]), void 0 !== a && (e.push(s.time), n.push(a)), (s = t[r++]);
        } while (void 0 !== s);
  }
  const Gh = {
    arraySlice: Dh,
    convertArray: Fh,
    isTypedArray: Bh,
    getKeyframeOrder: zh,
    sortedArray: kh,
    flattenJSON: Hh,
    subclip: function (t, e, n, i, r = 30) {
      const s = t.clone();
      s.name = e;
      const a = [];
      for (let l = 0; l < s.tracks.length; ++l) {
        const t = s.tracks[l],
          e = t.getValueSize(),
          o = [],
          c = [];
        for (let s = 0; s < t.times.length; ++s) {
          const a = t.times[s] * r;
          if (!(a < n || a >= i)) {
            o.push(t.times[s]);
            for (let n = 0; n < e; ++n) c.push(t.values[s * e + n]);
          }
        }
        0 !== o.length &&
          ((t.times = Fh(o, t.times.constructor)),
          (t.values = Fh(c, t.values.constructor)),
          a.push(t));
      }
      s.tracks = a;
      let o = 1 / 0;
      for (let l = 0; l < s.tracks.length; ++l)
        o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
      for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * o);
      return s.resetDuration(), s;
    },
    makeClipAdditive: function (t, e = 0, n = t, i = 30) {
      i <= 0 && (i = 30);
      const r = n.tracks.length,
        s = e / i;
      for (let a = 0; a < r; ++a) {
        const e = n.tracks[a],
          i = e.ValueTypeName;
        if ("bool" === i || "string" === i) continue;
        const r = t.tracks.find(function (t) {
          return t.name === e.name && t.ValueTypeName === i;
        });
        if (void 0 === r) continue;
        let o = 0;
        const l = e.getValueSize();
        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
          (o = l / 3);
        let c = 0;
        const h = r.getValueSize();
        r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
          (c = h / 3);
        const u = e.times.length - 1;
        let d;
        if (s <= e.times[0]) {
          const t = o,
            n = l - o;
          d = Dh(e.values, t, n);
        } else if (s >= e.times[u]) {
          const t = u * l + o,
            n = t + l - o;
          d = Dh(e.values, t, n);
        } else {
          const t = e.createInterpolant(),
            n = o,
            i = l - o;
          t.evaluate(s), (d = Dh(t.resultBuffer, n, i));
        }
        if ("quaternion" === i) {
          new Un().fromArray(d).normalize().conjugate().toArray(d);
        }
        const p = r.times.length;
        for (let t = 0; t < p; ++t) {
          const e = t * h + c;
          if ("quaternion" === i)
            Un.multiplyQuaternionsFlat(r.values, e, d, 0, r.values, e);
          else {
            const t = h - 2 * c;
            for (let n = 0; n < t; ++n) r.values[e + n] -= d[n];
          }
        }
      }
      return (t.blendMode = Le), t;
    },
  };
  class Vh {
    constructor(t, e, n, i) {
      (this.parameterPositions = t),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
        (this.sampleValues = e),
        (this.valueSize = n),
        (this.settings = null),
        (this.DefaultSettings_ = {});
    }
    evaluate(t) {
      const e = this.parameterPositions;
      let n = this._cachedIndex,
        i = e[n],
        r = e[n - 1];
      t: {
        e: {
          let s;
          n: {
            i: if (!(t < i)) {
              for (let s = n + 2; ; ) {
                if (void 0 === i) {
                  if (t < r) break i;
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.copySampleValue_(n - 1)
                  );
                }
                if (n === s) break;
                if (((r = i), (i = e[++n]), t < i)) break e;
              }
              s = e.length;
              break n;
            }
            if (t >= r) break t;
            {
              const a = e[1];
              t < a && ((n = 2), (r = a));
              for (let s = n - 2; ; ) {
                if (void 0 === r)
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (n === s) break;
                if (((i = r), (r = e[--n - 1]), t >= r)) break e;
              }
              (s = n), (n = 0);
            }
          }
          for (; n < s; ) {
            const i = (n + s) >>> 1;
            t < e[i] ? (s = i) : (n = i + 1);
          }
          if (((i = e[n]), (r = e[n - 1]), void 0 === r))
            return (this._cachedIndex = 0), this.copySampleValue_(0);
          if (void 0 === i)
            return (
              (n = e.length),
              (this._cachedIndex = n),
              this.copySampleValue_(n - 1)
            );
        }
        (this._cachedIndex = n), this.intervalChanged_(n, r, i);
      }
      return this.interpolate_(n, r, t, i);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t) {
      const e = this.resultBuffer,
        n = this.sampleValues,
        i = this.valueSize,
        r = t * i;
      for (let s = 0; s !== i; ++s) e[s] = n[r + s];
      return e;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {}
  }
  class Wh extends Vh {
    constructor(t, e, n, i) {
      super(t, e, n, i),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0),
        (this.DefaultSettings_ = { endingStart: Ee, endingEnd: Ee });
    }
    intervalChanged_(t, e, n) {
      const i = this.parameterPositions;
      let r = t - 2,
        s = t + 1,
        a = i[r],
        o = i[s];
      if (void 0 === a)
        switch (this.getSettings_().endingStart) {
          case Ae:
            (r = t), (a = 2 * e - n);
            break;
          case Re:
            (r = i.length - 2), (a = e + i[r] - i[r + 1]);
            break;
          default:
            (r = t), (a = n);
        }
      if (void 0 === o)
        switch (this.getSettings_().endingEnd) {
          case Ae:
            (s = t), (o = 2 * n - e);
            break;
          case Re:
            (s = 1), (o = n + i[1] - i[0]);
            break;
          default:
            (s = t - 1), (o = e);
        }
      const l = 0.5 * (n - e),
        c = this.valueSize;
      (this._weightPrev = l / (e - a)),
        (this._weightNext = l / (o - n)),
        (this._offsetPrev = r * c),
        (this._offsetNext = s * c);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        c = this._offsetPrev,
        h = this._offsetNext,
        u = this._weightPrev,
        d = this._weightNext,
        p = (n - e) / (i - e),
        f = p * p,
        m = f * p,
        g = -u * m + 2 * u * f - u * p,
        v = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
        _ = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
        y = d * m - d * f;
      for (let x = 0; x !== a; ++x)
        r[x] = g * s[c + x] + v * s[l + x] + _ * s[o + x] + y * s[h + x];
      return r;
    }
  }
  class jh extends Vh {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        c = (n - e) / (i - e),
        h = 1 - c;
      for (let u = 0; u !== a; ++u) r[u] = s[l + u] * h + s[o + u] * c;
      return r;
    }
  }
  class Xh extends Vh {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t) {
      return this.copySampleValue_(t - 1);
    }
  }
  class qh {
    constructor(t, e, n, i) {
      if (void 0 === t)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + t,
        );
      (this.name = t),
        (this.times = Fh(e, this.TimeBufferType)),
        (this.values = Fh(n, this.ValueBufferType)),
        this.setInterpolation(i || this.DefaultInterpolation);
    }
    static toJSON(t) {
      const e = t.constructor;
      let n;
      if (e.toJSON !== this.toJSON) n = e.toJSON(t);
      else {
        n = {
          name: t.name,
          times: Fh(t.times, Array),
          values: Fh(t.values, Array),
        };
        const e = t.getInterpolation();
        e !== t.DefaultInterpolation && (n.interpolation = e);
      }
      return (n.type = t.ValueTypeName), n;
    }
    InterpolantFactoryMethodDiscrete(t) {
      return new Xh(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodLinear(t) {
      return new jh(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodSmooth(t) {
      return new Wh(this.times, this.values, this.getValueSize(), t);
    }
    setInterpolation(t) {
      let e;
      switch (t) {
        case be:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case Te:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case we:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === e) {
        const e =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(e);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return (this.createInterpolant = e), this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return be;
        case this.InterpolantFactoryMethodLinear:
          return Te;
        case this.InterpolantFactoryMethodSmooth:
          return we;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t) {
      if (0 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
      }
      return this;
    }
    scale(t) {
      if (1 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
      }
      return this;
    }
    trim(t, e) {
      const n = this.times,
        i = n.length;
      let r = 0,
        s = i - 1;
      for (; r !== i && n[r] < t; ) ++r;
      for (; -1 !== s && n[s] > e; ) --s;
      if ((++s, 0 !== r || s !== i)) {
        r >= s && ((s = Math.max(s, 1)), (r = s - 1));
        const t = this.getValueSize();
        (this.times = Dh(n, r, s)),
          (this.values = Dh(this.values, r * t, s * t));
      }
      return this;
    }
    validate() {
      let t = !0;
      const e = this.getValueSize();
      e - Math.floor(e) != 0 &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this,
        ),
        (t = !1));
      const n = this.times,
        i = this.values,
        r = n.length;
      0 === r &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
      let s = null;
      for (let a = 0; a !== r; a++) {
        const e = n[a];
        if ("number" == typeof e && isNaN(e)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            a,
            e,
          ),
            (t = !1);
          break;
        }
        if (null !== s && s > e) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            a,
            e,
            s,
          ),
            (t = !1);
          break;
        }
        s = e;
      }
      if (void 0 !== i && Bh(i))
        for (let a = 0, o = i.length; a !== o; ++a) {
          const e = i[a];
          if (isNaN(e)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              a,
              e,
            ),
              (t = !1);
            break;
          }
        }
      return t;
    }
    optimize() {
      const t = Dh(this.times),
        e = Dh(this.values),
        n = this.getValueSize(),
        i = this.getInterpolation() === we,
        r = t.length - 1;
      let s = 1;
      for (let a = 1; a < r; ++a) {
        let r = !1;
        const o = t[a];
        if (o !== t[a + 1] && (1 !== a || o !== t[0]))
          if (i) r = !0;
          else {
            const t = a * n,
              i = t - n,
              s = t + n;
            for (let a = 0; a !== n; ++a) {
              const n = e[t + a];
              if (n !== e[i + a] || n !== e[s + a]) {
                r = !0;
                break;
              }
            }
          }
        if (r) {
          if (a !== s) {
            t[s] = t[a];
            const i = a * n,
              r = s * n;
            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
          }
          ++s;
        }
      }
      if (r > 0) {
        t[s] = t[r];
        for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
        ++s;
      }
      return (
        s !== t.length
          ? ((this.times = Dh(t, 0, s)), (this.values = Dh(e, 0, s * n)))
          : ((this.times = t), (this.values = e)),
        this
      );
    }
    clone() {
      const t = Dh(this.times, 0),
        e = Dh(this.values, 0),
        n = new (0, this.constructor)(this.name, t, e);
      return (n.createInterpolant = this.createInterpolant), n;
    }
  }
  (qh.prototype.TimeBufferType = Float32Array),
    (qh.prototype.ValueBufferType = Float32Array),
    (qh.prototype.DefaultInterpolation = Te);
  class Yh extends qh {}
  (Yh.prototype.ValueTypeName = "bool"),
    (Yh.prototype.ValueBufferType = Array),
    (Yh.prototype.DefaultInterpolation = be),
    (Yh.prototype.InterpolantFactoryMethodLinear = void 0),
    (Yh.prototype.InterpolantFactoryMethodSmooth = void 0);
  class Kh extends qh {}
  Kh.prototype.ValueTypeName = "color";
  class Zh extends qh {}
  Zh.prototype.ValueTypeName = "number";
  class Jh extends Vh {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = (n - e) / (i - e);
      let l = t * a;
      for (let c = l + a; l !== c; l += 4)
        Un.slerpFlat(r, 0, s, l - a, s, l, o);
      return r;
    }
  }
  class $h extends qh {
    InterpolantFactoryMethodLinear(t) {
      return new Jh(this.times, this.values, this.getValueSize(), t);
    }
  }
  ($h.prototype.ValueTypeName = "quaternion"),
    ($h.prototype.DefaultInterpolation = Te),
    ($h.prototype.InterpolantFactoryMethodSmooth = void 0);
  class Qh extends qh {}
  (Qh.prototype.ValueTypeName = "string"),
    (Qh.prototype.ValueBufferType = Array),
    (Qh.prototype.DefaultInterpolation = be),
    (Qh.prototype.InterpolantFactoryMethodLinear = void 0),
    (Qh.prototype.InterpolantFactoryMethodSmooth = void 0);
  class tu extends qh {}
  tu.prototype.ValueTypeName = "vector";
  class eu {
    constructor(t, e = -1, n, i = 2500) {
      (this.name = t),
        (this.tracks = n),
        (this.duration = e),
        (this.blendMode = i),
        (this.uuid = Ye()),
        this.duration < 0 && this.resetDuration();
    }
    static parse(t) {
      const e = [],
        n = t.tracks,
        i = 1 / (t.fps || 1);
      for (let s = 0, a = n.length; s !== a; ++s) e.push(nu(n[s]).scale(i));
      const r = new this(t.name, t.duration, e, t.blendMode);
      return (r.uuid = t.uuid), r;
    }
    static toJSON(t) {
      const e = [],
        n = t.tracks,
        i = {
          name: t.name,
          duration: t.duration,
          tracks: e,
          uuid: t.uuid,
          blendMode: t.blendMode,
        };
      for (let r = 0, s = n.length; r !== s; ++r) e.push(qh.toJSON(n[r]));
      return i;
    }
    static CreateFromMorphTargetSequence(t, e, n, i) {
      const r = e.length,
        s = [];
      for (let a = 0; a < r; a++) {
        let t = [],
          o = [];
        t.push((a + r - 1) % r, a, (a + 1) % r), o.push(0, 1, 0);
        const l = zh(t);
        (t = kh(t, 1, l)),
          (o = kh(o, 1, l)),
          i || 0 !== t[0] || (t.push(r), o.push(o[0])),
          s.push(
            new Zh(".morphTargetInfluences[" + e[a].name + "]", t, o).scale(
              1 / n,
            ),
          );
      }
      return new this(t, -1, s);
    }
    static findByName(t, e) {
      let n = t;
      if (!Array.isArray(t)) {
        const e = t;
        n = (e.geometry && e.geometry.animations) || e.animations;
      }
      for (let i = 0; i < n.length; i++) if (n[i].name === e) return n[i];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(t, e, n) {
      const i = {},
        r = /^([\w-]*?)([\d]+)$/;
      for (let a = 0, o = t.length; a < o; a++) {
        const e = t[a],
          n = e.name.match(r);
        if (n && n.length > 1) {
          const t = n[1];
          let r = i[t];
          r || (i[t] = r = []), r.push(e);
        }
      }
      const s = [];
      for (const a in i)
        s.push(this.CreateFromMorphTargetSequence(a, i[a], e, n));
      return s;
    }
    static parseAnimation(t, e) {
      if (!t)
        return (
          console.error(
            "THREE.AnimationClip: No animation in JSONLoader data.",
          ),
          null
        );
      const n = function (t, e, n, i, r) {
          if (0 !== n.length) {
            const s = [],
              a = [];
            Hh(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a));
          }
        },
        i = [],
        r = t.name || "default",
        s = t.fps || 30,
        a = t.blendMode;
      let o = t.length || -1;
      const l = t.hierarchy || [];
      for (let c = 0; c < l.length; c++) {
        const t = l[c].keys;
        if (t && 0 !== t.length)
          if (t[0].morphTargets) {
            const e = {};
            let n;
            for (n = 0; n < t.length; n++)
              if (t[n].morphTargets)
                for (let i = 0; i < t[n].morphTargets.length; i++)
                  e[t[n].morphTargets[i]] = -1;
            for (const r in e) {
              const e = [],
                s = [];
              for (let i = 0; i !== t[n].morphTargets.length; ++i) {
                const i = t[n];
                e.push(i.time), s.push(i.morphTarget === r ? 1 : 0);
              }
              i.push(new Zh(".morphTargetInfluence[" + r + "]", e, s));
            }
            o = e.length * s;
          } else {
            const r = ".bones[" + e[c].name + "]";
            n(tu, r + ".position", t, "pos", i),
              n($h, r + ".quaternion", t, "rot", i),
              n(tu, r + ".scale", t, "scl", i);
          }
      }
      if (0 === i.length) return null;
      return new this(r, o, i, a);
    }
    resetDuration() {
      let t = 0;
      for (let e = 0, n = this.tracks.length; e !== n; ++e) {
        const n = this.tracks[e];
        t = Math.max(t, n.times[n.times.length - 1]);
      }
      return (this.duration = t), this;
    }
    trim() {
      for (let t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this;
    }
    validate() {
      let t = !0;
      for (let e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t;
    }
    optimize() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
      return this;
    }
    clone() {
      const t = [];
      for (let e = 0; e < this.tracks.length; e++)
        t.push(this.tracks[e].clone());
      return new this.constructor(this.name, this.duration, t, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function nu(t) {
    if (void 0 === t.type)
      throw new Error(
        "THREE.KeyframeTrack: track type undefined, can not parse",
      );
    const e = (function (t) {
      switch (t.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return Zh;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return tu;
        case "color":
          return Kh;
        case "quaternion":
          return $h;
        case "bool":
        case "boolean":
          return Yh;
        case "string":
          return Qh;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
    })(t.type);
    if (void 0 === t.times) {
      const e = [],
        n = [];
      Hh(t.keys, e, n, "value"), (t.times = e), (t.values = n);
    }
    return void 0 !== e.parse
      ? e.parse(t)
      : new e(t.name, t.times, t.values, t.interpolation);
  }
  const iu = {
    enabled: !1,
    files: {},
    add: function (t, e) {
      !1 !== this.enabled && (this.files[t] = e);
    },
    get: function (t) {
      if (!1 !== this.enabled) return this.files[t];
    },
    remove: function (t) {
      delete this.files[t];
    },
    clear: function () {
      this.files = {};
    },
  };
  class ru {
    constructor(t, e, n) {
      const i = this;
      let r,
        s = !1,
        a = 0,
        o = 0;
      const l = [];
      (this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = e),
        (this.onError = n),
        (this.itemStart = function (t) {
          o++, !1 === s && void 0 !== i.onStart && i.onStart(t, a, o), (s = !0);
        }),
        (this.itemEnd = function (t) {
          a++,
            void 0 !== i.onProgress && i.onProgress(t, a, o),
            a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
        }),
        (this.itemError = function (t) {
          void 0 !== i.onError && i.onError(t);
        }),
        (this.resolveURL = function (t) {
          return r ? r(t) : t;
        }),
        (this.setURLModifier = function (t) {
          return (r = t), this;
        }),
        (this.addHandler = function (t, e) {
          return l.push(t, e), this;
        }),
        (this.removeHandler = function (t) {
          const e = l.indexOf(t);
          return -1 !== e && l.splice(e, 2), this;
        }),
        (this.getHandler = function (t) {
          for (let e = 0, n = l.length; e < n; e += 2) {
            const n = l[e],
              i = l[e + 1];
            if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
          }
          return null;
        });
    }
  }
  const su = new ru();
  class au {
    constructor(t) {
      (this.manager = void 0 !== t ? t : su),
        (this.crossOrigin = "anonymous"),
        (this.withCredentials = !1),
        (this.path = ""),
        (this.resourcePath = ""),
        (this.requestHeader = {});
    }
    load() {}
    loadAsync(t, e) {
      const n = this;
      return new Promise(function (i, r) {
        n.load(t, i, e, r);
      });
    }
    parse() {}
    setCrossOrigin(t) {
      return (this.crossOrigin = t), this;
    }
    setWithCredentials(t) {
      return (this.withCredentials = t), this;
    }
    setPath(t) {
      return (this.path = t), this;
    }
    setResourcePath(t) {
      return (this.resourcePath = t), this;
    }
    setRequestHeader(t) {
      return (this.requestHeader = t), this;
    }
  }
  au.DEFAULT_MATERIAL_NAME = "__DEFAULT";
  const ou = {};
  class lu extends Error {
    constructor(t, e) {
      super(t), (this.response = e);
    }
  }
  class cu extends au {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = iu.get(t);
      if (void 0 !== r)
        return (
          this.manager.itemStart(t),
          setTimeout(() => {
            e && e(r), this.manager.itemEnd(t);
          }, 0),
          r
        );
      if (void 0 !== ou[t])
        return void ou[t].push({ onLoad: e, onProgress: n, onError: i });
      (ou[t] = []), ou[t].push({ onLoad: e, onProgress: n, onError: i });
      const s = new Request(t, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin",
        }),
        a = this.mimeType,
        o = this.responseType;
      fetch(s)
        .then((e) => {
          if (200 === e.status || 0 === e.status) {
            if (
              (0 === e.status &&
                console.warn("THREE.FileLoader: HTTP Status 0 received."),
              "undefined" == typeof ReadableStream ||
                void 0 === e.body ||
                void 0 === e.body.getReader)
            )
              return e;
            const n = ou[t],
              i = e.body.getReader(),
              r =
                e.headers.get("Content-Length") || e.headers.get("X-File-Size"),
              s = r ? parseInt(r) : 0,
              a = 0 !== s;
            let o = 0;
            const l = new ReadableStream({
              start(t) {
                !(function e() {
                  i.read().then(({ done: i, value: r }) => {
                    if (i) t.close();
                    else {
                      o += r.byteLength;
                      const i = new ProgressEvent("progress", {
                        lengthComputable: a,
                        loaded: o,
                        total: s,
                      });
                      for (let t = 0, e = n.length; t < e; t++) {
                        const e = n[t];
                        e.onProgress && e.onProgress(i);
                      }
                      t.enqueue(r), e();
                    }
                  });
                })();
              },
            });
            return new Response(l);
          }
          throw new lu(
            `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,
            e,
          );
        })
        .then((t) => {
          switch (o) {
            case "arraybuffer":
              return t.arrayBuffer();
            case "blob":
              return t.blob();
            case "document":
              return t
                .text()
                .then((t) => new DOMParser().parseFromString(t, a));
            case "json":
              return t.json();
            default:
              if (void 0 === a) return t.text();
              {
                const e = /charset="?([^;"\s]*)"?/i.exec(a),
                  n = e && e[1] ? e[1].toLowerCase() : void 0,
                  i = new TextDecoder(n);
                return t.arrayBuffer().then((t) => i.decode(t));
              }
          }
        })
        .then((e) => {
          iu.add(t, e);
          const n = ou[t];
          delete ou[t];
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            i.onLoad && i.onLoad(e);
          }
        })
        .catch((e) => {
          const n = ou[t];
          if (void 0 === n) throw (this.manager.itemError(t), e);
          delete ou[t];
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            i.onError && i.onError(e);
          }
          this.manager.itemError(t);
        })
        .finally(() => {
          this.manager.itemEnd(t);
        }),
        this.manager.itemStart(t);
    }
    setResponseType(t) {
      return (this.responseType = t), this;
    }
    setMimeType(t) {
      return (this.mimeType = t), this;
    }
  }
  class hu extends au {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = this,
        s = iu.get(t);
      if (void 0 !== s)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(s), r.manager.itemEnd(t);
          }, 0),
          s
        );
      const a = un("img");
      function o() {
        c(), iu.add(t, this), e && e(this), r.manager.itemEnd(t);
      }
      function l(e) {
        c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
      }
      function c() {
        a.removeEventListener("load", o, !1),
          a.removeEventListener("error", l, !1);
      }
      return (
        a.addEventListener("load", o, !1),
        a.addEventListener("error", l, !1),
        "data:" !== t.slice(0, 5) &&
          void 0 !== this.crossOrigin &&
          (a.crossOrigin = this.crossOrigin),
        r.manager.itemStart(t),
        (a.src = t),
        a
      );
    }
  }
  class uu extends au {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      const r = new An(),
        s = new hu(this.manager);
      return (
        s.setCrossOrigin(this.crossOrigin),
        s.setPath(this.path),
        s.load(
          t,
          function (t) {
            (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
          },
          n,
          i,
        ),
        r
      );
    }
  }
  class du extends Oi {
    constructor(t, e = 1) {
      super(),
        (this.isLight = !0),
        (this.type = "Light"),
        (this.color = new tr(t)),
        (this.intensity = e);
    }
    dispose() {}
    copy(t, e) {
      return (
        super.copy(t, e),
        this.color.copy(t.color),
        (this.intensity = t.intensity),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.color = this.color.getHex()),
        (e.object.intensity = this.intensity),
        void 0 !== this.groundColor &&
          (e.object.groundColor = this.groundColor.getHex()),
        void 0 !== this.distance && (e.object.distance = this.distance),
        void 0 !== this.angle && (e.object.angle = this.angle),
        void 0 !== this.decay && (e.object.decay = this.decay),
        void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
        void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
        e
      );
    }
  }
  class pu extends du {
    constructor(t, e, n) {
      super(t, n),
        (this.isHemisphereLight = !0),
        (this.type = "HemisphereLight"),
        this.position.copy(Oi.DEFAULT_UP),
        this.updateMatrix(),
        (this.groundColor = new tr(e));
    }
    copy(t, e) {
      return super.copy(t, e), this.groundColor.copy(t.groundColor), this;
    }
  }
  const fu = new hi(),
    mu = new Nn(),
    gu = new Nn();
  class vu {
    constructor(t) {
      (this.camera = t),
        (this.bias = 0),
        (this.normalBias = 0),
        (this.radius = 1),
        (this.blurSamples = 8),
        (this.mapSize = new sn(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new hi()),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this._frustum = new ss()),
        (this._frameExtents = new sn(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new Rn(0, 0, 1, 1)]);
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(t) {
      const e = this.camera,
        n = this.matrix;
      mu.setFromMatrixPosition(t.matrixWorld),
        e.position.copy(mu),
        gu.setFromMatrixPosition(t.target.matrixWorld),
        e.lookAt(gu),
        e.updateMatrixWorld(),
        fu.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(fu),
        n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        n.multiply(fu);
    }
    getViewport(t) {
      return this._viewports[t];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t) {
      return (
        (this.camera = t.camera.clone()),
        (this.bias = t.bias),
        (this.radius = t.radius),
        this.mapSize.copy(t.mapSize),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t = {};
      return (
        0 !== this.bias && (t.bias = this.bias),
        0 !== this.normalBias && (t.normalBias = this.normalBias),
        1 !== this.radius && (t.radius = this.radius),
        (512 === this.mapSize.x && 512 === this.mapSize.y) ||
          (t.mapSize = this.mapSize.toArray()),
        (t.camera = this.camera.toJSON(!1).object),
        delete t.camera.matrix,
        t
      );
    }
  }
  class _u extends vu {
    constructor() {
      super(new Yr(50, 1, 0.5, 500)),
        (this.isSpotLightShadow = !0),
        (this.focus = 1);
    }
    updateMatrices(t) {
      const e = this.camera,
        n = 2 * qe * t.angle * this.focus,
        i = this.mapSize.width / this.mapSize.height,
        r = t.distance || e.far;
      (n === e.fov && i === e.aspect && r === e.far) ||
        ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
        super.updateMatrices(t);
    }
    copy(t) {
      return super.copy(t), (this.focus = t.focus), this;
    }
  }
  class yu extends du {
    constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 2) {
      super(t, e),
        (this.isSpotLight = !0),
        (this.type = "SpotLight"),
        this.position.copy(Oi.DEFAULT_UP),
        this.updateMatrix(),
        (this.target = new Oi()),
        (this.distance = n),
        (this.angle = i),
        (this.penumbra = r),
        (this.decay = s),
        (this.map = null),
        (this.shadow = new _u());
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.distance = t.distance),
        (this.angle = t.angle),
        (this.penumbra = t.penumbra),
        (this.decay = t.decay),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  const xu = new hi(),
    Mu = new Nn(),
    Su = new Nn();
  class bu extends vu {
    constructor() {
      super(new Yr(90, 1, 0.5, 500)),
        (this.isPointLightShadow = !0),
        (this._frameExtents = new sn(4, 2)),
        (this._viewportCount = 6),
        (this._viewports = [
          new Rn(2, 1, 1, 1),
          new Rn(0, 1, 1, 1),
          new Rn(3, 1, 1, 1),
          new Rn(1, 1, 1, 1),
          new Rn(3, 0, 1, 1),
          new Rn(1, 0, 1, 1),
        ]),
        (this._cubeDirections = [
          new Nn(1, 0, 0),
          new Nn(-1, 0, 0),
          new Nn(0, 0, 1),
          new Nn(0, 0, -1),
          new Nn(0, 1, 0),
          new Nn(0, -1, 0),
        ]),
        (this._cubeUps = [
          new Nn(0, 1, 0),
          new Nn(0, 1, 0),
          new Nn(0, 1, 0),
          new Nn(0, 1, 0),
          new Nn(0, 0, 1),
          new Nn(0, 0, -1),
        ]);
    }
    updateMatrices(t, e = 0) {
      const n = this.camera,
        i = this.matrix,
        r = t.distance || n.far;
      r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
        Mu.setFromMatrixPosition(t.matrixWorld),
        n.position.copy(Mu),
        Su.copy(n.position),
        Su.add(this._cubeDirections[e]),
        n.up.copy(this._cubeUps[e]),
        n.lookAt(Su),
        n.updateMatrixWorld(),
        i.makeTranslation(-Mu.x, -Mu.y, -Mu.z),
        xu.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(xu);
    }
  }
  class Tu extends du {
    constructor(t, e, n = 0, i = 2) {
      super(t, e),
        (this.isPointLight = !0),
        (this.type = "PointLight"),
        (this.distance = n),
        (this.decay = i),
        (this.shadow = new bu());
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.distance = t.distance),
        (this.decay = t.decay),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  class wu extends vu {
    constructor() {
      super(new ys(-5, 5, 5, -5, 0.5, 500)),
        (this.isDirectionalLightShadow = !0);
    }
  }
  class Eu extends du {
    constructor(t, e) {
      super(t, e),
        (this.isDirectionalLight = !0),
        (this.type = "DirectionalLight"),
        this.position.copy(Oi.DEFAULT_UP),
        this.updateMatrix(),
        (this.target = new Oi()),
        (this.shadow = new wu());
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return (
        super.copy(t),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  class Au extends du {
    constructor(t, e) {
      super(t, e), (this.isAmbientLight = !0), (this.type = "AmbientLight");
    }
  }
  class Ru extends du {
    constructor(t, e, n = 10, i = 10) {
      super(t, e),
        (this.isRectAreaLight = !0),
        (this.type = "RectAreaLight"),
        (this.width = n),
        (this.height = i);
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(t) {
      this.intensity = t / (this.width * this.height * Math.PI);
    }
    copy(t) {
      return (
        super.copy(t), (this.width = t.width), (this.height = t.height), this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (e.object.width = this.width), (e.object.height = this.height), e;
    }
  }
  class Cu {
    constructor() {
      (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
      for (let t = 0; t < 9; t++) this.coefficients.push(new Nn());
    }
    set(t) {
      for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
      return this;
    }
    zero() {
      for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
      return this;
    }
    getAt(t, e) {
      const n = t.x,
        i = t.y,
        r = t.z,
        s = this.coefficients;
      return (
        e.copy(s[0]).multiplyScalar(0.282095),
        e.addScaledVector(s[1], 0.488603 * i),
        e.addScaledVector(s[2], 0.488603 * r),
        e.addScaledVector(s[3], 0.488603 * n),
        e.addScaledVector(s[4], n * i * 1.092548),
        e.addScaledVector(s[5], i * r * 1.092548),
        e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
        e.addScaledVector(s[7], n * r * 1.092548),
        e.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
        e
      );
    }
    getIrradianceAt(t, e) {
      const n = t.x,
        i = t.y,
        r = t.z,
        s = this.coefficients;
      return (
        e.copy(s[0]).multiplyScalar(0.886227),
        e.addScaledVector(s[1], 1.023328 * i),
        e.addScaledVector(s[2], 1.023328 * r),
        e.addScaledVector(s[3], 1.023328 * n),
        e.addScaledVector(s[4], 0.858086 * n * i),
        e.addScaledVector(s[5], 0.858086 * i * r),
        e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
        e.addScaledVector(s[7], 0.858086 * n * r),
        e.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
        e
      );
    }
    add(t) {
      for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
      return this;
    }
    addScaledSH(t, e) {
      for (let n = 0; n < 9; n++)
        this.coefficients[n].addScaledVector(t.coefficients[n], e);
      return this;
    }
    scale(t) {
      for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
      return this;
    }
    lerp(t, e) {
      for (let n = 0; n < 9; n++)
        this.coefficients[n].lerp(t.coefficients[n], e);
      return this;
    }
    equals(t) {
      for (let e = 0; e < 9; e++)
        if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
      return !0;
    }
    copy(t) {
      return this.set(t.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(t, e = 0) {
      const n = this.coefficients;
      for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.coefficients;
      for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
      return t;
    }
    static getBasisAt(t, e) {
      const n = t.x,
        i = t.y,
        r = t.z;
      (e[0] = 0.282095),
        (e[1] = 0.488603 * i),
        (e[2] = 0.488603 * r),
        (e[3] = 0.488603 * n),
        (e[4] = 1.092548 * n * i),
        (e[5] = 1.092548 * i * r),
        (e[6] = 0.315392 * (3 * r * r - 1)),
        (e[7] = 1.092548 * n * r),
        (e[8] = 0.546274 * (n * n - i * i));
    }
  }
  class Lu extends du {
    constructor(t = new Cu(), e = 1) {
      super(void 0, e), (this.isLightProbe = !0), (this.sh = t);
    }
    copy(t) {
      return super.copy(t), this.sh.copy(t.sh), this;
    }
    fromJSON(t) {
      return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (e.object.sh = this.sh.toArray()), e;
    }
  }
  class Iu extends au {
    constructor(t) {
      super(t), (this.textures = {});
    }
    load(t, e, n, i) {
      const r = this,
        s = new cu(r.manager);
      s.setPath(r.path),
        s.setRequestHeader(r.requestHeader),
        s.setWithCredentials(r.withCredentials),
        s.load(
          t,
          function (n) {
            try {
              e(r.parse(JSON.parse(n)));
            } catch (s) {
              i ? i(s) : console.error(s), r.manager.itemError(t);
            }
          },
          n,
          i,
        );
    }
    parse(t) {
      const e = this.textures;
      function n(t) {
        return (
          void 0 === e[t] &&
            console.warn("THREE.MaterialLoader: Undefined texture", t),
          e[t]
        );
      }
      const i = Iu.createMaterialFromType(t.type);
      if (
        (void 0 !== t.uuid && (i.uuid = t.uuid),
        void 0 !== t.name && (i.name = t.name),
        void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color),
        void 0 !== t.roughness && (i.roughness = t.roughness),
        void 0 !== t.metalness && (i.metalness = t.metalness),
        void 0 !== t.sheen && (i.sheen = t.sheen),
        void 0 !== t.sheenColor &&
          (i.sheenColor = new tr().setHex(t.sheenColor)),
        void 0 !== t.sheenRoughness && (i.sheenRoughness = t.sheenRoughness),
        void 0 !== t.emissive &&
          void 0 !== i.emissive &&
          i.emissive.setHex(t.emissive),
        void 0 !== t.specular &&
          void 0 !== i.specular &&
          i.specular.setHex(t.specular),
        void 0 !== t.specularIntensity &&
          (i.specularIntensity = t.specularIntensity),
        void 0 !== t.specularColor &&
          void 0 !== i.specularColor &&
          i.specularColor.setHex(t.specularColor),
        void 0 !== t.shininess && (i.shininess = t.shininess),
        void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
        void 0 !== t.clearcoatRoughness &&
          (i.clearcoatRoughness = t.clearcoatRoughness),
        void 0 !== t.iridescence && (i.iridescence = t.iridescence),
        void 0 !== t.iridescenceIOR && (i.iridescenceIOR = t.iridescenceIOR),
        void 0 !== t.iridescenceThicknessRange &&
          (i.iridescenceThicknessRange = t.iridescenceThicknessRange),
        void 0 !== t.transmission && (i.transmission = t.transmission),
        void 0 !== t.thickness && (i.thickness = t.thickness),
        void 0 !== t.attenuationDistance &&
          (i.attenuationDistance = t.attenuationDistance),
        void 0 !== t.attenuationColor &&
          void 0 !== i.attenuationColor &&
          i.attenuationColor.setHex(t.attenuationColor),
        void 0 !== t.anisotropy && (i.anisotropy = t.anisotropy),
        void 0 !== t.anisotropyRotation &&
          (i.anisotropyRotation = t.anisotropyRotation),
        void 0 !== t.fog && (i.fog = t.fog),
        void 0 !== t.flatShading && (i.flatShading = t.flatShading),
        void 0 !== t.blending && (i.blending = t.blending),
        void 0 !== t.combine && (i.combine = t.combine),
        void 0 !== t.side && (i.side = t.side),
        void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide),
        void 0 !== t.opacity && (i.opacity = t.opacity),
        void 0 !== t.transparent && (i.transparent = t.transparent),
        void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
        void 0 !== t.alphaHash && (i.alphaHash = t.alphaHash),
        void 0 !== t.depthTest && (i.depthTest = t.depthTest),
        void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
        void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
        void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
        void 0 !== t.stencilWriteMask &&
          (i.stencilWriteMask = t.stencilWriteMask),
        void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
        void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
        void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask),
        void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
        void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
        void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
        void 0 !== t.wireframe && (i.wireframe = t.wireframe),
        void 0 !== t.wireframeLinewidth &&
          (i.wireframeLinewidth = t.wireframeLinewidth),
        void 0 !== t.wireframeLinecap &&
          (i.wireframeLinecap = t.wireframeLinecap),
        void 0 !== t.wireframeLinejoin &&
          (i.wireframeLinejoin = t.wireframeLinejoin),
        void 0 !== t.rotation && (i.rotation = t.rotation),
        1 !== t.linewidth && (i.linewidth = t.linewidth),
        void 0 !== t.dashSize && (i.dashSize = t.dashSize),
        void 0 !== t.gapSize && (i.gapSize = t.gapSize),
        void 0 !== t.scale && (i.scale = t.scale),
        void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
        void 0 !== t.polygonOffsetFactor &&
          (i.polygonOffsetFactor = t.polygonOffsetFactor),
        void 0 !== t.polygonOffsetUnits &&
          (i.polygonOffsetUnits = t.polygonOffsetUnits),
        void 0 !== t.dithering && (i.dithering = t.dithering),
        void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage),
        void 0 !== t.premultipliedAlpha &&
          (i.premultipliedAlpha = t.premultipliedAlpha),
        void 0 !== t.forceSinglePass && (i.forceSinglePass = t.forceSinglePass),
        void 0 !== t.visible && (i.visible = t.visible),
        void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
        void 0 !== t.userData && (i.userData = t.userData),
        void 0 !== t.vertexColors &&
          ("number" == typeof t.vertexColors
            ? (i.vertexColors = t.vertexColors > 0)
            : (i.vertexColors = t.vertexColors)),
        void 0 !== t.uniforms)
      )
        for (const r in t.uniforms) {
          const e = t.uniforms[r];
          switch (((i.uniforms[r] = {}), e.type)) {
            case "t":
              i.uniforms[r].value = n(e.value);
              break;
            case "c":
              i.uniforms[r].value = new tr().setHex(e.value);
              break;
            case "v2":
              i.uniforms[r].value = new sn().fromArray(e.value);
              break;
            case "v3":
              i.uniforms[r].value = new Nn().fromArray(e.value);
              break;
            case "v4":
              i.uniforms[r].value = new Rn().fromArray(e.value);
              break;
            case "m3":
              i.uniforms[r].value = new an().fromArray(e.value);
              break;
            case "m4":
              i.uniforms[r].value = new hi().fromArray(e.value);
              break;
            default:
              i.uniforms[r].value = e.value;
          }
        }
      if (
        (void 0 !== t.defines && (i.defines = t.defines),
        void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
        void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader),
        void 0 !== t.glslVersion && (i.glslVersion = t.glslVersion),
        void 0 !== t.extensions)
      )
        for (const r in t.extensions) i.extensions[r] = t.extensions[r];
      if (
        (void 0 !== t.lights && (i.lights = t.lights),
        void 0 !== t.clipping && (i.clipping = t.clipping),
        void 0 !== t.size && (i.size = t.size),
        void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation),
        void 0 !== t.map && (i.map = n(t.map)),
        void 0 !== t.matcap && (i.matcap = n(t.matcap)),
        void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
        void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
        void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
        void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
        void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
        void 0 !== t.normalScale)
      ) {
        let e = t.normalScale;
        !1 === Array.isArray(e) && (e = [e, e]),
          (i.normalScale = new sn().fromArray(e));
      }
      return (
        void 0 !== t.displacementMap &&
          (i.displacementMap = n(t.displacementMap)),
        void 0 !== t.displacementScale &&
          (i.displacementScale = t.displacementScale),
        void 0 !== t.displacementBias &&
          (i.displacementBias = t.displacementBias),
        void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
        void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
        void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
        void 0 !== t.emissiveIntensity &&
          (i.emissiveIntensity = t.emissiveIntensity),
        void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
        void 0 !== t.specularIntensityMap &&
          (i.specularIntensityMap = n(t.specularIntensityMap)),
        void 0 !== t.specularColorMap &&
          (i.specularColorMap = n(t.specularColorMap)),
        void 0 !== t.envMap && (i.envMap = n(t.envMap)),
        void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity),
        void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
        void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio),
        void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
        void 0 !== t.lightMapIntensity &&
          (i.lightMapIntensity = t.lightMapIntensity),
        void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
        void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity),
        void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
        void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
        void 0 !== t.clearcoatRoughnessMap &&
          (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
        void 0 !== t.clearcoatNormalMap &&
          (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
        void 0 !== t.clearcoatNormalScale &&
          (i.clearcoatNormalScale = new sn().fromArray(t.clearcoatNormalScale)),
        void 0 !== t.iridescenceMap && (i.iridescenceMap = n(t.iridescenceMap)),
        void 0 !== t.iridescenceThicknessMap &&
          (i.iridescenceThicknessMap = n(t.iridescenceThicknessMap)),
        void 0 !== t.transmissionMap &&
          (i.transmissionMap = n(t.transmissionMap)),
        void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)),
        void 0 !== t.anisotropyMap && (i.anisotropyMap = n(t.anisotropyMap)),
        void 0 !== t.sheenColorMap && (i.sheenColorMap = n(t.sheenColorMap)),
        void 0 !== t.sheenRoughnessMap &&
          (i.sheenRoughnessMap = n(t.sheenRoughnessMap)),
        i
      );
    }
    setTextures(t) {
      return (this.textures = t), this;
    }
    static createMaterialFromType(t) {
      return new {
        ShadowMaterial: Eh,
        SpriteMaterial: Ko,
        RawShaderMaterial: Ah,
        ShaderMaterial: Xr,
        PointsMaterial: Kl,
        MeshPhysicalMaterial: Ch,
        MeshStandardMaterial: Rh,
        MeshPhongMaterial: Lh,
        MeshToonMaterial: Ih,
        MeshNormalMaterial: Ph,
        MeshLambertMaterial: Uh,
        MeshDepthMaterial: Eo,
        MeshDistanceMaterial: Ao,
        MeshBasicMaterial: nr,
        MeshMatcapMaterial: Nh,
        LineDashedMaterial: Oh,
        LineBasicMaterial: Bl,
        Material: Ki,
      }[t]();
    }
  }
  class Pu {
    static decodeText(t) {
      if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
      let e = "";
      for (let i = 0, r = t.length; i < r; i++) e += String.fromCharCode(t[i]);
      try {
        return decodeURIComponent(escape(e));
      } catch (n) {
        return e;
      }
    }
    static extractUrlBase(t) {
      const e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.slice(0, e + 1);
    }
    static resolveURL(t, e) {
      return "string" != typeof t || "" === t
        ? ""
        : (/^https?:\/\//i.test(e) &&
            /^\//.test(t) &&
            (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(t) ||
          /^data:.*,.*$/i.test(t) ||
          /^blob:.*$/i.test(t)
            ? t
            : e + t);
    }
  }
  class Uu extends Mr {
    constructor() {
      super(),
        (this.isInstancedBufferGeometry = !0),
        (this.type = "InstancedBufferGeometry"),
        (this.instanceCount = 1 / 0);
    }
    copy(t) {
      return super.copy(t), (this.instanceCount = t.instanceCount), this;
    }
    toJSON() {
      const t = super.toJSON();
      return (
        (t.instanceCount = this.instanceCount),
        (t.isInstancedBufferGeometry = !0),
        t
      );
    }
  }
  class Nu extends au {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      const r = this,
        s = new cu(r.manager);
      s.setPath(r.path),
        s.setRequestHeader(r.requestHeader),
        s.setWithCredentials(r.withCredentials),
        s.load(
          t,
          function (n) {
            try {
              e(r.parse(JSON.parse(n)));
            } catch (s) {
              i ? i(s) : console.error(s), r.manager.itemError(t);
            }
          },
          n,
          i,
        );
    }
    parse(t) {
      const e = {},
        n = {};
      function i(t, i) {
        if (void 0 !== e[i]) return e[i];
        const r = t.interleavedBuffers[i],
          s = (function (t, e) {
            if (void 0 !== n[e]) return n[e];
            const i = t.arrayBuffers,
              r = i[e],
              s = new Uint32Array(r).buffer;
            return (n[e] = s), s;
          })(t, r.buffer),
          a = hn(r.type, s),
          o = new Xo(a, r.stride);
        return (o.uuid = r.uuid), (e[i] = o), o;
      }
      const r = t.isInstancedBufferGeometry ? new Uu() : new Mr(),
        s = t.data.index;
      if (void 0 !== s) {
        const t = hn(s.type, s.array);
        r.setIndex(new hr(t, 1));
      }
      const a = t.data.attributes;
      for (const h in a) {
        const e = a[h];
        let n;
        if (e.isInterleavedBufferAttribute) {
          const r = i(t.data, e.data);
          n = new Yo(r, e.itemSize, e.offset, e.normalized);
        } else {
          const t = hn(e.type, e.array);
          n = new (e.isInstancedBufferAttribute ? Cl : hr)(
            t,
            e.itemSize,
            e.normalized,
          );
        }
        void 0 !== e.name && (n.name = e.name),
          void 0 !== e.usage && n.setUsage(e.usage),
          void 0 !== e.updateRange &&
            ((n.updateRange.offset = e.updateRange.offset),
            (n.updateRange.count = e.updateRange.count)),
          r.setAttribute(h, n);
      }
      const o = t.data.morphAttributes;
      if (o)
        for (const h in o) {
          const e = o[h],
            n = [];
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r];
            let a;
            if (s.isInterleavedBufferAttribute) {
              const e = i(t.data, s.data);
              a = new Yo(e, s.itemSize, s.offset, s.normalized);
            } else {
              const t = hn(s.type, s.array);
              a = new hr(t, s.itemSize, s.normalized);
            }
            void 0 !== s.name && (a.name = s.name), n.push(a);
          }
          r.morphAttributes[h] = n;
        }
      t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
      const l = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (void 0 !== l)
        for (let h = 0, u = l.length; h !== u; ++h) {
          const t = l[h];
          r.addGroup(t.start, t.count, t.materialIndex);
        }
      const c = t.data.boundingSphere;
      if (void 0 !== c) {
        const t = new Nn();
        void 0 !== c.center && t.fromArray(c.center),
          (r.boundingSphere = new ei(t, c.radius));
      }
      return (
        t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
      );
    }
  }
  const Ou = {
      UVMapping: _t,
      CubeReflectionMapping: yt,
      CubeRefractionMapping: xt,
      EquirectangularReflectionMapping: Mt,
      EquirectangularRefractionMapping: St,
      CubeUVReflectionMapping: bt,
    },
    Du = {
      RepeatWrapping: Tt,
      ClampToEdgeWrapping: wt,
      MirroredRepeatWrapping: Et,
    },
    Fu = {
      NearestFilter: At,
      NearestMipmapNearestFilter: Rt,
      NearestMipmapLinearFilter: Ct,
      LinearFilter: Lt,
      LinearMipmapNearestFilter: It,
      LinearMipmapLinearFilter: Pt,
    };
  class Bu extends au {
    constructor(t) {
      super(t),
        (this.isImageBitmapLoader = !0),
        "undefined" == typeof createImageBitmap &&
          console.warn(
            "THREE.ImageBitmapLoader: createImageBitmap() not supported.",
          ),
        "undefined" == typeof fetch &&
          console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        (this.options = { premultiplyAlpha: "none" });
    }
    setOptions(t) {
      return (this.options = t), this;
    }
    load(t, e, n, i) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = this,
        s = iu.get(t);
      if (void 0 !== s)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(s), r.manager.itemEnd(t);
          }, 0),
          s
        );
      const a = {};
      (a.credentials =
        "anonymous" === this.crossOrigin ? "same-origin" : "include"),
        (a.headers = this.requestHeader),
        fetch(t, a)
          .then(function (t) {
            return t.blob();
          })
          .then(function (t) {
            return createImageBitmap(
              t,
              Object.assign(r.options, { colorSpaceConversion: "none" }),
            );
          })
          .then(function (n) {
            iu.add(t, n), e && e(n), r.manager.itemEnd(t);
          })
          .catch(function (e) {
            i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
          }),
        r.manager.itemStart(t);
    }
  }
  let zu;
  class ku {
    static getContext() {
      return (
        void 0 === zu &&
          (zu = new (window.AudioContext || window.webkitAudioContext)()),
        zu
      );
    }
    static setContext(t) {
      zu = t;
    }
  }
  const Hu = new hi(),
    Gu = new hi(),
    Vu = new hi();
  class Wu {
    constructor(t = !0) {
      (this.autoStart = t),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    start() {
      (this.startTime = ju()),
        (this.oldTime = this.startTime),
        (this.elapsedTime = 0),
        (this.running = !0);
    }
    stop() {
      this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let t = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        const e = ju();
        (t = (e - this.oldTime) / 1e3),
          (this.oldTime = e),
          (this.elapsedTime += t);
      }
      return t;
    }
  }
  function ju() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }
  const Xu = new Nn(),
    qu = new Un(),
    Yu = new Nn(),
    Ku = new Nn();
  class Zu extends Oi {
    constructor(t) {
      super(),
        (this.type = "Audio"),
        (this.listener = t),
        (this.context = t.context),
        (this.gain = this.context.createGain()),
        this.gain.connect(t.getInput()),
        (this.autoplay = !1),
        (this.buffer = null),
        (this.detune = 0),
        (this.loop = !1),
        (this.loopStart = 0),
        (this.loopEnd = 0),
        (this.offset = 0),
        (this.duration = void 0),
        (this.playbackRate = 1),
        (this.isPlaying = !1),
        (this.hasPlaybackControl = !0),
        (this.source = null),
        (this.sourceType = "empty"),
        (this._startedAt = 0),
        (this._progress = 0),
        (this._connected = !1),
        (this.filters = []);
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(t) {
      return (
        (this.hasPlaybackControl = !1),
        (this.sourceType = "audioNode"),
        (this.source = t),
        this.connect(),
        this
      );
    }
    setMediaElementSource(t) {
      return (
        (this.hasPlaybackControl = !1),
        (this.sourceType = "mediaNode"),
        (this.source = this.context.createMediaElementSource(t)),
        this.connect(),
        this
      );
    }
    setMediaStreamSource(t) {
      return (
        (this.hasPlaybackControl = !1),
        (this.sourceType = "mediaStreamNode"),
        (this.source = this.context.createMediaStreamSource(t)),
        this.connect(),
        this
      );
    }
    setBuffer(t) {
      return (
        (this.buffer = t),
        (this.sourceType = "buffer"),
        this.autoplay && this.play(),
        this
      );
    }
    play(t = 0) {
      if (!0 === this.isPlaying)
        return void console.warn("THREE.Audio: Audio is already playing.");
      if (!1 === this.hasPlaybackControl)
        return void console.warn(
          "THREE.Audio: this Audio has no playback control.",
        );
      this._startedAt = this.context.currentTime + t;
      const e = this.context.createBufferSource();
      return (
        (e.buffer = this.buffer),
        (e.loop = this.loop),
        (e.loopStart = this.loopStart),
        (e.loopEnd = this.loopEnd),
        (e.onended = this.onEnded.bind(this)),
        e.start(this._startedAt, this._progress + this.offset, this.duration),
        (this.isPlaying = !0),
        (this.source = e),
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
      );
    }
    pause() {
      if (!1 !== this.hasPlaybackControl)
        return (
          !0 === this.isPlaying &&
            ((this._progress +=
              Math.max(this.context.currentTime - this._startedAt, 0) *
              this.playbackRate),
            !0 === this.loop &&
              (this._progress =
                this._progress % (this.duration || this.buffer.duration)),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1)),
          this
        );
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    stop() {
      if (!1 !== this.hasPlaybackControl)
        return (
          (this._progress = 0),
          null !== this.source &&
            (this.source.stop(), (this.source.onended = null)),
          (this.isPlaying = !1),
          this
        );
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].connect(this.filters[t]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else this.source.connect(this.getOutput());
      return (this._connected = !0), this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(t) {
      return (
        t || (t = []),
        !0 === this._connected
          ? (this.disconnect(), (this.filters = t.slice()), this.connect())
          : (this.filters = t.slice()),
        this
      );
    }
    setDetune(t) {
      if (((this.detune = t), void 0 !== this.source.detune))
        return (
          !0 === this.isPlaying &&
            this.source.detune.setTargetAtTime(
              this.detune,
              this.context.currentTime,
              0.01,
            ),
          this
        );
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(t) {
      return this.setFilters(t ? [t] : []);
    }
    setPlaybackRate(t) {
      if (!1 !== this.hasPlaybackControl)
        return (
          (this.playbackRate = t),
          !0 === this.isPlaying &&
            this.source.playbackRate.setTargetAtTime(
              this.playbackRate,
              this.context.currentTime,
              0.01,
            ),
          this
        );
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = !1;
    }
    getLoop() {
      return !1 === this.hasPlaybackControl
        ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
        : this.loop;
    }
    setLoop(t) {
      if (!1 !== this.hasPlaybackControl)
        return (
          (this.loop = t),
          !0 === this.isPlaying && (this.source.loop = this.loop),
          this
        );
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    setLoopStart(t) {
      return (this.loopStart = t), this;
    }
    setLoopEnd(t) {
      return (this.loopEnd = t), this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(t) {
      return (
        this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
      );
    }
  }
  const Ju = new Nn(),
    $u = new Un(),
    Qu = new Nn(),
    td = new Nn();
  class ed {
    constructor(t, e, n) {
      let i, r, s;
      switch (((this.binding = t), (this.valueSize = n), e)) {
        case "quaternion":
          (i = this._slerp),
            (r = this._slerpAdditive),
            (s = this._setAdditiveIdentityQuaternion),
            (this.buffer = new Float64Array(6 * n)),
            (this._workIndex = 5);
          break;
        case "string":
        case "bool":
          (i = this._select),
            (r = this._select),
            (s = this._setAdditiveIdentityOther),
            (this.buffer = new Array(5 * n));
          break;
        default:
          (i = this._lerp),
            (r = this._lerpAdditive),
            (s = this._setAdditiveIdentityNumeric),
            (this.buffer = new Float64Array(5 * n));
      }
      (this._mixBufferRegion = i),
        (this._mixBufferRegionAdditive = r),
        (this._setIdentity = s),
        (this._origIndex = 3),
        (this._addIndex = 4),
        (this.cumulativeWeight = 0),
        (this.cumulativeWeightAdditive = 0),
        (this.useCount = 0),
        (this.referenceCount = 0);
    }
    accumulate(t, e) {
      const n = this.buffer,
        i = this.valueSize,
        r = t * i + i;
      let s = this.cumulativeWeight;
      if (0 === s) {
        for (let t = 0; t !== i; ++t) n[r + t] = n[t];
        s = e;
      } else {
        s += e;
        const t = e / s;
        this._mixBufferRegion(n, r, 0, t, i);
      }
      this.cumulativeWeight = s;
    }
    accumulateAdditive(t) {
      const e = this.buffer,
        n = this.valueSize,
        i = n * this._addIndex;
      0 === this.cumulativeWeightAdditive && this._setIdentity(),
        this._mixBufferRegionAdditive(e, i, 0, t, n),
        (this.cumulativeWeightAdditive += t);
    }
    apply(t) {
      const e = this.valueSize,
        n = this.buffer,
        i = t * e + e,
        r = this.cumulativeWeight,
        s = this.cumulativeWeightAdditive,
        a = this.binding;
      if (
        ((this.cumulativeWeight = 0),
        (this.cumulativeWeightAdditive = 0),
        r < 1)
      ) {
        const t = e * this._origIndex;
        this._mixBufferRegion(n, i, t, 1 - r, e);
      }
      s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
      for (let o = e, l = e + e; o !== l; ++o)
        if (n[o] !== n[o + e]) {
          a.setValue(n, i);
          break;
        }
    }
    saveOriginalState() {
      const t = this.binding,
        e = this.buffer,
        n = this.valueSize,
        i = n * this._origIndex;
      t.getValue(e, i);
      for (let r = n, s = i; r !== s; ++r) e[r] = e[i + (r % n)];
      this._setIdentity(),
        (this.cumulativeWeight = 0),
        (this.cumulativeWeightAdditive = 0);
    }
    restoreOriginalState() {
      const t = 3 * this.valueSize;
      this.binding.setValue(this.buffer, t);
    }
    _setAdditiveIdentityNumeric() {
      const t = this._addIndex * this.valueSize,
        e = t + this.valueSize;
      for (let n = t; n < e; n++) this.buffer[n] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(),
        (this.buffer[this._addIndex * this.valueSize + 3] = 1);
    }
    _setAdditiveIdentityOther() {
      const t = this._origIndex * this.valueSize,
        e = this._addIndex * this.valueSize;
      for (let n = 0; n < this.valueSize; n++)
        this.buffer[e + n] = this.buffer[t + n];
    }
    _select(t, e, n, i, r) {
      if (i >= 0.5) for (let s = 0; s !== r; ++s) t[e + s] = t[n + s];
    }
    _slerp(t, e, n, i) {
      Un.slerpFlat(t, e, t, e, t, n, i);
    }
    _slerpAdditive(t, e, n, i, r) {
      const s = this._workIndex * r;
      Un.multiplyQuaternionsFlat(t, s, t, e, t, n),
        Un.slerpFlat(t, e, t, e, t, s, i);
    }
    _lerp(t, e, n, i, r) {
      const s = 1 - i;
      for (let a = 0; a !== r; ++a) {
        const r = e + a;
        t[r] = t[r] * s + t[n + a] * i;
      }
    }
    _lerpAdditive(t, e, n, i, r) {
      for (let s = 0; s !== r; ++s) {
        const r = e + s;
        t[r] = t[r] + t[n + s] * i;
      }
    }
  }
  const nd = "\\[\\]\\.:\\/",
    id = new RegExp("[" + nd + "]", "g"),
    rd = "[^" + nd + "]",
    sd = "[^" + nd.replace("\\.", "") + "]",
    ad = new RegExp(
      "^" +
        /((?:WC+[\/:])*)/.source.replace("WC", rd) +
        /(WCOD+)?/.source.replace("WCOD", sd) +
        /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", rd) +
        /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", rd) +
        "$",
    ),
    od = ["material", "materials", "bones", "map"];
  class ld {
    constructor(t, e, n) {
      (this.path = e),
        (this.parsedPath = n || ld.parseTrackName(e)),
        (this.node = ld.findNode(t, this.parsedPath.nodeName)),
        (this.rootNode = t),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
    static create(t, e, n) {
      return t && t.isAnimationObjectGroup
        ? new ld.Composite(t, e, n)
        : new ld(t, e, n);
    }
    static sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(id, "");
    }
    static parseTrackName(t) {
      const e = ad.exec(t);
      if (null === e)
        throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      const n = {
          nodeName: e[2],
          objectName: e[3],
          objectIndex: e[4],
          propertyName: e[5],
          propertyIndex: e[6],
        },
        i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (void 0 !== i && -1 !== i) {
        const t = n.nodeName.substring(i + 1);
        -1 !== od.indexOf(t) &&
          ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
      }
      if (null === n.propertyName || 0 === n.propertyName.length)
        throw new Error(
          "PropertyBinding: can not parse propertyName from trackName: " + t,
        );
      return n;
    }
    static findNode(t, e) {
      if (
        void 0 === e ||
        "" === e ||
        "." === e ||
        -1 === e ||
        e === t.name ||
        e === t.uuid
      )
        return t;
      if (t.skeleton) {
        const n = t.skeleton.getBoneByName(e);
        if (void 0 !== n) return n;
      }
      if (t.children) {
        const n = function (t) {
            for (let i = 0; i < t.length; i++) {
              const r = t[i];
              if (r.name === e || r.uuid === e) return r;
              const s = n(r.children);
              if (s) return s;
            }
            return null;
          },
          i = n(t.children);
        if (i) return i;
      }
      return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(t, e) {
      t[e] = this.targetObject[this.propertyName];
    }
    _getValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
    }
    _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e);
    }
    _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e];
    }
    _setValue_direct_setNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
    }
    _setValue_array_setNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e];
    }
    _setValue_arrayElement_setNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e);
    }
    _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _getValue_unbound(t, e) {
      this.bind(), this.getValue(t, e);
    }
    _setValue_unbound(t, e) {
      this.bind(), this.setValue(t, e);
    }
    bind() {
      let t = this.node;
      const e = this.parsedPath,
        n = e.objectName,
        i = e.propertyName;
      let r = e.propertyIndex;
      if (
        (t || ((t = ld.findNode(this.rootNode, e.nodeName)), (this.node = t)),
        (this.getValue = this._getValue_unavailable),
        (this.setValue = this._setValue_unavailable),
        !t)
      )
        return void console.warn(
          "THREE.PropertyBinding: No target node found for track: " +
            this.path +
            ".",
        );
      if (n) {
        let i = e.objectIndex;
        switch (n) {
          case "materials":
            if (!t.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this,
              );
            if (!t.material.materials)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                this,
              );
            t = t.material.materials;
            break;
          case "bones":
            if (!t.skeleton)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                this,
              );
            t = t.skeleton.bones;
            for (let e = 0; e < t.length; e++)
              if (t[e].name === i) {
                i = e;
                break;
              }
            break;
          case "map":
            if ("map" in t) {
              t = t.map;
              break;
            }
            if (!t.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this,
              );
            if (!t.material.map)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                this,
              );
            t = t.material.map;
            break;
          default:
            if (void 0 === t[n])
              return void console.error(
                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                this,
              );
            t = t[n];
        }
        if (void 0 !== i) {
          if (void 0 === t[i])
            return void console.error(
              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
              this,
              t,
            );
          t = t[i];
        }
      }
      const s = t[i];
      if (void 0 === s) {
        const n = e.nodeName;
        return void console.error(
          "THREE.PropertyBinding: Trying to update property for track: " +
            n +
            "." +
            i +
            " but it wasn't found.",
          t,
        );
      }
      let a = this.Versioning.None;
      (this.targetObject = t),
        void 0 !== t.needsUpdate
          ? (a = this.Versioning.NeedsUpdate)
          : void 0 !== t.matrixWorldNeedsUpdate &&
            (a = this.Versioning.MatrixWorldNeedsUpdate);
      let o = this.BindingType.Direct;
      if (void 0 !== r) {
        if ("morphTargetInfluences" === i) {
          if (!t.geometry)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
              this,
            );
          if (!t.geometry.morphAttributes)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this,
            );
          void 0 !== t.morphTargetDictionary[r] &&
            (r = t.morphTargetDictionary[r]);
        }
        (o = this.BindingType.ArrayElement),
          (this.resolvedProperty = s),
          (this.propertyIndex = r);
      } else void 0 !== s.fromArray && void 0 !== s.toArray ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s)) : Array.isArray(s) ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s)) : (this.propertyName = i);
      (this.getValue = this.GetterByBindingType[o]),
        (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
    }
    unbind() {
      (this.node = null),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
  }
  (ld.Composite = class {
    constructor(t, e, n) {
      const i = n || ld.parseTrackName(e);
      (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
    }
    getValue(t, e) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_,
        i = this._bindings[n];
      void 0 !== i && i.getValue(t, e);
    }
    setValue(t, e) {
      const n = this._bindings;
      for (
        let i = this._targetGroup.nCachedObjects_, r = n.length;
        i !== r;
        ++i
      )
        n[i].setValue(t, e);
    }
    bind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, n = t.length;
        e !== n;
        ++e
      )
        t[e].bind();
    }
    unbind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, n = t.length;
        e !== n;
        ++e
      )
        t[e].unbind();
    }
  }),
    (ld.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3,
    }),
    (ld.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2,
    }),
    (ld.prototype.GetterByBindingType = [
      ld.prototype._getValue_direct,
      ld.prototype._getValue_array,
      ld.prototype._getValue_arrayElement,
      ld.prototype._getValue_toArray,
    ]),
    (ld.prototype.SetterByBindingTypeAndVersioning = [
      [
        ld.prototype._setValue_direct,
        ld.prototype._setValue_direct_setNeedsUpdate,
        ld.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
      ],
      [
        ld.prototype._setValue_array,
        ld.prototype._setValue_array_setNeedsUpdate,
        ld.prototype._setValue_array_setMatrixWorldNeedsUpdate,
      ],
      [
        ld.prototype._setValue_arrayElement,
        ld.prototype._setValue_arrayElement_setNeedsUpdate,
        ld.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
      ],
      [
        ld.prototype._setValue_fromArray,
        ld.prototype._setValue_fromArray_setNeedsUpdate,
        ld.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
      ],
    ]);
  class cd {
    constructor(t, e, n = null, i = e.blendMode) {
      (this._mixer = t),
        (this._clip = e),
        (this._localRoot = n),
        (this.blendMode = i);
      const r = e.tracks,
        s = r.length,
        a = new Array(s),
        o = { endingStart: Ee, endingEnd: Ee };
      for (let l = 0; l !== s; ++l) {
        const t = r[l].createInterpolant(null);
        (a[l] = t), (t.settings = o);
      }
      (this._interpolantSettings = o),
        (this._interpolants = a),
        (this._propertyBindings = new Array(s)),
        (this._cacheIndex = null),
        (this._byClipCacheIndex = null),
        (this._timeScaleInterpolant = null),
        (this._weightInterpolant = null),
        (this.loop = 2201),
        (this._loopCount = -1),
        (this._startTime = null),
        (this.time = 0),
        (this.timeScale = 1),
        (this._effectiveTimeScale = 1),
        (this.weight = 1),
        (this._effectiveWeight = 1),
        (this.repetitions = 1 / 0),
        (this.paused = !1),
        (this.enabled = !0),
        (this.clampWhenFinished = !1),
        (this.zeroSlopeAtStart = !0),
        (this.zeroSlopeAtEnd = !0);
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return (
        (this.paused = !1),
        (this.enabled = !0),
        (this.time = 0),
        (this._loopCount = -1),
        (this._startTime = null),
        this.stopFading().stopWarping()
      );
    }
    isRunning() {
      return (
        this.enabled &&
        !this.paused &&
        0 !== this.timeScale &&
        null === this._startTime &&
        this._mixer._isActiveAction(this)
      );
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(t) {
      return (this._startTime = t), this;
    }
    setLoop(t, e) {
      return (this.loop = t), (this.repetitions = e), this;
    }
    setEffectiveWeight(t) {
      return (
        (this.weight = t),
        (this._effectiveWeight = this.enabled ? t : 0),
        this.stopFading()
      );
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(t) {
      return this._scheduleFading(t, 0, 1);
    }
    fadeOut(t) {
      return this._scheduleFading(t, 1, 0);
    }
    crossFadeFrom(t, e, n) {
      if ((t.fadeOut(e), this.fadeIn(e), n)) {
        const n = this._clip.duration,
          i = t._clip.duration,
          r = i / n,
          s = n / i;
        t.warp(1, r, e), this.warp(s, 1, e);
      }
      return this;
    }
    crossFadeTo(t, e, n) {
      return t.crossFadeFrom(this, e, n);
    }
    stopFading() {
      const t = this._weightInterpolant;
      return (
        null !== t &&
          ((this._weightInterpolant = null),
          this._mixer._takeBackControlInterpolant(t)),
        this
      );
    }
    setEffectiveTimeScale(t) {
      return (
        (this.timeScale = t),
        (this._effectiveTimeScale = this.paused ? 0 : t),
        this.stopWarping()
      );
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(t) {
      return (this.timeScale = this._clip.duration / t), this.stopWarping();
    }
    syncWith(t) {
      return (
        (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
      );
    }
    halt(t) {
      return this.warp(this._effectiveTimeScale, 0, t);
    }
    warp(t, e, n) {
      const i = this._mixer,
        r = i.time,
        s = this.timeScale;
      let a = this._timeScaleInterpolant;
      null === a &&
        ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
      const o = a.parameterPositions,
        l = a.sampleValues;
      return (o[0] = r), (o[1] = r + n), (l[0] = t / s), (l[1] = e / s), this;
    }
    stopWarping() {
      const t = this._timeScaleInterpolant;
      return (
        null !== t &&
          ((this._timeScaleInterpolant = null),
          this._mixer._takeBackControlInterpolant(t)),
        this
      );
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(t, e, n, i) {
      if (!this.enabled) return void this._updateWeight(t);
      const r = this._startTime;
      if (null !== r) {
        const i = (t - r) * n;
        i < 0 || 0 === n ? (e = 0) : ((this._startTime = null), (e = n * i));
      }
      e *= this._updateTimeScale(t);
      const s = this._updateTime(e),
        a = this._updateWeight(t);
      if (a > 0) {
        const t = this._interpolants,
          e = this._propertyBindings;
        if (this.blendMode === Le)
          for (let n = 0, i = t.length; n !== i; ++n)
            t[n].evaluate(s), e[n].accumulateAdditive(a);
        else
          for (let n = 0, r = t.length; n !== r; ++n)
            t[n].evaluate(s), e[n].accumulate(i, a);
      }
    }
    _updateWeight(t) {
      let e = 0;
      if (this.enabled) {
        e = this.weight;
        const n = this._weightInterpolant;
        if (null !== n) {
          const i = n.evaluate(t)[0];
          (e *= i),
            t > n.parameterPositions[1] &&
              (this.stopFading(), 0 === i && (this.enabled = !1));
        }
      }
      return (this._effectiveWeight = e), e;
    }
    _updateTimeScale(t) {
      let e = 0;
      if (!this.paused) {
        e = this.timeScale;
        const n = this._timeScaleInterpolant;
        if (null !== n) {
          (e *= n.evaluate(t)[0]),
            t > n.parameterPositions[1] &&
              (this.stopWarping(),
              0 === e ? (this.paused = !0) : (this.timeScale = e));
        }
      }
      return (this._effectiveTimeScale = e), e;
    }
    _updateTime(t) {
      const e = this._clip.duration,
        n = this.loop;
      let i = this.time + t,
        r = this._loopCount;
      const s = 2202 === n;
      if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
      if (n === Se) {
        -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
        t: {
          if (i >= e) i = e;
          else {
            if (!(i < 0)) {
              this.time = i;
              break t;
            }
            i = 0;
          }
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: t < 0 ? -1 : 1,
            });
        }
      } else {
        if (
          (-1 === r &&
            (t >= 0
              ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
              : this._setEndings(0 === this.repetitions, !0, s)),
          i >= e || i < 0)
        ) {
          const n = Math.floor(i / e);
          (i -= e * n), (r += Math.abs(n));
          const a = this.repetitions - r;
          if (a <= 0)
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (i = t > 0 ? e : 0),
              (this.time = i),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: t > 0 ? 1 : -1,
              });
          else {
            if (1 === a) {
              const e = t < 0;
              this._setEndings(e, !e, s);
            } else this._setEndings(!1, !1, s);
            (this._loopCount = r),
              (this.time = i),
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: n,
              });
          }
        } else this.time = i;
        if (s && 1 == (1 & r)) return e - i;
      }
      return i;
    }
    _setEndings(t, e, n) {
      const i = this._interpolantSettings;
      n
        ? ((i.endingStart = Ae), (i.endingEnd = Ae))
        : ((i.endingStart = t ? (this.zeroSlopeAtStart ? Ae : Ee) : Re),
          (i.endingEnd = e ? (this.zeroSlopeAtEnd ? Ae : Ee) : Re));
    }
    _scheduleFading(t, e, n) {
      const i = this._mixer,
        r = i.time;
      let s = this._weightInterpolant;
      null === s &&
        ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
      const a = s.parameterPositions,
        o = s.sampleValues;
      return (a[0] = r), (o[0] = e), (a[1] = r + t), (o[1] = n), this;
    }
  }
  const hd = new Float32Array(1);
  class ud extends Ve {
    constructor(t) {
      super(),
        (this._root = t),
        this._initMemoryManager(),
        (this._accuIndex = 0),
        (this.time = 0),
        (this.timeScale = 1);
    }
    _bindAction(t, e) {
      const n = t._localRoot || this._root,
        i = t._clip.tracks,
        r = i.length,
        s = t._propertyBindings,
        a = t._interpolants,
        o = n.uuid,
        l = this._bindingsByRootAndName;
      let c = l[o];
      void 0 === c && ((c = {}), (l[o] = c));
      for (let h = 0; h !== r; ++h) {
        const t = i[h],
          r = t.name;
        let l = c[r];
        if (void 0 !== l) ++l.referenceCount, (s[h] = l);
        else {
          if (((l = s[h]), void 0 !== l)) {
            null === l._cacheIndex &&
              (++l.referenceCount, this._addInactiveBinding(l, o, r));
            continue;
          }
          const i = e && e._propertyBindings[h].binding.parsedPath;
          (l = new ed(ld.create(n, r, i), t.ValueTypeName, t.getValueSize())),
            ++l.referenceCount,
            this._addInactiveBinding(l, o, r),
            (s[h] = l);
        }
        a[h].resultBuffer = l.buffer;
      }
    }
    _activateAction(t) {
      if (!this._isActiveAction(t)) {
        if (null === t._cacheIndex) {
          const e = (t._localRoot || this._root).uuid,
            n = t._clip.uuid,
            i = this._actionsByClip[n];
          this._bindAction(t, i && i.knownActions[0]),
            this._addInactiveAction(t, n, e);
        }
        const e = t._propertyBindings;
        for (let t = 0, n = e.length; t !== n; ++t) {
          const n = e[t];
          0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
        }
        this._lendAction(t);
      }
    }
    _deactivateAction(t) {
      if (this._isActiveAction(t)) {
        const e = t._propertyBindings;
        for (let t = 0, n = e.length; t !== n; ++t) {
          const n = e[t];
          0 == --n.useCount &&
            (n.restoreOriginalState(), this._takeBackBinding(n));
        }
        this._takeBackAction(t);
      }
    }
    _initMemoryManager() {
      (this._actions = []),
        (this._nActiveActions = 0),
        (this._actionsByClip = {}),
        (this._bindings = []),
        (this._nActiveBindings = 0),
        (this._bindingsByRootAndName = {}),
        (this._controlInterpolants = []),
        (this._nActiveControlInterpolants = 0);
      const t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length;
          },
          get inUse() {
            return t._nActiveActions;
          },
        },
        bindings: {
          get total() {
            return t._bindings.length;
          },
          get inUse() {
            return t._nActiveBindings;
          },
        },
        controlInterpolants: {
          get total() {
            return t._controlInterpolants.length;
          },
          get inUse() {
            return t._nActiveControlInterpolants;
          },
        },
      };
    }
    _isActiveAction(t) {
      const e = t._cacheIndex;
      return null !== e && e < this._nActiveActions;
    }
    _addInactiveAction(t, e, n) {
      const i = this._actions,
        r = this._actionsByClip;
      let s = r[e];
      if (void 0 === s)
        (s = { knownActions: [t], actionByRoot: {} }),
          (t._byClipCacheIndex = 0),
          (r[e] = s);
      else {
        const e = s.knownActions;
        (t._byClipCacheIndex = e.length), e.push(t);
      }
      (t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t);
    }
    _removeInactiveAction(t) {
      const e = this._actions,
        n = e[e.length - 1],
        i = t._cacheIndex;
      (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
      const r = t._clip.uuid,
        s = this._actionsByClip,
        a = s[r],
        o = a.knownActions,
        l = o[o.length - 1],
        c = t._byClipCacheIndex;
      (l._byClipCacheIndex = c),
        (o[c] = l),
        o.pop(),
        (t._byClipCacheIndex = null);
      delete a.actionByRoot[(t._localRoot || this._root).uuid],
        0 === o.length && delete s[r],
        this._removeInactiveBindingsForAction(t);
    }
    _removeInactiveBindingsForAction(t) {
      const e = t._propertyBindings;
      for (let n = 0, i = e.length; n !== i; ++n) {
        const t = e[n];
        0 == --t.referenceCount && this._removeInactiveBinding(t);
      }
    }
    _lendAction(t) {
      const e = this._actions,
        n = t._cacheIndex,
        i = this._nActiveActions++,
        r = e[i];
      (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
    }
    _takeBackAction(t) {
      const e = this._actions,
        n = t._cacheIndex,
        i = --this._nActiveActions,
        r = e[i];
      (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
    }
    _addInactiveBinding(t, e, n) {
      const i = this._bindingsByRootAndName,
        r = this._bindings;
      let s = i[e];
      void 0 === s && ((s = {}), (i[e] = s)),
        (s[n] = t),
        (t._cacheIndex = r.length),
        r.push(t);
    }
    _removeInactiveBinding(t) {
      const e = this._bindings,
        n = t.binding,
        i = n.rootNode.uuid,
        r = n.path,
        s = this._bindingsByRootAndName,
        a = s[i],
        o = e[e.length - 1],
        l = t._cacheIndex;
      (o._cacheIndex = l),
        (e[l] = o),
        e.pop(),
        delete a[r],
        0 === Object.keys(a).length && delete s[i];
    }
    _lendBinding(t) {
      const e = this._bindings,
        n = t._cacheIndex,
        i = this._nActiveBindings++,
        r = e[i];
      (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
    }
    _takeBackBinding(t) {
      const e = this._bindings,
        n = t._cacheIndex,
        i = --this._nActiveBindings,
        r = e[i];
      (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
    }
    _lendControlInterpolant() {
      const t = this._controlInterpolants,
        e = this._nActiveControlInterpolants++;
      let n = t[e];
      return (
        void 0 === n &&
          ((n = new jh(new Float32Array(2), new Float32Array(2), 1, hd)),
          (n.__cacheIndex = e),
          (t[e] = n)),
        n
      );
    }
    _takeBackControlInterpolant(t) {
      const e = this._controlInterpolants,
        n = t.__cacheIndex,
        i = --this._nActiveControlInterpolants,
        r = e[i];
      (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
    }
    clipAction(t, e, n) {
      const i = e || this._root,
        r = i.uuid;
      let s = "string" == typeof t ? eu.findByName(i, t) : t;
      const a = null !== s ? s.uuid : t,
        o = this._actionsByClip[a];
      let l = null;
      if ((void 0 === n && (n = null !== s ? s.blendMode : Ce), void 0 !== o)) {
        const t = o.actionByRoot[r];
        if (void 0 !== t && t.blendMode === n) return t;
        (l = o.knownActions[0]), null === s && (s = l._clip);
      }
      if (null === s) return null;
      const c = new cd(this, s, e, n);
      return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
    }
    existingAction(t, e) {
      const n = e || this._root,
        i = n.uuid,
        r = "string" == typeof t ? eu.findByName(n, t) : t,
        s = r ? r.uuid : t,
        a = this._actionsByClip[s];
      return (void 0 !== a && a.actionByRoot[i]) || null;
    }
    stopAllAction() {
      const t = this._actions;
      for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
      return this;
    }
    update(t) {
      t *= this.timeScale;
      const e = this._actions,
        n = this._nActiveActions,
        i = (this.time += t),
        r = Math.sign(t),
        s = (this._accuIndex ^= 1);
      for (let l = 0; l !== n; ++l) {
        e[l]._update(i, t, r, s);
      }
      const a = this._bindings,
        o = this._nActiveBindings;
      for (let l = 0; l !== o; ++l) a[l].apply(s);
      return this;
    }
    setTime(t) {
      this.time = 0;
      for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
      return this.update(t);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(t) {
      const e = this._actions,
        n = t.uuid,
        i = this._actionsByClip,
        r = i[n];
      if (void 0 !== r) {
        const t = r.knownActions;
        for (let n = 0, i = t.length; n !== i; ++n) {
          const i = t[n];
          this._deactivateAction(i);
          const r = i._cacheIndex,
            s = e[e.length - 1];
          (i._cacheIndex = null),
            (i._byClipCacheIndex = null),
            (s._cacheIndex = r),
            (e[r] = s),
            e.pop(),
            this._removeInactiveBindingsForAction(i);
        }
        delete i[n];
      }
    }
    uncacheRoot(t) {
      const e = t.uuid,
        n = this._actionsByClip;
      for (const r in n) {
        const t = n[r].actionByRoot[e];
        void 0 !== t &&
          (this._deactivateAction(t), this._removeInactiveAction(t));
      }
      const i = this._bindingsByRootAndName[e];
      if (void 0 !== i)
        for (const r in i) {
          const t = i[r];
          t.restoreOriginalState(), this._removeInactiveBinding(t);
        }
    }
    uncacheAction(t, e) {
      const n = this.existingAction(t, e);
      null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
    }
  }
  class dd {
    constructor(t) {
      this.value = t;
    }
    clone() {
      return new dd(
        void 0 === this.value.clone ? this.value : this.value.clone(),
      );
    }
  }
  let pd = 0;
  function fd(t, e) {
    return t.distance - e.distance;
  }
  function md(t, e, n, i) {
    if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
      const i = t.children;
      for (let t = 0, r = i.length; t < r; t++) md(i[t], e, n, !0);
    }
  }
  class gd {
    constructor(t = 1, e = 0, n = 0) {
      return (this.radius = t), (this.phi = e), (this.theta = n), this;
    }
    set(t, e, n) {
      return (this.radius = t), (this.phi = e), (this.theta = n), this;
    }
    copy(t) {
      return (
        (this.radius = t.radius),
        (this.phi = t.phi),
        (this.theta = t.theta),
        this
      );
    }
    makeSafe() {
      const t = 1e-6;
      return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this;
    }
    setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }
    setFromCartesianCoords(t, e, n) {
      return (
        (this.radius = Math.sqrt(t * t + e * e + n * n)),
        0 === this.radius
          ? ((this.theta = 0), (this.phi = 0))
          : ((this.theta = Math.atan2(t, n)),
            (this.phi = Math.acos(Ke(e / this.radius, -1, 1)))),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const vd = new sn();
  const _d = new Nn(),
    yd = new Nn();
  const xd = new Nn();
  const Md = new Nn(),
    Sd = new hi(),
    bd = new hi();
  function Td(t) {
    const e = [];
    !0 === t.isBone && e.push(t);
    for (let n = 0; n < t.children.length; n++)
      e.push.apply(e, Td(t.children[n]));
    return e;
  }
  const wd = new Nn(),
    Ed = new tr(),
    Ad = new tr();
  const Rd = new Nn(),
    Cd = new Nn(),
    Ld = new Nn();
  const Id = new Nn(),
    Pd = new qr();
  function Ud(t, e, n, i, r, s, a) {
    Id.set(r, s, a).unproject(i);
    const o = e[t];
    if (void 0 !== o) {
      const t = n.getAttribute("position");
      for (let e = 0, n = o.length; e < n; e++)
        t.setXYZ(o[e], Id.x, Id.y, Id.z);
    }
  }
  const Nd = new Fn();
  const Od = new Nn();
  let Dd, Fd;
  "undefined" != typeof __THREE_DEVTOOLS__ &&
    __THREE_DEVTOOLS__.dispatchEvent(
      new CustomEvent("register", { detail: { revision: tt } }),
    ),
    "undefined" != typeof window &&
      (window.__THREE__
        ? console.warn(
            "WARNING: Multiple instances of Three.js being imported.",
          )
        : (window.__THREE__ = tt));
  const Bd = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          ACESFilmicToneMapping: gt,
          AddEquation: lt,
          AddOperation: ut,
          AdditiveAnimationBlendMode: Le,
          AdditiveBlending: 2,
          AlphaFormat: 1021,
          AlwaysCompare: 519,
          AlwaysDepth: 1,
          AlwaysStencilFunc: 519,
          AmbientLight: Au,
          AmbientLightProbe: class extends Lu {
            constructor(t, e = 1) {
              super(void 0, e), (this.isAmbientLightProbe = !0);
              const n = new tr().set(t);
              this.sh.coefficients[0]
                .set(n.r, n.g, n.b)
                .multiplyScalar(2 * Math.sqrt(Math.PI));
            }
          },
          AnimationAction: cd,
          AnimationClip: eu,
          AnimationLoader: class extends au {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = new cu(this.manager);
              s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(
                  t,
                  function (n) {
                    try {
                      e(r.parse(JSON.parse(n)));
                    } catch (s) {
                      i ? i(s) : console.error(s), r.manager.itemError(t);
                    }
                  },
                  n,
                  i,
                );
            }
            parse(t) {
              const e = [];
              for (let n = 0; n < t.length; n++) {
                const i = eu.parse(t[n]);
                e.push(i);
              }
              return e;
            }
          },
          AnimationMixer: ud,
          AnimationObjectGroup: class {
            constructor() {
              (this.isAnimationObjectGroup = !0),
                (this.uuid = Ye()),
                (this._objects = Array.prototype.slice.call(arguments)),
                (this.nCachedObjects_ = 0);
              const t = {};
              this._indicesByUUID = t;
              for (let n = 0, i = arguments.length; n !== i; ++n)
                t[arguments[n].uuid] = n;
              (this._paths = []),
                (this._parsedPaths = []),
                (this._bindings = []),
                (this._bindingsIndicesByPath = {});
              const e = this;
              this.stats = {
                objects: {
                  get total() {
                    return e._objects.length;
                  },
                  get inUse() {
                    return this.total - e.nCachedObjects_;
                  },
                },
                get bindingsPerObject() {
                  return e._bindings.length;
                },
              };
            }
            add() {
              const t = this._objects,
                e = this._indicesByUUID,
                n = this._paths,
                i = this._parsedPaths,
                r = this._bindings,
                s = r.length;
              let a,
                o = t.length,
                l = this.nCachedObjects_;
              for (let c = 0, h = arguments.length; c !== h; ++c) {
                const h = arguments[c],
                  u = h.uuid;
                let d = e[u];
                if (void 0 === d) {
                  (d = o++), (e[u] = d), t.push(h);
                  for (let t = 0, e = s; t !== e; ++t)
                    r[t].push(new ld(h, n[t], i[t]));
                } else if (d < l) {
                  a = t[d];
                  const o = --l,
                    c = t[o];
                  (e[c.uuid] = d), (t[d] = c), (e[u] = o), (t[o] = h);
                  for (let t = 0, e = s; t !== e; ++t) {
                    const e = r[t],
                      s = e[o];
                    let a = e[d];
                    (e[d] = s),
                      void 0 === a && (a = new ld(h, n[t], i[t])),
                      (e[o] = a);
                  }
                } else
                  t[d] !== a &&
                    console.error(
                      "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.",
                    );
              }
              this.nCachedObjects_ = l;
            }
            remove() {
              const t = this._objects,
                e = this._indicesByUUID,
                n = this._bindings,
                i = n.length;
              let r = this.nCachedObjects_;
              for (let s = 0, a = arguments.length; s !== a; ++s) {
                const a = arguments[s],
                  o = a.uuid,
                  l = e[o];
                if (void 0 !== l && l >= r) {
                  const s = r++,
                    c = t[s];
                  (e[c.uuid] = l), (t[l] = c), (e[o] = s), (t[s] = a);
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t],
                      i = e[s],
                      r = e[l];
                    (e[l] = i), (e[s] = r);
                  }
                }
              }
              this.nCachedObjects_ = r;
            }
            uncache() {
              const t = this._objects,
                e = this._indicesByUUID,
                n = this._bindings,
                i = n.length;
              let r = this.nCachedObjects_,
                s = t.length;
              for (let a = 0, o = arguments.length; a !== o; ++a) {
                const o = arguments[a].uuid,
                  l = e[o];
                if (void 0 !== l)
                  if ((delete e[o], l < r)) {
                    const a = --r,
                      o = t[a],
                      c = --s,
                      h = t[c];
                    (e[o.uuid] = l),
                      (t[l] = o),
                      (e[h.uuid] = a),
                      (t[a] = h),
                      t.pop();
                    for (let t = 0, e = i; t !== e; ++t) {
                      const e = n[t],
                        i = e[a],
                        r = e[c];
                      (e[l] = i), (e[a] = r), e.pop();
                    }
                  } else {
                    const r = --s,
                      a = t[r];
                    r > 0 && (e[a.uuid] = l), (t[l] = a), t.pop();
                    for (let t = 0, e = i; t !== e; ++t) {
                      const e = n[t];
                      (e[l] = e[r]), e.pop();
                    }
                  }
              }
              this.nCachedObjects_ = r;
            }
            subscribe_(t, e) {
              const n = this._bindingsIndicesByPath;
              let i = n[t];
              const r = this._bindings;
              if (void 0 !== i) return r[i];
              const s = this._paths,
                a = this._parsedPaths,
                o = this._objects,
                l = o.length,
                c = this.nCachedObjects_,
                h = new Array(l);
              (i = r.length), (n[t] = i), s.push(t), a.push(e), r.push(h);
              for (let u = c, d = o.length; u !== d; ++u) {
                const n = o[u];
                h[u] = new ld(n, t, e);
              }
              return h;
            }
            unsubscribe_(t) {
              const e = this._bindingsIndicesByPath,
                n = e[t];
              if (void 0 !== n) {
                const i = this._paths,
                  r = this._parsedPaths,
                  s = this._bindings,
                  a = s.length - 1,
                  o = s[a];
                (e[t[a]] = n),
                  (s[n] = o),
                  s.pop(),
                  (r[n] = r[a]),
                  r.pop(),
                  (i[n] = i[a]),
                  i.pop();
              }
            }
          },
          AnimationUtils: Gh,
          ArcCurve: sc,
          ArrayCamera: Po,
          ArrowHelper: class extends Oi {
            constructor(
              t = new Nn(0, 0, 1),
              e = new Nn(0, 0, 0),
              n = 1,
              i = 16776960,
              r = 0.2 * n,
              s = 0.2 * r,
            ) {
              super(),
                (this.type = "ArrowHelper"),
                void 0 === Dd &&
                  ((Dd = new Mr()),
                  Dd.setAttribute("position", new pr([0, 0, 0, 0, 1, 0], 3)),
                  (Fd = new Rc(0, 0.5, 1, 5, 1)),
                  Fd.translate(0, -0.5, 0)),
                this.position.copy(e),
                (this.line = new Wl(Dd, new Bl({ color: i, toneMapped: !1 }))),
                (this.line.matrixAutoUpdate = !1),
                this.add(this.line),
                (this.cone = new zr(Fd, new nr({ color: i, toneMapped: !1 }))),
                (this.cone.matrixAutoUpdate = !1),
                this.add(this.cone),
                this.setDirection(t),
                this.setLength(n, r, s);
            }
            setDirection(t) {
              if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
              else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
              else {
                Od.set(t.z, 0, -t.x).normalize();
                const e = Math.acos(t.y);
                this.quaternion.setFromAxisAngle(Od, e);
              }
            }
            setLength(t, e = 0.2 * t, n = 0.2 * e) {
              this.line.scale.set(1, Math.max(1e-4, t - e), 1),
                this.line.updateMatrix(),
                this.cone.scale.set(n, e, n),
                (this.cone.position.y = t),
                this.cone.updateMatrix();
            }
            setColor(t) {
              this.line.material.color.set(t), this.cone.material.color.set(t);
            }
            copy(t) {
              return (
                super.copy(t, !1),
                this.line.copy(t.line),
                this.cone.copy(t.cone),
                this
              );
            }
            dispose() {
              this.line.geometry.dispose(),
                this.line.material.dispose(),
                this.cone.geometry.dispose(),
                this.cone.material.dispose();
            }
          },
          Audio: Zu,
          AudioAnalyser: class {
            constructor(t, e = 2048) {
              (this.analyser = t.context.createAnalyser()),
                (this.analyser.fftSize = e),
                (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
                t.getOutput().connect(this.analyser);
            }
            getFrequencyData() {
              return this.analyser.getByteFrequencyData(this.data), this.data;
            }
            getAverageFrequency() {
              let t = 0;
              const e = this.getFrequencyData();
              for (let n = 0; n < e.length; n++) t += e[n];
              return t / e.length;
            }
          },
          AudioContext: ku,
          AudioListener: class extends Oi {
            constructor() {
              super(),
                (this.type = "AudioListener"),
                (this.context = ku.getContext()),
                (this.gain = this.context.createGain()),
                this.gain.connect(this.context.destination),
                (this.filter = null),
                (this.timeDelta = 0),
                (this._clock = new Wu());
            }
            getInput() {
              return this.gain;
            }
            removeFilter() {
              return (
                null !== this.filter &&
                  (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination),
                  this.gain.connect(this.context.destination),
                  (this.filter = null)),
                this
              );
            }
            getFilter() {
              return this.filter;
            }
            setFilter(t) {
              return (
                null !== this.filter
                  ? (this.gain.disconnect(this.filter),
                    this.filter.disconnect(this.context.destination))
                  : this.gain.disconnect(this.context.destination),
                (this.filter = t),
                this.gain.connect(this.filter),
                this.filter.connect(this.context.destination),
                this
              );
            }
            getMasterVolume() {
              return this.gain.gain.value;
            }
            setMasterVolume(t) {
              return (
                this.gain.gain.setTargetAtTime(
                  t,
                  this.context.currentTime,
                  0.01,
                ),
                this
              );
            }
            updateMatrixWorld(t) {
              super.updateMatrixWorld(t);
              const e = this.context.listener,
                n = this.up;
              if (
                ((this.timeDelta = this._clock.getDelta()),
                this.matrixWorld.decompose(Xu, qu, Yu),
                Ku.set(0, 0, -1).applyQuaternion(qu),
                e.positionX)
              ) {
                const t = this.context.currentTime + this.timeDelta;
                e.positionX.linearRampToValueAtTime(Xu.x, t),
                  e.positionY.linearRampToValueAtTime(Xu.y, t),
                  e.positionZ.linearRampToValueAtTime(Xu.z, t),
                  e.forwardX.linearRampToValueAtTime(Ku.x, t),
                  e.forwardY.linearRampToValueAtTime(Ku.y, t),
                  e.forwardZ.linearRampToValueAtTime(Ku.z, t),
                  e.upX.linearRampToValueAtTime(n.x, t),
                  e.upY.linearRampToValueAtTime(n.y, t),
                  e.upZ.linearRampToValueAtTime(n.z, t);
              } else
                e.setPosition(Xu.x, Xu.y, Xu.z),
                  e.setOrientation(Ku.x, Ku.y, Ku.z, n.x, n.y, n.z);
            }
          },
          AudioLoader: class extends au {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = new cu(this.manager);
              function a(e) {
                i ? i(e) : console.error(e), r.manager.itemError(t);
              }
              s.setResponseType("arraybuffer"),
                s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(
                  t,
                  function (t) {
                    try {
                      const n = t.slice(0);
                      ku.getContext().decodeAudioData(
                        n,
                        function (t) {
                          e(t);
                        },
                        a,
                      );
                    } catch (n) {
                      a(n);
                    }
                  },
                  n,
                  i,
                );
            }
          },
          AxesHelper: class extends ql {
            constructor(t = 1) {
              const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                n = new Mr();
              n.setAttribute("position", new pr(e, 3)),
                n.setAttribute(
                  "color",
                  new pr(
                    [
                      1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6,
                      1,
                    ],
                    3,
                  ),
                );
              super(n, new Bl({ vertexColors: !0, toneMapped: !1 })),
                (this.type = "AxesHelper");
            }
            setColors(t, e, n) {
              const i = new tr(),
                r = this.geometry.attributes.color.array;
              return (
                i.set(t),
                i.toArray(r, 0),
                i.toArray(r, 3),
                i.set(e),
                i.toArray(r, 6),
                i.toArray(r, 9),
                i.set(n),
                i.toArray(r, 12),
                i.toArray(r, 15),
                (this.geometry.attributes.color.needsUpdate = !0),
                this
              );
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          },
          BackSide: ot,
          BasicDepthPacking: 3200,
          BasicShadowMap: 0,
          Bone: Tl,
          BooleanKeyframeTrack: Yh,
          Box2: class {
            constructor(t = new sn(1 / 0, 1 / 0), e = new sn(-1 / 0, -1 / 0)) {
              (this.isBox2 = !0), (this.min = t), (this.max = e);
            }
            set(t, e) {
              return this.min.copy(t), this.max.copy(e), this;
            }
            setFromPoints(t) {
              this.makeEmpty();
              for (let e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
              return this;
            }
            setFromCenterAndSize(t, e) {
              const n = vd.copy(e).multiplyScalar(0.5);
              return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(t) {
              return this.min.copy(t.min), this.max.copy(t.max), this;
            }
            makeEmpty() {
              return (
                (this.min.x = this.min.y = 1 / 0),
                (this.max.x = this.max.y = -1 / 0),
                this
              );
            }
            isEmpty() {
              return this.max.x < this.min.x || this.max.y < this.min.y;
            }
            getCenter(t) {
              return this.isEmpty()
                ? t.set(0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5);
            }
            getSize(t) {
              return this.isEmpty()
                ? t.set(0, 0)
                : t.subVectors(this.max, this.min);
            }
            expandByPoint(t) {
              return this.min.min(t), this.max.max(t), this;
            }
            expandByVector(t) {
              return this.min.sub(t), this.max.add(t), this;
            }
            expandByScalar(t) {
              return this.min.addScalar(-t), this.max.addScalar(t), this;
            }
            containsPoint(t) {
              return !(
                t.x < this.min.x ||
                t.x > this.max.x ||
                t.y < this.min.y ||
                t.y > this.max.y
              );
            }
            containsBox(t) {
              return (
                this.min.x <= t.min.x &&
                t.max.x <= this.max.x &&
                this.min.y <= t.min.y &&
                t.max.y <= this.max.y
              );
            }
            getParameter(t, e) {
              return e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y),
              );
            }
            intersectsBox(t) {
              return !(
                t.max.x < this.min.x ||
                t.min.x > this.max.x ||
                t.max.y < this.min.y ||
                t.min.y > this.max.y
              );
            }
            clampPoint(t, e) {
              return e.copy(t).clamp(this.min, this.max);
            }
            distanceToPoint(t) {
              return this.clampPoint(t, vd).distanceTo(t);
            }
            intersect(t) {
              return (
                this.min.max(t.min),
                this.max.min(t.max),
                this.isEmpty() && this.makeEmpty(),
                this
              );
            }
            union(t) {
              return this.min.min(t.min), this.max.max(t.max), this;
            }
            translate(t) {
              return this.min.add(t), this.max.add(t), this;
            }
            equals(t) {
              return t.min.equals(this.min) && t.max.equals(this.max);
            }
          },
          Box3: Fn,
          Box3Helper: class extends ql {
            constructor(t, e = 16776960) {
              const n = new Uint16Array([
                  0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                  6, 3, 7,
                ]),
                i = new Mr();
              i.setIndex(new hr(n, 1)),
                i.setAttribute(
                  "position",
                  new pr(
                    [
                      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1,
                      -1, -1, -1, -1, 1, -1, -1,
                    ],
                    3,
                  ),
                ),
                super(i, new Bl({ color: e, toneMapped: !1 })),
                (this.box = t),
                (this.type = "Box3Helper"),
                this.geometry.computeBoundingSphere();
            }
            updateMatrixWorld(t) {
              const e = this.box;
              e.isEmpty() ||
                (e.getCenter(this.position),
                e.getSize(this.scale),
                this.scale.multiplyScalar(0.5),
                super.updateMatrixWorld(t));
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          },
          BoxGeometry: Hr,
          BoxHelper: class extends ql {
            constructor(t, e = 16776960) {
              const n = new Uint16Array([
                  0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                  6, 3, 7,
                ]),
                i = new Float32Array(24),
                r = new Mr();
              r.setIndex(new hr(n, 1)),
                r.setAttribute("position", new hr(i, 3)),
                super(r, new Bl({ color: e, toneMapped: !1 })),
                (this.object = t),
                (this.type = "BoxHelper"),
                (this.matrixAutoUpdate = !1),
                this.update();
            }
            update(t) {
              if (
                (void 0 !== t &&
                  console.warn(
                    "THREE.BoxHelper: .update() has no longer arguments.",
                  ),
                void 0 !== this.object && Nd.setFromObject(this.object),
                Nd.isEmpty())
              )
                return;
              const e = Nd.min,
                n = Nd.max,
                i = this.geometry.attributes.position,
                r = i.array;
              (r[0] = n.x),
                (r[1] = n.y),
                (r[2] = n.z),
                (r[3] = e.x),
                (r[4] = n.y),
                (r[5] = n.z),
                (r[6] = e.x),
                (r[7] = e.y),
                (r[8] = n.z),
                (r[9] = n.x),
                (r[10] = e.y),
                (r[11] = n.z),
                (r[12] = n.x),
                (r[13] = n.y),
                (r[14] = e.z),
                (r[15] = e.x),
                (r[16] = n.y),
                (r[17] = e.z),
                (r[18] = e.x),
                (r[19] = e.y),
                (r[20] = e.z),
                (r[21] = n.x),
                (r[22] = e.y),
                (r[23] = e.z),
                (i.needsUpdate = !0),
                this.geometry.computeBoundingSphere();
            }
            setFromObject(t) {
              return (this.object = t), this.update(), this;
            }
            copy(t, e) {
              return super.copy(t, e), (this.object = t.object), this;
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          },
          BufferAttribute: hr,
          BufferGeometry: Mr,
          BufferGeometryLoader: Nu,
          ByteType: 1010,
          Cache: iu,
          Camera: qr,
          CameraHelper: class extends ql {
            constructor(t) {
              const e = new Mr(),
                n = new Bl({
                  color: 16777215,
                  vertexColors: !0,
                  toneMapped: !1,
                }),
                i = [],
                r = [],
                s = {};
              function a(t, e) {
                o(t), o(e);
              }
              function o(t) {
                i.push(0, 0, 0),
                  r.push(0, 0, 0),
                  void 0 === s[t] && (s[t] = []),
                  s[t].push(i.length / 3 - 1);
              }
              a("n1", "n2"),
                a("n2", "n4"),
                a("n4", "n3"),
                a("n3", "n1"),
                a("f1", "f2"),
                a("f2", "f4"),
                a("f4", "f3"),
                a("f3", "f1"),
                a("n1", "f1"),
                a("n2", "f2"),
                a("n3", "f3"),
                a("n4", "f4"),
                a("p", "n1"),
                a("p", "n2"),
                a("p", "n3"),
                a("p", "n4"),
                a("u1", "u2"),
                a("u2", "u3"),
                a("u3", "u1"),
                a("c", "t"),
                a("p", "c"),
                a("cn1", "cn2"),
                a("cn3", "cn4"),
                a("cf1", "cf2"),
                a("cf3", "cf4"),
                e.setAttribute("position", new pr(i, 3)),
                e.setAttribute("color", new pr(r, 3)),
                super(e, n),
                (this.type = "CameraHelper"),
                (this.camera = t),
                this.camera.updateProjectionMatrix &&
                  this.camera.updateProjectionMatrix(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.pointMap = s),
                this.update();
              const l = new tr(16755200),
                c = new tr(16711680),
                h = new tr(43775),
                u = new tr(16777215),
                d = new tr(3355443);
              this.setColors(l, c, h, u, d);
            }
            setColors(t, e, n, i, r) {
              const s = this.geometry.getAttribute("color");
              s.setXYZ(0, t.r, t.g, t.b),
                s.setXYZ(1, t.r, t.g, t.b),
                s.setXYZ(2, t.r, t.g, t.b),
                s.setXYZ(3, t.r, t.g, t.b),
                s.setXYZ(4, t.r, t.g, t.b),
                s.setXYZ(5, t.r, t.g, t.b),
                s.setXYZ(6, t.r, t.g, t.b),
                s.setXYZ(7, t.r, t.g, t.b),
                s.setXYZ(8, t.r, t.g, t.b),
                s.setXYZ(9, t.r, t.g, t.b),
                s.setXYZ(10, t.r, t.g, t.b),
                s.setXYZ(11, t.r, t.g, t.b),
                s.setXYZ(12, t.r, t.g, t.b),
                s.setXYZ(13, t.r, t.g, t.b),
                s.setXYZ(14, t.r, t.g, t.b),
                s.setXYZ(15, t.r, t.g, t.b),
                s.setXYZ(16, t.r, t.g, t.b),
                s.setXYZ(17, t.r, t.g, t.b),
                s.setXYZ(18, t.r, t.g, t.b),
                s.setXYZ(19, t.r, t.g, t.b),
                s.setXYZ(20, t.r, t.g, t.b),
                s.setXYZ(21, t.r, t.g, t.b),
                s.setXYZ(22, t.r, t.g, t.b),
                s.setXYZ(23, t.r, t.g, t.b),
                s.setXYZ(24, e.r, e.g, e.b),
                s.setXYZ(25, e.r, e.g, e.b),
                s.setXYZ(26, e.r, e.g, e.b),
                s.setXYZ(27, e.r, e.g, e.b),
                s.setXYZ(28, e.r, e.g, e.b),
                s.setXYZ(29, e.r, e.g, e.b),
                s.setXYZ(30, e.r, e.g, e.b),
                s.setXYZ(31, e.r, e.g, e.b),
                s.setXYZ(32, n.r, n.g, n.b),
                s.setXYZ(33, n.r, n.g, n.b),
                s.setXYZ(34, n.r, n.g, n.b),
                s.setXYZ(35, n.r, n.g, n.b),
                s.setXYZ(36, n.r, n.g, n.b),
                s.setXYZ(37, n.r, n.g, n.b),
                s.setXYZ(38, i.r, i.g, i.b),
                s.setXYZ(39, i.r, i.g, i.b),
                s.setXYZ(40, r.r, r.g, r.b),
                s.setXYZ(41, r.r, r.g, r.b),
                s.setXYZ(42, r.r, r.g, r.b),
                s.setXYZ(43, r.r, r.g, r.b),
                s.setXYZ(44, r.r, r.g, r.b),
                s.setXYZ(45, r.r, r.g, r.b),
                s.setXYZ(46, r.r, r.g, r.b),
                s.setXYZ(47, r.r, r.g, r.b),
                s.setXYZ(48, r.r, r.g, r.b),
                s.setXYZ(49, r.r, r.g, r.b),
                (s.needsUpdate = !0);
            }
            update() {
              const t = this.geometry,
                e = this.pointMap;
              Pd.projectionMatrixInverse.copy(
                this.camera.projectionMatrixInverse,
              ),
                Ud("c", e, t, Pd, 0, 0, -1),
                Ud("t", e, t, Pd, 0, 0, 1),
                Ud("n1", e, t, Pd, -1, -1, -1),
                Ud("n2", e, t, Pd, 1, -1, -1),
                Ud("n3", e, t, Pd, -1, 1, -1),
                Ud("n4", e, t, Pd, 1, 1, -1),
                Ud("f1", e, t, Pd, -1, -1, 1),
                Ud("f2", e, t, Pd, 1, -1, 1),
                Ud("f3", e, t, Pd, -1, 1, 1),
                Ud("f4", e, t, Pd, 1, 1, 1),
                Ud("u1", e, t, Pd, 0.7, 1.1, -1),
                Ud("u2", e, t, Pd, -0.7, 1.1, -1),
                Ud("u3", e, t, Pd, 0, 2, -1),
                Ud("cf1", e, t, Pd, -1, 0, 1),
                Ud("cf2", e, t, Pd, 1, 0, 1),
                Ud("cf3", e, t, Pd, 0, -1, 1),
                Ud("cf4", e, t, Pd, 0, 1, 1),
                Ud("cn1", e, t, Pd, -1, 0, -1),
                Ud("cn2", e, t, Pd, 1, 0, -1),
                Ud("cn3", e, t, Pd, 0, -1, -1),
                Ud("cn4", e, t, Pd, 0, 1, -1),
                (t.getAttribute("position").needsUpdate = !0);
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          },
          CanvasTexture: class extends An {
            constructor(t, e, n, i, r, s, a, o, l) {
              super(t, e, n, i, r, s, a, o, l),
                (this.isCanvasTexture = !0),
                (this.needsUpdate = !0);
            }
          },
          CapsuleGeometry: Ec,
          CatmullRomCurve3: uc,
          CineonToneMapping: mt,
          CircleGeometry: Ac,
          ClampToEdgeWrapping: wt,
          Clock: Wu,
          Color: tr,
          ColorKeyframeTrack: Kh,
          ColorManagement: xn,
          CompressedArrayTexture: class extends nc {
            constructor(t, e, n, i, r, s) {
              super(t, e, n, r, s),
                (this.isCompressedArrayTexture = !0),
                (this.image.depth = i),
                (this.wrapR = wt);
            }
          },
          CompressedCubeTexture: class extends nc {
            constructor(t, e, n) {
              super(void 0, t[0].width, t[0].height, e, n, yt),
                (this.isCompressedCubeTexture = !0),
                (this.isCubeTexture = !0),
                (this.image = t);
            }
          },
          CompressedTexture: nc,
          CompressedTextureLoader: class extends au {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = [],
                a = new nc(),
                o = new cu(this.manager);
              o.setPath(this.path),
                o.setResponseType("arraybuffer"),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(r.withCredentials);
              let l = 0;
              function c(c) {
                o.load(
                  t[c],
                  function (t) {
                    const n = r.parse(t, !0);
                    (s[c] = {
                      width: n.width,
                      height: n.height,
                      format: n.format,
                      mipmaps: n.mipmaps,
                    }),
                      (l += 1),
                      6 === l &&
                        (1 === n.mipmapCount && (a.minFilter = Lt),
                        (a.image = s),
                        (a.format = n.format),
                        (a.needsUpdate = !0),
                        e && e(a));
                  },
                  n,
                  i,
                );
              }
              if (Array.isArray(t))
                for (let h = 0, u = t.length; h < u; ++h) c(h);
              else
                o.load(
                  t,
                  function (t) {
                    const n = r.parse(t, !0);
                    if (n.isCubemap) {
                      const t = n.mipmaps.length / n.mipmapCount;
                      for (let e = 0; e < t; e++) {
                        s[e] = { mipmaps: [] };
                        for (let t = 0; t < n.mipmapCount; t++)
                          s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                            (s[e].format = n.format),
                            (s[e].width = n.width),
                            (s[e].height = n.height);
                      }
                      a.image = s;
                    } else
                      (a.image.width = n.width),
                        (a.image.height = n.height),
                        (a.mipmaps = n.mipmaps);
                    1 === n.mipmapCount && (a.minFilter = Lt),
                      (a.format = n.format),
                      (a.needsUpdate = !0),
                      e && e(a);
                  },
                  n,
                  i,
                );
              return a;
            }
          },
          ConeGeometry: Cc,
          CubeCamera: Zr,
          CubeReflectionMapping: yt,
          CubeRefractionMapping: xt,
          CubeTexture: Jr,
          CubeTextureLoader: class extends au {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = new Jr();
              r.colorSpace = Ne;
              const s = new hu(this.manager);
              s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
              let a = 0;
              function o(n) {
                s.load(
                  t[n],
                  function (t) {
                    (r.images[n] = t),
                      a++,
                      6 === a && ((r.needsUpdate = !0), e && e(r));
                  },
                  void 0,
                  i,
                );
              }
              for (let l = 0; l < t.length; ++l) o(l);
              return r;
            }
          },
          CubeUVReflectionMapping: bt,
          CubicBezierCurve: mc,
          CubicBezierCurve3: gc,
          CubicInterpolant: Wh,
          CullFaceBack: 1,
          CullFaceFront: 2,
          CullFaceFrontBack: 3,
          CullFaceNone: 0,
          Curve: ic,
          CurvePath: bc,
          CustomBlending: 5,
          CustomToneMapping: vt,
          CylinderGeometry: Rc,
          Cylindrical: class {
            constructor(t = 1, e = 0, n = 0) {
              return (this.radius = t), (this.theta = e), (this.y = n), this;
            }
            set(t, e, n) {
              return (this.radius = t), (this.theta = e), (this.y = n), this;
            }
            copy(t) {
              return (
                (this.radius = t.radius),
                (this.theta = t.theta),
                (this.y = t.y),
                this
              );
            }
            setFromVector3(t) {
              return this.setFromCartesianCoords(t.x, t.y, t.z);
            }
            setFromCartesianCoords(t, e, n) {
              return (
                (this.radius = Math.sqrt(t * t + n * n)),
                (this.theta = Math.atan2(t, n)),
                (this.y = e),
                this
              );
            }
            clone() {
              return new this.constructor().copy(this);
            }
          },
          Data3DTexture: Pn,
          DataArrayTexture: In,
          DataTexture: wl,
          DataTextureLoader: class extends au {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = new wl(),
                a = new cu(this.manager);
              return (
                a.setResponseType("arraybuffer"),
                a.setRequestHeader(this.requestHeader),
                a.setPath(this.path),
                a.setWithCredentials(r.withCredentials),
                a.load(
                  t,
                  function (t) {
                    let n;
                    try {
                      n = r.parse(t);
                    } catch (a) {
                      if (void 0 === i) return void console.error(a);
                      i(a);
                    }
                    if (!n) return i();
                    void 0 !== n.image
                      ? (s.image = n.image)
                      : void 0 !== n.data &&
                        ((s.image.width = n.width),
                        (s.image.height = n.height),
                        (s.image.data = n.data)),
                      (s.wrapS = void 0 !== n.wrapS ? n.wrapS : wt),
                      (s.wrapT = void 0 !== n.wrapT ? n.wrapT : wt),
                      (s.magFilter = void 0 !== n.magFilter ? n.magFilter : Lt),
                      (s.minFilter = void 0 !== n.minFilter ? n.minFilter : Lt),
                      (s.anisotropy =
                        void 0 !== n.anisotropy ? n.anisotropy : 1),
                      void 0 !== n.colorSpace
                        ? (s.colorSpace = n.colorSpace)
                        : void 0 !== n.encoding && (s.encoding = n.encoding),
                      void 0 !== n.flipY && (s.flipY = n.flipY),
                      void 0 !== n.format && (s.format = n.format),
                      void 0 !== n.type && (s.type = n.type),
                      void 0 !== n.mipmaps &&
                        ((s.mipmaps = n.mipmaps), (s.minFilter = Pt)),
                      1 === n.mipmapCount && (s.minFilter = Lt),
                      void 0 !== n.generateMipmaps &&
                        (s.generateMipmaps = n.generateMipmaps),
                      (s.needsUpdate = !0),
                      e && e(s, n);
                  },
                  n,
                  i,
                ),
                s
              );
            }
          },
          DataUtils: or,
          DecrementStencilOp: 7683,
          DecrementWrapStencilOp: 34056,
          DefaultLoadingManager: su,
          DepthFormat: Vt,
          DepthStencilFormat: Wt,
          DepthTexture: Do,
          DirectionalLight: Eu,
          DirectionalLightHelper: class extends Oi {
            constructor(t, e, n) {
              super(),
                (this.light = t),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n),
                (this.type = "DirectionalLightHelper"),
                void 0 === e && (e = 1);
              let i = new Mr();
              i.setAttribute(
                "position",
                new pr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3),
              );
              const r = new Bl({ fog: !1, toneMapped: !1 });
              (this.lightPlane = new Wl(i, r)),
                this.add(this.lightPlane),
                (i = new Mr()),
                i.setAttribute("position", new pr([0, 0, 0, 0, 0, 1], 3)),
                (this.targetLine = new Wl(i, r)),
                this.add(this.targetLine),
                this.update();
            }
            dispose() {
              this.lightPlane.geometry.dispose(),
                this.lightPlane.material.dispose(),
                this.targetLine.geometry.dispose(),
                this.targetLine.material.dispose();
            }
            update() {
              this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1),
                Rd.setFromMatrixPosition(this.light.matrixWorld),
                Cd.setFromMatrixPosition(this.light.target.matrixWorld),
                Ld.subVectors(Cd, Rd),
                this.lightPlane.lookAt(Cd),
                void 0 !== this.color
                  ? (this.lightPlane.material.color.set(this.color),
                    this.targetLine.material.color.set(this.color))
                  : (this.lightPlane.material.color.copy(this.light.color),
                    this.targetLine.material.color.copy(this.light.color)),
                this.targetLine.lookAt(Cd),
                (this.targetLine.scale.z = Ld.length());
            }
          },
          DiscreteInterpolant: Xh,
          DisplayP3ColorSpace: De,
          DodecahedronGeometry: Ic,
          DoubleSide: 2,
          DstAlphaFactor: 206,
          DstColorFactor: 208,
          DynamicCopyUsage: 35050,
          DynamicDrawUsage: 35048,
          DynamicReadUsage: 35049,
          EdgesGeometry: Dc,
          EllipseCurve: rc,
          EqualCompare: 514,
          EqualDepth: 4,
          EqualStencilFunc: 514,
          EquirectangularReflectionMapping: Mt,
          EquirectangularRefractionMapping: St,
          Euler: xi,
          EventDispatcher: Ve,
          ExtrudeGeometry: dh,
          FileLoader: cu,
          Float16BufferAttribute: class extends hr {
            constructor(t, e, n) {
              super(new Uint16Array(t), e, n),
                (this.isFloat16BufferAttribute = !0);
            }
            getX(t) {
              let e = ar(this.array[t * this.itemSize]);
              return this.normalized && (e = en(e, this.array)), e;
            }
            setX(t, e) {
              return (
                this.normalized && (e = nn(e, this.array)),
                (this.array[t * this.itemSize] = sr(e)),
                this
              );
            }
            getY(t) {
              let e = ar(this.array[t * this.itemSize + 1]);
              return this.normalized && (e = en(e, this.array)), e;
            }
            setY(t, e) {
              return (
                this.normalized && (e = nn(e, this.array)),
                (this.array[t * this.itemSize + 1] = sr(e)),
                this
              );
            }
            getZ(t) {
              let e = ar(this.array[t * this.itemSize + 2]);
              return this.normalized && (e = en(e, this.array)), e;
            }
            setZ(t, e) {
              return (
                this.normalized && (e = nn(e, this.array)),
                (this.array[t * this.itemSize + 2] = sr(e)),
                this
              );
            }
            getW(t) {
              let e = ar(this.array[t * this.itemSize + 3]);
              return this.normalized && (e = en(e, this.array)), e;
            }
            setW(t, e) {
              return (
                this.normalized && (e = nn(e, this.array)),
                (this.array[t * this.itemSize + 3] = sr(e)),
                this
              );
            }
            setXY(t, e, n) {
              return (
                (t *= this.itemSize),
                this.normalized &&
                  ((e = nn(e, this.array)), (n = nn(n, this.array))),
                (this.array[t + 0] = sr(e)),
                (this.array[t + 1] = sr(n)),
                this
              );
            }
            setXYZ(t, e, n, i) {
              return (
                (t *= this.itemSize),
                this.normalized &&
                  ((e = nn(e, this.array)),
                  (n = nn(n, this.array)),
                  (i = nn(i, this.array))),
                (this.array[t + 0] = sr(e)),
                (this.array[t + 1] = sr(n)),
                (this.array[t + 2] = sr(i)),
                this
              );
            }
            setXYZW(t, e, n, i, r) {
              return (
                (t *= this.itemSize),
                this.normalized &&
                  ((e = nn(e, this.array)),
                  (n = nn(n, this.array)),
                  (i = nn(i, this.array)),
                  (r = nn(r, this.array))),
                (this.array[t + 0] = sr(e)),
                (this.array[t + 1] = sr(n)),
                (this.array[t + 2] = sr(i)),
                (this.array[t + 3] = sr(r)),
                this
              );
            }
          },
          Float32BufferAttribute: pr,
          Float64BufferAttribute: class extends hr {
            constructor(t, e, n) {
              super(new Float64Array(t), e, n);
            }
          },
          FloatType: Ft,
          Fog: Wo,
          FogExp2: Vo,
          FramebufferTexture: class extends An {
            constructor(t, e) {
              super({ width: t, height: e }),
                (this.isFramebufferTexture = !0),
                (this.magFilter = At),
                (this.minFilter = At),
                (this.generateMipmaps = !1),
                (this.needsUpdate = !0);
            }
          },
          FrontSide: at,
          Frustum: ss,
          GLBufferAttribute: class {
            constructor(t, e, n, i, r) {
              (this.isGLBufferAttribute = !0),
                (this.name = ""),
                (this.buffer = t),
                (this.type = e),
                (this.itemSize = n),
                (this.elementSize = i),
                (this.count = r),
                (this.version = 0);
            }
            set needsUpdate(t) {
              !0 === t && this.version++;
            }
            setBuffer(t) {
              return (this.buffer = t), this;
            }
            setType(t, e) {
              return (this.type = t), (this.elementSize = e), this;
            }
            setItemSize(t) {
              return (this.itemSize = t), this;
            }
            setCount(t) {
              return (this.count = t), this;
            }
          },
          GLSL1: "100",
          GLSL3: ze,
          GreaterCompare: 516,
          GreaterDepth: 6,
          GreaterEqualCompare: 518,
          GreaterEqualDepth: 5,
          GreaterEqualStencilFunc: 518,
          GreaterStencilFunc: 516,
          GridHelper: class extends ql {
            constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
              (n = new tr(n)), (i = new tr(i));
              const r = e / 2,
                s = t / e,
                a = t / 2,
                o = [],
                l = [];
              for (let h = 0, u = 0, d = -a; h <= e; h++, d += s) {
                o.push(-a, 0, d, a, 0, d), o.push(d, 0, -a, d, 0, a);
                const t = h === r ? n : i;
                t.toArray(l, u),
                  (u += 3),
                  t.toArray(l, u),
                  (u += 3),
                  t.toArray(l, u),
                  (u += 3),
                  t.toArray(l, u),
                  (u += 3);
              }
              const c = new Mr();
              c.setAttribute("position", new pr(o, 3)),
                c.setAttribute("color", new pr(l, 3));
              super(c, new Bl({ vertexColors: !0, toneMapped: !1 })),
                (this.type = "GridHelper");
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          },
          Group: Uo,
          HalfFloatType: Bt,
          HemisphereLight: pu,
          HemisphereLightHelper: class extends Oi {
            constructor(t, e, n) {
              super(),
                (this.light = t),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n),
                (this.type = "HemisphereLightHelper");
              const i = new mh(e);
              i.rotateY(0.5 * Math.PI),
                (this.material = new nr({
                  wireframe: !0,
                  fog: !1,
                  toneMapped: !1,
                })),
                void 0 === this.color && (this.material.vertexColors = !0);
              const r = i.getAttribute("position"),
                s = new Float32Array(3 * r.count);
              i.setAttribute("color", new hr(s, 3)),
                this.add(new zr(i, this.material)),
                this.update();
            }
            dispose() {
              this.children[0].geometry.dispose(),
                this.children[0].material.dispose();
            }
            update() {
              const t = this.children[0];
              if (void 0 !== this.color) this.material.color.set(this.color);
              else {
                const e = t.geometry.getAttribute("color");
                Ed.copy(this.light.color), Ad.copy(this.light.groundColor);
                for (let t = 0, n = e.count; t < n; t++) {
                  const i = t < n / 2 ? Ed : Ad;
                  e.setXYZ(t, i.r, i.g, i.b);
                }
                e.needsUpdate = !0;
              }
              this.light.updateWorldMatrix(!0, !1),
                t.lookAt(
                  wd.setFromMatrixPosition(this.light.matrixWorld).negate(),
                );
            }
          },
          HemisphereLightProbe: class extends Lu {
            constructor(t, e, n = 1) {
              super(void 0, n), (this.isHemisphereLightProbe = !0);
              const i = new tr().set(t),
                r = new tr().set(e),
                s = new Nn(i.r, i.g, i.b),
                a = new Nn(r.r, r.g, r.b),
                o = Math.sqrt(Math.PI),
                l = o * Math.sqrt(0.75);
              this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
                this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l);
            }
          },
          IcosahedronGeometry: fh,
          ImageBitmapLoader: Bu,
          ImageLoader: hu,
          ImageUtils: Sn,
          IncrementStencilOp: 7682,
          IncrementWrapStencilOp: 34055,
          InstancedBufferAttribute: Cl,
          InstancedBufferGeometry: Uu,
          InstancedInterleavedBuffer: class extends Xo {
            constructor(t, e, n = 1) {
              super(t, e),
                (this.isInstancedInterleavedBuffer = !0),
                (this.meshPerAttribute = n);
            }
            copy(t) {
              return (
                super.copy(t),
                (this.meshPerAttribute = t.meshPerAttribute),
                this
              );
            }
            clone(t) {
              const e = super.clone(t);
              return (e.meshPerAttribute = this.meshPerAttribute), e;
            }
            toJSON(t) {
              const e = super.toJSON(t);
              return (
                (e.isInstancedInterleavedBuffer = !0),
                (e.meshPerAttribute = this.meshPerAttribute),
                e
              );
            }
          },
          InstancedMesh: Fl,
          Int16BufferAttribute: class extends hr {
            constructor(t, e, n) {
              super(new Int16Array(t), e, n);
            }
          },
          Int32BufferAttribute: class extends hr {
            constructor(t, e, n) {
              super(new Int32Array(t), e, n);
            }
          },
          Int8BufferAttribute: class extends hr {
            constructor(t, e, n) {
              super(new Int8Array(t), e, n);
            }
          },
          IntType: Ot,
          InterleavedBuffer: Xo,
          InterleavedBufferAttribute: Yo,
          Interpolant: Vh,
          InterpolateDiscrete: be,
          InterpolateLinear: Te,
          InterpolateSmooth: we,
          InvertStencilOp: 5386,
          KeepStencilOp: Fe,
          KeyframeTrack: qh,
          LOD: pl,
          LatheGeometry: wc,
          Layers: Mi,
          LessCompare: 513,
          LessDepth: 2,
          LessEqualCompare: 515,
          LessEqualDepth: 3,
          LessEqualStencilFunc: 515,
          LessStencilFunc: 513,
          Light: du,
          LightProbe: Lu,
          Line: Wl,
          Line3: class {
            constructor(t = new Nn(), e = new Nn()) {
              (this.start = t), (this.end = e);
            }
            set(t, e) {
              return this.start.copy(t), this.end.copy(e), this;
            }
            copy(t) {
              return this.start.copy(t.start), this.end.copy(t.end), this;
            }
            getCenter(t) {
              return t.addVectors(this.start, this.end).multiplyScalar(0.5);
            }
            delta(t) {
              return t.subVectors(this.end, this.start);
            }
            distanceSq() {
              return this.start.distanceToSquared(this.end);
            }
            distance() {
              return this.start.distanceTo(this.end);
            }
            at(t, e) {
              return this.delta(e).multiplyScalar(t).add(this.start);
            }
            closestPointToPointParameter(t, e) {
              _d.subVectors(t, this.start), yd.subVectors(this.end, this.start);
              const n = yd.dot(yd);
              let i = yd.dot(_d) / n;
              return e && (i = Ke(i, 0, 1)), i;
            }
            closestPointToPoint(t, e, n) {
              const i = this.closestPointToPointParameter(t, e);
              return this.delta(n).multiplyScalar(i).add(this.start);
            }
            applyMatrix4(t) {
              return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
            }
            equals(t) {
              return t.start.equals(this.start) && t.end.equals(this.end);
            }
            clone() {
              return new this.constructor().copy(this);
            }
          },
          LineBasicMaterial: Bl,
          LineCurve: vc,
          LineCurve3: _c,
          LineDashedMaterial: Oh,
          LineLoop: Yl,
          LineSegments: ql,
          LinearEncoding: Ie,
          LinearFilter: Lt,
          LinearInterpolant: jh,
          LinearMipMapLinearFilter: 1008,
          LinearMipMapNearestFilter: 1007,
          LinearMipmapLinearFilter: Pt,
          LinearMipmapNearestFilter: It,
          LinearSRGBColorSpace: Oe,
          LinearToneMapping: pt,
          Loader: au,
          LoaderUtils: Pu,
          LoadingManager: ru,
          LoopOnce: Se,
          LoopPingPong: 2202,
          LoopRepeat: 2201,
          LuminanceAlphaFormat: 1025,
          LuminanceFormat: 1024,
          MOUSE: et,
          Material: Ki,
          MaterialLoader: Iu,
          MathUtils: rn,
          Matrix3: an,
          Matrix4: hi,
          MaxEquation: 104,
          Mesh: zr,
          MeshBasicMaterial: nr,
          MeshDepthMaterial: Eo,
          MeshDistanceMaterial: Ao,
          MeshLambertMaterial: Uh,
          MeshMatcapMaterial: Nh,
          MeshNormalMaterial: Ph,
          MeshPhongMaterial: Lh,
          MeshPhysicalMaterial: Ch,
          MeshStandardMaterial: Rh,
          MeshToonMaterial: Ih,
          MinEquation: 103,
          MirroredRepeatWrapping: Et,
          MixOperation: ht,
          MultiplyBlending: 4,
          MultiplyOperation: ct,
          NearestFilter: At,
          NearestMipMapLinearFilter: 1005,
          NearestMipMapNearestFilter: 1004,
          NearestMipmapLinearFilter: Ct,
          NearestMipmapNearestFilter: Rt,
          NeverCompare: 512,
          NeverDepth: 0,
          NeverStencilFunc: 512,
          NoBlending: 0,
          NoColorSpace: Ue,
          NoToneMapping: dt,
          NormalAnimationBlendMode: Ce,
          NormalBlending: 1,
          NotEqualCompare: 517,
          NotEqualDepth: 7,
          NotEqualStencilFunc: 517,
          NumberKeyframeTrack: Zh,
          Object3D: Oi,
          ObjectLoader: class extends au {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = "" === this.path ? Pu.extractUrlBase(t) : this.path;
              this.resourcePath = this.resourcePath || s;
              const a = new cu(this.manager);
              a.setPath(this.path),
                a.setRequestHeader(this.requestHeader),
                a.setWithCredentials(this.withCredentials),
                a.load(
                  t,
                  function (n) {
                    let s = null;
                    try {
                      s = JSON.parse(n);
                    } catch (o) {
                      return (
                        void 0 !== i && i(o),
                        void console.error(
                          "THREE:ObjectLoader: Can't parse " + t + ".",
                          o.message,
                        )
                      );
                    }
                    const a = s.metadata;
                    if (
                      void 0 === a ||
                      void 0 === a.type ||
                      "geometry" === a.type.toLowerCase()
                    )
                      return (
                        void 0 !== i &&
                          i(new Error("THREE.ObjectLoader: Can't load " + t)),
                        void console.error(
                          "THREE.ObjectLoader: Can't load " + t,
                        )
                      );
                    r.parse(s, e);
                  },
                  n,
                  i,
                );
            }
            loadAsync(t, e) {
              return c(this, null, function* () {
                const n = "" === this.path ? Pu.extractUrlBase(t) : this.path;
                this.resourcePath = this.resourcePath || n;
                const i = new cu(this.manager);
                i.setPath(this.path),
                  i.setRequestHeader(this.requestHeader),
                  i.setWithCredentials(this.withCredentials);
                const r = yield i.loadAsync(t, e),
                  s = JSON.parse(r),
                  a = s.metadata;
                if (
                  void 0 === a ||
                  void 0 === a.type ||
                  "geometry" === a.type.toLowerCase()
                )
                  throw new Error("THREE.ObjectLoader: Can't load " + t);
                return yield this.parseAsync(s);
              });
            }
            parse(t, e) {
              const n = this.parseAnimations(t.animations),
                i = this.parseShapes(t.shapes),
                r = this.parseGeometries(t.geometries, i),
                s = this.parseImages(t.images, function () {
                  void 0 !== e && e(l);
                }),
                a = this.parseTextures(t.textures, s),
                o = this.parseMaterials(t.materials, a),
                l = this.parseObject(t.object, r, o, a, n),
                c = this.parseSkeletons(t.skeletons, l);
              if ((this.bindSkeletons(l, c), void 0 !== e)) {
                let t = !1;
                for (const e in s)
                  if (s[e].data instanceof HTMLImageElement) {
                    t = !0;
                    break;
                  }
                !1 === t && e(l);
              }
              return l;
            }
            parseAsync(t) {
              return c(this, null, function* () {
                const e = this.parseAnimations(t.animations),
                  n = this.parseShapes(t.shapes),
                  i = this.parseGeometries(t.geometries, n),
                  r = yield this.parseImagesAsync(t.images),
                  s = this.parseTextures(t.textures, r),
                  a = this.parseMaterials(t.materials, s),
                  o = this.parseObject(t.object, i, a, s, e),
                  l = this.parseSkeletons(t.skeletons, o);
                return this.bindSkeletons(o, l), o;
              });
            }
            parseShapes(t) {
              const e = {};
              if (void 0 !== t)
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = new Fc().fromJSON(t[n]);
                  e[i.uuid] = i;
                }
              return e;
            }
            parseSkeletons(t, e) {
              const n = {},
                i = {};
              if (
                (e.traverse(function (t) {
                  t.isBone && (i[t.uuid] = t);
                }),
                void 0 !== t)
              )
                for (let r = 0, s = t.length; r < s; r++) {
                  const e = new Rl().fromJSON(t[r], i);
                  n[e.uuid] = e;
                }
              return n;
            }
            parseGeometries(t, e) {
              const n = {};
              if (void 0 !== t) {
                const i = new Nu();
                for (let r = 0, s = t.length; r < s; r++) {
                  let s;
                  const a = t[r];
                  switch (a.type) {
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                      s = i.parse(a);
                      break;
                    default:
                      a.type in wh
                        ? (s = wh[a.type].fromJSON(a, e))
                        : console.warn(
                            `THREE.ObjectLoader: Unsupported geometry type "${a.type}"`,
                          );
                  }
                  (s.uuid = a.uuid),
                    void 0 !== a.name && (s.name = a.name),
                    void 0 !== a.userData && (s.userData = a.userData),
                    (n[a.uuid] = s);
                }
              }
              return n;
            }
            parseMaterials(t, e) {
              const n = {},
                i = {};
              if (void 0 !== t) {
                const r = new Iu();
                r.setTextures(e);
                for (let e = 0, s = t.length; e < s; e++) {
                  const s = t[e];
                  void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)),
                    (i[s.uuid] = n[s.uuid]);
                }
              }
              return i;
            }
            parseAnimations(t) {
              const e = {};
              if (void 0 !== t)
                for (let n = 0; n < t.length; n++) {
                  const i = t[n],
                    r = eu.parse(i);
                  e[r.uuid] = r;
                }
              return e;
            }
            parseImages(t, e) {
              const n = this,
                i = {};
              let r;
              function s(t) {
                if ("string" == typeof t) {
                  const e = t;
                  return (function (t) {
                    return (
                      n.manager.itemStart(t),
                      r.load(
                        t,
                        function () {
                          n.manager.itemEnd(t);
                        },
                        void 0,
                        function () {
                          n.manager.itemError(t), n.manager.itemEnd(t);
                        },
                      )
                    );
                  })(
                    /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)
                      ? e
                      : n.resourcePath + e,
                  );
                }
                return t.data
                  ? {
                      data: hn(t.type, t.data),
                      width: t.width,
                      height: t.height,
                    }
                  : null;
              }
              if (void 0 !== t && t.length > 0) {
                const n = new ru(e);
                (r = new hu(n)), r.setCrossOrigin(this.crossOrigin);
                for (let e = 0, r = t.length; e < r; e++) {
                  const n = t[e],
                    r = n.url;
                  if (Array.isArray(r)) {
                    const t = [];
                    for (let e = 0, n = r.length; e < n; e++) {
                      const n = s(r[e]);
                      null !== n &&
                        (n instanceof HTMLImageElement
                          ? t.push(n)
                          : t.push(new wl(n.data, n.width, n.height)));
                    }
                    i[n.uuid] = new Tn(t);
                  } else {
                    const t = s(n.url);
                    i[n.uuid] = new Tn(t);
                  }
                }
              }
              return i;
            }
            parseImagesAsync(t) {
              return c(this, null, function* () {
                const e = this,
                  n = {};
                let i;
                function r(t) {
                  return c(this, null, function* () {
                    if ("string" == typeof t) {
                      const n = t,
                        r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)
                          ? n
                          : e.resourcePath + n;
                      return yield i.loadAsync(r);
                    }
                    return t.data
                      ? {
                          data: hn(t.type, t.data),
                          width: t.width,
                          height: t.height,
                        }
                      : null;
                  });
                }
                if (void 0 !== t && t.length > 0) {
                  (i = new hu(this.manager)),
                    i.setCrossOrigin(this.crossOrigin);
                  for (let e = 0, i = t.length; e < i; e++) {
                    const i = t[e],
                      s = i.url;
                    if (Array.isArray(s)) {
                      const t = [];
                      for (let e = 0, n = s.length; e < n; e++) {
                        const n = s[e],
                          i = yield r(n);
                        null !== i &&
                          (i instanceof HTMLImageElement
                            ? t.push(i)
                            : t.push(new wl(i.data, i.width, i.height)));
                      }
                      n[i.uuid] = new Tn(t);
                    } else {
                      const t = yield r(i.url);
                      n[i.uuid] = new Tn(t);
                    }
                  }
                }
                return n;
              });
            }
            parseTextures(t, e) {
              function n(t, e) {
                return "number" == typeof t
                  ? t
                  : (console.warn(
                      "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                      t,
                    ),
                    e[t]);
              }
              const i = {};
              if (void 0 !== t)
                for (let r = 0, s = t.length; r < s; r++) {
                  const s = t[r];
                  void 0 === s.image &&
                    console.warn(
                      'THREE.ObjectLoader: No "image" specified for',
                      s.uuid,
                    ),
                    void 0 === e[s.image] &&
                      console.warn(
                        "THREE.ObjectLoader: Undefined image",
                        s.image,
                      );
                  const a = e[s.image],
                    o = a.data;
                  let l;
                  Array.isArray(o)
                    ? ((l = new Jr()), 6 === o.length && (l.needsUpdate = !0))
                    : ((l = o && o.data ? new wl() : new An()),
                      o && (l.needsUpdate = !0)),
                    (l.source = a),
                    (l.uuid = s.uuid),
                    void 0 !== s.name && (l.name = s.name),
                    void 0 !== s.mapping && (l.mapping = n(s.mapping, Ou)),
                    void 0 !== s.channel && (l.channel = s.channel),
                    void 0 !== s.offset && l.offset.fromArray(s.offset),
                    void 0 !== s.repeat && l.repeat.fromArray(s.repeat),
                    void 0 !== s.center && l.center.fromArray(s.center),
                    void 0 !== s.rotation && (l.rotation = s.rotation),
                    void 0 !== s.wrap &&
                      ((l.wrapS = n(s.wrap[0], Du)),
                      (l.wrapT = n(s.wrap[1], Du))),
                    void 0 !== s.format && (l.format = s.format),
                    void 0 !== s.internalFormat &&
                      (l.internalFormat = s.internalFormat),
                    void 0 !== s.type && (l.type = s.type),
                    void 0 !== s.colorSpace && (l.colorSpace = s.colorSpace),
                    void 0 !== s.encoding && (l.encoding = s.encoding),
                    void 0 !== s.minFilter &&
                      (l.minFilter = n(s.minFilter, Fu)),
                    void 0 !== s.magFilter &&
                      (l.magFilter = n(s.magFilter, Fu)),
                    void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy),
                    void 0 !== s.flipY && (l.flipY = s.flipY),
                    void 0 !== s.generateMipmaps &&
                      (l.generateMipmaps = s.generateMipmaps),
                    void 0 !== s.premultiplyAlpha &&
                      (l.premultiplyAlpha = s.premultiplyAlpha),
                    void 0 !== s.unpackAlignment &&
                      (l.unpackAlignment = s.unpackAlignment),
                    void 0 !== s.compareFunction &&
                      (l.compareFunction = s.compareFunction),
                    void 0 !== s.userData && (l.userData = s.userData),
                    (i[s.uuid] = l);
                }
              return i;
            }
            parseObject(t, e, n, i, r) {
              let s, a, o;
              function l(t) {
                return (
                  void 0 === e[t] &&
                    console.warn("THREE.ObjectLoader: Undefined geometry", t),
                  e[t]
                );
              }
              function c(t) {
                if (void 0 !== t) {
                  if (Array.isArray(t)) {
                    const e = [];
                    for (let i = 0, r = t.length; i < r; i++) {
                      const r = t[i];
                      void 0 === n[r] &&
                        console.warn(
                          "THREE.ObjectLoader: Undefined material",
                          r,
                        ),
                        e.push(n[r]);
                    }
                    return e;
                  }
                  return (
                    void 0 === n[t] &&
                      console.warn("THREE.ObjectLoader: Undefined material", t),
                    n[t]
                  );
                }
              }
              function h(t) {
                return (
                  void 0 === i[t] &&
                    console.warn("THREE.ObjectLoader: Undefined texture", t),
                  i[t]
                );
              }
              switch (t.type) {
                case "Scene":
                  (s = new jo()),
                    void 0 !== t.background &&
                      (Number.isInteger(t.background)
                        ? (s.background = new tr(t.background))
                        : (s.background = h(t.background))),
                    void 0 !== t.environment &&
                      (s.environment = h(t.environment)),
                    void 0 !== t.fog &&
                      ("Fog" === t.fog.type
                        ? (s.fog = new Wo(t.fog.color, t.fog.near, t.fog.far))
                        : "FogExp2" === t.fog.type &&
                          (s.fog = new Vo(t.fog.color, t.fog.density))),
                    void 0 !== t.backgroundBlurriness &&
                      (s.backgroundBlurriness = t.backgroundBlurriness),
                    void 0 !== t.backgroundIntensity &&
                      (s.backgroundIntensity = t.backgroundIntensity);
                  break;
                case "PerspectiveCamera":
                  (s = new Yr(t.fov, t.aspect, t.near, t.far)),
                    void 0 !== t.focus && (s.focus = t.focus),
                    void 0 !== t.zoom && (s.zoom = t.zoom),
                    void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge),
                    void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset),
                    void 0 !== t.view && (s.view = Object.assign({}, t.view));
                  break;
                case "OrthographicCamera":
                  (s = new ys(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                    void 0 !== t.zoom && (s.zoom = t.zoom),
                    void 0 !== t.view && (s.view = Object.assign({}, t.view));
                  break;
                case "AmbientLight":
                  s = new Au(t.color, t.intensity);
                  break;
                case "DirectionalLight":
                  s = new Eu(t.color, t.intensity);
                  break;
                case "PointLight":
                  s = new Tu(t.color, t.intensity, t.distance, t.decay);
                  break;
                case "RectAreaLight":
                  s = new Ru(t.color, t.intensity, t.width, t.height);
                  break;
                case "SpotLight":
                  s = new yu(
                    t.color,
                    t.intensity,
                    t.distance,
                    t.angle,
                    t.penumbra,
                    t.decay,
                  );
                  break;
                case "HemisphereLight":
                  s = new pu(t.color, t.groundColor, t.intensity);
                  break;
                case "LightProbe":
                  s = new Lu().fromJSON(t);
                  break;
                case "SkinnedMesh":
                  (a = l(t.geometry)),
                    (o = c(t.material)),
                    (s = new bl(a, o)),
                    void 0 !== t.bindMode && (s.bindMode = t.bindMode),
                    void 0 !== t.bindMatrix &&
                      s.bindMatrix.fromArray(t.bindMatrix),
                    void 0 !== t.skeleton && (s.skeleton = t.skeleton);
                  break;
                case "Mesh":
                  (a = l(t.geometry)), (o = c(t.material)), (s = new zr(a, o));
                  break;
                case "InstancedMesh":
                  (a = l(t.geometry)), (o = c(t.material));
                  const e = t.count,
                    n = t.instanceMatrix,
                    i = t.instanceColor;
                  (s = new Fl(a, o, e)),
                    (s.instanceMatrix = new Cl(new Float32Array(n.array), 16)),
                    void 0 !== i &&
                      (s.instanceColor = new Cl(
                        new Float32Array(i.array),
                        i.itemSize,
                      ));
                  break;
                case "LOD":
                  s = new pl();
                  break;
                case "Line":
                  s = new Wl(l(t.geometry), c(t.material));
                  break;
                case "LineLoop":
                  s = new Yl(l(t.geometry), c(t.material));
                  break;
                case "LineSegments":
                  s = new ql(l(t.geometry), c(t.material));
                  break;
                case "PointCloud":
                case "Points":
                  s = new tc(l(t.geometry), c(t.material));
                  break;
                case "Sprite":
                  s = new cl(c(t.material));
                  break;
                case "Group":
                  s = new Uo();
                  break;
                case "Bone":
                  s = new Tl();
                  break;
                default:
                  s = new Oi();
              }
              if (
                ((s.uuid = t.uuid),
                void 0 !== t.name && (s.name = t.name),
                void 0 !== t.matrix
                  ? (s.matrix.fromArray(t.matrix),
                    void 0 !== t.matrixAutoUpdate &&
                      (s.matrixAutoUpdate = t.matrixAutoUpdate),
                    s.matrixAutoUpdate &&
                      s.matrix.decompose(s.position, s.quaternion, s.scale))
                  : (void 0 !== t.position && s.position.fromArray(t.position),
                    void 0 !== t.rotation && s.rotation.fromArray(t.rotation),
                    void 0 !== t.quaternion &&
                      s.quaternion.fromArray(t.quaternion),
                    void 0 !== t.scale && s.scale.fromArray(t.scale)),
                void 0 !== t.up && s.up.fromArray(t.up),
                void 0 !== t.castShadow && (s.castShadow = t.castShadow),
                void 0 !== t.receiveShadow &&
                  (s.receiveShadow = t.receiveShadow),
                t.shadow &&
                  (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias),
                  void 0 !== t.shadow.normalBias &&
                    (s.shadow.normalBias = t.shadow.normalBias),
                  void 0 !== t.shadow.radius &&
                    (s.shadow.radius = t.shadow.radius),
                  void 0 !== t.shadow.mapSize &&
                    s.shadow.mapSize.fromArray(t.shadow.mapSize),
                  void 0 !== t.shadow.camera &&
                    (s.shadow.camera = this.parseObject(t.shadow.camera))),
                void 0 !== t.visible && (s.visible = t.visible),
                void 0 !== t.frustumCulled &&
                  (s.frustumCulled = t.frustumCulled),
                void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder),
                void 0 !== t.userData && (s.userData = t.userData),
                void 0 !== t.layers && (s.layers.mask = t.layers),
                void 0 !== t.children)
              ) {
                const a = t.children;
                for (let t = 0; t < a.length; t++)
                  s.add(this.parseObject(a[t], e, n, i, r));
              }
              if (void 0 !== t.animations) {
                const e = t.animations;
                for (let t = 0; t < e.length; t++) {
                  const n = e[t];
                  s.animations.push(r[n]);
                }
              }
              if ("LOD" === t.type) {
                void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate);
                const e = t.levels;
                for (let t = 0; t < e.length; t++) {
                  const n = e[t],
                    i = s.getObjectByProperty("uuid", n.object);
                  void 0 !== i && s.addLevel(i, n.distance, n.hysteresis);
                }
              }
              return s;
            }
            bindSkeletons(t, e) {
              0 !== Object.keys(e).length &&
                t.traverse(function (t) {
                  if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                    const n = e[t.skeleton];
                    void 0 === n
                      ? console.warn(
                          "THREE.ObjectLoader: No skeleton found with UUID:",
                          t.skeleton,
                        )
                      : t.bind(n, t.bindMatrix);
                  }
                });
            }
          },
          ObjectSpaceNormalMap: 1,
          OctahedronGeometry: mh,
          OneFactor: 201,
          OneMinusDstAlphaFactor: 207,
          OneMinusDstColorFactor: 209,
          OneMinusSrcAlphaFactor: 205,
          OneMinusSrcColorFactor: 203,
          OrthographicCamera: ys,
          PCFShadowMap: it,
          PCFSoftShadowMap: rt,
          PMREMGenerator: Rs,
          Path: Tc,
          PerspectiveCamera: Yr,
          Plane: ns,
          PlaneGeometry: ls,
          PlaneHelper: class extends Wl {
            constructor(t, e = 1, n = 16776960) {
              const i = n,
                r = new Mr();
              r.setAttribute(
                "position",
                new pr(
                  [
                    1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0,
                    1, -1, 0, 1, 1, 0,
                  ],
                  3,
                ),
              ),
                r.computeBoundingSphere(),
                super(r, new Bl({ color: i, toneMapped: !1 })),
                (this.type = "PlaneHelper"),
                (this.plane = t),
                (this.size = e);
              const s = new Mr();
              s.setAttribute(
                "position",
                new pr(
                  [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
                  3,
                ),
              ),
                s.computeBoundingSphere(),
                this.add(
                  new zr(
                    s,
                    new nr({
                      color: i,
                      opacity: 0.2,
                      transparent: !0,
                      depthWrite: !1,
                      toneMapped: !1,
                    }),
                  ),
                );
            }
            updateMatrixWorld(t) {
              this.position.set(0, 0, 0),
                this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
                this.lookAt(this.plane.normal),
                this.translateZ(-this.plane.constant),
                super.updateMatrixWorld(t);
            }
            dispose() {
              this.geometry.dispose(),
                this.material.dispose(),
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose();
            }
          },
          PointLight: Tu,
          PointLightHelper: class extends zr {
            constructor(t, e, n) {
              super(
                new _h(e, 4, 2),
                new nr({ wireframe: !0, fog: !1, toneMapped: !1 }),
              ),
                (this.light = t),
                (this.color = n),
                (this.type = "PointLightHelper"),
                (this.matrix = this.light.matrixWorld),
                (this.matrixAutoUpdate = !1),
                this.update();
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
            update() {
              this.light.updateWorldMatrix(!0, !1),
                void 0 !== this.color
                  ? this.material.color.set(this.color)
                  : this.material.color.copy(this.light.color);
            }
          },
          Points: tc,
          PointsMaterial: Kl,
          PolarGridHelper: class extends ql {
            constructor(
              t = 10,
              e = 16,
              n = 8,
              i = 64,
              r = 4473924,
              s = 8947848,
            ) {
              (r = new tr(r)), (s = new tr(s));
              const a = [],
                o = [];
              if (e > 1)
                for (let c = 0; c < e; c++) {
                  const n = (c / e) * (2 * Math.PI),
                    i = Math.sin(n) * t,
                    l = Math.cos(n) * t;
                  a.push(0, 0, 0), a.push(i, 0, l);
                  const h = 1 & c ? r : s;
                  o.push(h.r, h.g, h.b), o.push(h.r, h.g, h.b);
                }
              for (let c = 0; c < n; c++) {
                const e = 1 & c ? r : s,
                  l = t - (t / n) * c;
                for (let t = 0; t < i; t++) {
                  let n = (t / i) * (2 * Math.PI),
                    r = Math.sin(n) * l,
                    s = Math.cos(n) * l;
                  a.push(r, 0, s),
                    o.push(e.r, e.g, e.b),
                    (n = ((t + 1) / i) * (2 * Math.PI)),
                    (r = Math.sin(n) * l),
                    (s = Math.cos(n) * l),
                    a.push(r, 0, s),
                    o.push(e.r, e.g, e.b);
                }
              }
              const l = new Mr();
              l.setAttribute("position", new pr(a, 3)),
                l.setAttribute("color", new pr(o, 3));
              super(l, new Bl({ vertexColors: !0, toneMapped: !1 })),
                (this.type = "PolarGridHelper");
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          },
          PolyhedronGeometry: Lc,
          PositionalAudio: class extends Zu {
            constructor(t) {
              super(t),
                (this.panner = this.context.createPanner()),
                (this.panner.panningModel = "HRTF"),
                this.panner.connect(this.gain);
            }
            connect() {
              super.connect(), this.panner.connect(this.gain);
            }
            disconnect() {
              super.disconnect(), this.panner.disconnect(this.gain);
            }
            getOutput() {
              return this.panner;
            }
            getRefDistance() {
              return this.panner.refDistance;
            }
            setRefDistance(t) {
              return (this.panner.refDistance = t), this;
            }
            getRolloffFactor() {
              return this.panner.rolloffFactor;
            }
            setRolloffFactor(t) {
              return (this.panner.rolloffFactor = t), this;
            }
            getDistanceModel() {
              return this.panner.distanceModel;
            }
            setDistanceModel(t) {
              return (this.panner.distanceModel = t), this;
            }
            getMaxDistance() {
              return this.panner.maxDistance;
            }
            setMaxDistance(t) {
              return (this.panner.maxDistance = t), this;
            }
            setDirectionalCone(t, e, n) {
              return (
                (this.panner.coneInnerAngle = t),
                (this.panner.coneOuterAngle = e),
                (this.panner.coneOuterGain = n),
                this
              );
            }
            updateMatrixWorld(t) {
              if (
                (super.updateMatrixWorld(t),
                !0 === this.hasPlaybackControl && !1 === this.isPlaying)
              )
                return;
              this.matrixWorld.decompose(Ju, $u, Qu),
                td.set(0, 0, 1).applyQuaternion($u);
              const e = this.panner;
              if (e.positionX) {
                const t = this.context.currentTime + this.listener.timeDelta;
                e.positionX.linearRampToValueAtTime(Ju.x, t),
                  e.positionY.linearRampToValueAtTime(Ju.y, t),
                  e.positionZ.linearRampToValueAtTime(Ju.z, t),
                  e.orientationX.linearRampToValueAtTime(td.x, t),
                  e.orientationY.linearRampToValueAtTime(td.y, t),
                  e.orientationZ.linearRampToValueAtTime(td.z, t);
              } else
                e.setPosition(Ju.x, Ju.y, Ju.z),
                  e.setOrientation(td.x, td.y, td.z);
            }
          },
          PropertyBinding: ld,
          PropertyMixer: ed,
          QuadraticBezierCurve: yc,
          QuadraticBezierCurve3: xc,
          Quaternion: Un,
          QuaternionKeyframeTrack: $h,
          QuaternionLinearInterpolant: Jh,
          RED_GREEN_RGTC2_Format: xe,
          RED_RGTC1_Format: 36283,
          REVISION: tt,
          RGBADepthPacking: 3201,
          RGBAFormat: Gt,
          RGBAIntegerFormat: qt,
          RGBA_ASTC_10x10_Format: me,
          RGBA_ASTC_10x5_Format: de,
          RGBA_ASTC_10x6_Format: pe,
          RGBA_ASTC_10x8_Format: fe,
          RGBA_ASTC_12x10_Format: ge,
          RGBA_ASTC_12x12_Format: ve,
          RGBA_ASTC_4x4_Format: re,
          RGBA_ASTC_5x4_Format: se,
          RGBA_ASTC_5x5_Format: ae,
          RGBA_ASTC_6x5_Format: oe,
          RGBA_ASTC_6x6_Format: le,
          RGBA_ASTC_8x5_Format: ce,
          RGBA_ASTC_8x6_Format: he,
          RGBA_ASTC_8x8_Format: ue,
          RGBA_BPTC_Format: _e,
          RGBA_ETC2_EAC_Format: ie,
          RGBA_PVRTC_2BPPV1_Format: ee,
          RGBA_PVRTC_4BPPV1_Format: te,
          RGBA_S3TC_DXT1_Format: Kt,
          RGBA_S3TC_DXT3_Format: Zt,
          RGBA_S3TC_DXT5_Format: Jt,
          RGB_ETC1_Format: 36196,
          RGB_ETC2_Format: ne,
          RGB_PVRTC_2BPPV1_Format: Qt,
          RGB_PVRTC_4BPPV1_Format: $t,
          RGB_S3TC_DXT1_Format: Yt,
          RGFormat: 1030,
          RGIntegerFormat: Xt,
          RawShaderMaterial: Ah,
          Ray: ci,
          Raycaster: class {
            constructor(t, e, n = 0, i = 1 / 0) {
              (this.ray = new ci(t, e)),
                (this.near = n),
                (this.far = i),
                (this.camera = null),
                (this.layers = new Mi()),
                (this.params = {
                  Mesh: {},
                  Line: { threshold: 1 },
                  LOD: {},
                  Points: { threshold: 1 },
                  Sprite: {},
                });
            }
            set(t, e) {
              this.ray.set(t, e);
            }
            setFromCamera(t, e) {
              e.isPerspectiveCamera
                ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                  this.ray.direction
                    .set(t.x, t.y, 0.5)
                    .unproject(e)
                    .sub(this.ray.origin)
                    .normalize(),
                  (this.camera = e))
                : e.isOrthographicCamera
                ? (this.ray.origin
                    .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                    .unproject(e),
                  this.ray.direction
                    .set(0, 0, -1)
                    .transformDirection(e.matrixWorld),
                  (this.camera = e))
                : console.error(
                    "THREE.Raycaster: Unsupported camera type: " + e.type,
                  );
            }
            intersectObject(t, e = !0, n = []) {
              return md(t, this, n, e), n.sort(fd), n;
            }
            intersectObjects(t, e = !0, n = []) {
              for (let i = 0, r = t.length; i < r; i++) md(t[i], this, n, e);
              return n.sort(fd), n;
            }
          },
          RectAreaLight: Ru,
          RedFormat: 1028,
          RedIntegerFormat: jt,
          ReinhardToneMapping: ft,
          RenderTarget: Cn,
          RepeatWrapping: Tt,
          ReplaceStencilOp: 7681,
          ReverseSubtractEquation: 102,
          RingGeometry: gh,
          SIGNED_RED_GREEN_RGTC2_Format: Me,
          SIGNED_RED_RGTC1_Format: ye,
          SRGBColorSpace: Ne,
          Scene: jo,
          ShaderChunk: cs,
          ShaderLib: us,
          ShaderMaterial: Xr,
          ShadowMaterial: Eh,
          Shape: Fc,
          ShapeGeometry: vh,
          ShapePath: class {
            constructor() {
              (this.type = "ShapePath"),
                (this.color = new tr()),
                (this.subPaths = []),
                (this.currentPath = null);
            }
            moveTo(t, e) {
              return (
                (this.currentPath = new Tc()),
                this.subPaths.push(this.currentPath),
                this.currentPath.moveTo(t, e),
                this
              );
            }
            lineTo(t, e) {
              return this.currentPath.lineTo(t, e), this;
            }
            quadraticCurveTo(t, e, n, i) {
              return this.currentPath.quadraticCurveTo(t, e, n, i), this;
            }
            bezierCurveTo(t, e, n, i, r, s) {
              return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this;
            }
            splineThru(t) {
              return this.currentPath.splineThru(t), this;
            }
            toShapes(t) {
              function e(t, e) {
                const n = e.length;
                let i = !1;
                for (let r = n - 1, s = 0; s < n; r = s++) {
                  let n = e[r],
                    a = e[s],
                    o = a.x - n.x,
                    l = a.y - n.y;
                  if (Math.abs(l) > Number.EPSILON) {
                    if (
                      (l < 0 && ((n = e[s]), (o = -o), (a = e[r]), (l = -l)),
                      t.y < n.y || t.y > a.y)
                    )
                      continue;
                    if (t.y === n.y) {
                      if (t.x === n.x) return !0;
                    } else {
                      const e = l * (t.x - n.x) - o * (t.y - n.y);
                      if (0 === e) return !0;
                      if (e < 0) continue;
                      i = !i;
                    }
                  } else {
                    if (t.y !== n.y) continue;
                    if (
                      (a.x <= t.x && t.x <= n.x) ||
                      (n.x <= t.x && t.x <= a.x)
                    )
                      return !0;
                  }
                }
                return i;
              }
              const n = ch.isClockWise,
                i = this.subPaths;
              if (0 === i.length) return [];
              let r, s, a;
              const o = [];
              if (1 === i.length)
                return (
                  (s = i[0]),
                  (a = new Fc()),
                  (a.curves = s.curves),
                  o.push(a),
                  o
                );
              let l = !n(i[0].getPoints());
              l = t ? !l : l;
              const c = [],
                h = [];
              let u,
                d,
                p = [],
                f = 0;
              (h[f] = void 0), (p[f] = []);
              for (let m = 0, g = i.length; m < g; m++)
                (s = i[m]),
                  (u = s.getPoints()),
                  (r = n(u)),
                  (r = t ? !r : r),
                  r
                    ? (!l && h[f] && f++,
                      (h[f] = { s: new Fc(), p: u }),
                      (h[f].s.curves = s.curves),
                      l && f++,
                      (p[f] = []))
                    : p[f].push({ h: s, p: u[0] });
              if (!h[0])
                return (function (t) {
                  const e = [];
                  for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n],
                      r = new Fc();
                    (r.curves = i.curves), e.push(r);
                  }
                  return e;
                })(i);
              if (h.length > 1) {
                let t = !1,
                  n = 0;
                for (let e = 0, i = h.length; e < i; e++) c[e] = [];
                for (let i = 0, r = h.length; i < r; i++) {
                  const r = p[i];
                  for (let s = 0; s < r.length; s++) {
                    const a = r[s];
                    let o = !0;
                    for (let r = 0; r < h.length; r++)
                      e(a.p, h[r].p) &&
                        (i !== r && n++,
                        o ? ((o = !1), c[r].push(a)) : (t = !0));
                    o && c[i].push(a);
                  }
                }
                n > 0 && !1 === t && (p = c);
              }
              for (let m = 0, g = h.length; m < g; m++) {
                (a = h[m].s), o.push(a), (d = p[m]);
                for (let t = 0, e = d.length; t < e; t++) a.holes.push(d[t].h);
              }
              return o;
            }
          },
          ShapeUtils: ch,
          ShortType: 1011,
          Skeleton: Rl,
          SkeletonHelper: class extends ql {
            constructor(t) {
              const e = Td(t),
                n = new Mr(),
                i = [],
                r = [],
                s = new tr(0, 0, 1),
                a = new tr(0, 1, 0);
              for (let o = 0; o < e.length; o++) {
                const t = e[o];
                t.parent &&
                  t.parent.isBone &&
                  (i.push(0, 0, 0),
                  i.push(0, 0, 0),
                  r.push(s.r, s.g, s.b),
                  r.push(a.r, a.g, a.b));
              }
              n.setAttribute("position", new pr(i, 3)),
                n.setAttribute("color", new pr(r, 3));
              super(
                n,
                new Bl({
                  vertexColors: !0,
                  depthTest: !1,
                  depthWrite: !1,
                  toneMapped: !1,
                  transparent: !0,
                }),
              ),
                (this.isSkeletonHelper = !0),
                (this.type = "SkeletonHelper"),
                (this.root = t),
                (this.bones = e),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1);
            }
            updateMatrixWorld(t) {
              const e = this.bones,
                n = this.geometry,
                i = n.getAttribute("position");
              bd.copy(this.root.matrixWorld).invert();
              for (let r = 0, s = 0; r < e.length; r++) {
                const t = e[r];
                t.parent &&
                  t.parent.isBone &&
                  (Sd.multiplyMatrices(bd, t.matrixWorld),
                  Md.setFromMatrixPosition(Sd),
                  i.setXYZ(s, Md.x, Md.y, Md.z),
                  Sd.multiplyMatrices(bd, t.parent.matrixWorld),
                  Md.setFromMatrixPosition(Sd),
                  i.setXYZ(s + 1, Md.x, Md.y, Md.z),
                  (s += 2));
              }
              (n.getAttribute("position").needsUpdate = !0),
                super.updateMatrixWorld(t);
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          },
          SkinnedMesh: bl,
          Source: Tn,
          Sphere: ei,
          SphereGeometry: _h,
          Spherical: gd,
          SphericalHarmonics3: Cu,
          SplineCurve: Mc,
          SpotLight: yu,
          SpotLightHelper: class extends Oi {
            constructor(t, e) {
              super(),
                (this.light = t),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = e),
                (this.type = "SpotLightHelper");
              const n = new Mr(),
                i = [
                  0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0,
                  0, 0, 1, 1, 0, 0, 0, 0, -1, 1,
                ];
              for (let s = 0, a = 1, o = 32; s < o; s++, a++) {
                const t = (s / o) * Math.PI * 2,
                  e = (a / o) * Math.PI * 2;
                i.push(
                  Math.cos(t),
                  Math.sin(t),
                  1,
                  Math.cos(e),
                  Math.sin(e),
                  1,
                );
              }
              n.setAttribute("position", new pr(i, 3));
              const r = new Bl({ fog: !1, toneMapped: !1 });
              (this.cone = new ql(n, r)), this.add(this.cone), this.update();
            }
            dispose() {
              this.cone.geometry.dispose(), this.cone.material.dispose();
            }
            update() {
              this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1);
              const t = this.light.distance ? this.light.distance : 1e3,
                e = t * Math.tan(this.light.angle);
              this.cone.scale.set(e, e, t),
                xd.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(xd),
                void 0 !== this.color
                  ? this.cone.material.color.set(this.color)
                  : this.cone.material.color.copy(this.light.color);
            }
          },
          Sprite: cl,
          SpriteMaterial: Ko,
          SrcAlphaFactor: 204,
          SrcAlphaSaturateFactor: 210,
          SrcColorFactor: 202,
          StaticCopyUsage: 35046,
          StaticDrawUsage: Be,
          StaticReadUsage: 35045,
          StereoCamera: class {
            constructor() {
              (this.type = "StereoCamera"),
                (this.aspect = 1),
                (this.eyeSep = 0.064),
                (this.cameraL = new Yr()),
                this.cameraL.layers.enable(1),
                (this.cameraL.matrixAutoUpdate = !1),
                (this.cameraR = new Yr()),
                this.cameraR.layers.enable(2),
                (this.cameraR.matrixAutoUpdate = !1),
                (this._cache = {
                  focus: null,
                  fov: null,
                  aspect: null,
                  near: null,
                  far: null,
                  zoom: null,
                  eyeSep: null,
                });
            }
            update(t) {
              const e = this._cache;
              if (
                e.focus !== t.focus ||
                e.fov !== t.fov ||
                e.aspect !== t.aspect * this.aspect ||
                e.near !== t.near ||
                e.far !== t.far ||
                e.zoom !== t.zoom ||
                e.eyeSep !== this.eyeSep
              ) {
                (e.focus = t.focus),
                  (e.fov = t.fov),
                  (e.aspect = t.aspect * this.aspect),
                  (e.near = t.near),
                  (e.far = t.far),
                  (e.zoom = t.zoom),
                  (e.eyeSep = this.eyeSep),
                  Vu.copy(t.projectionMatrix);
                const n = e.eyeSep / 2,
                  i = (n * e.near) / e.focus,
                  r = (e.near * Math.tan(Xe * e.fov * 0.5)) / e.zoom;
                let s, a;
                (Gu.elements[12] = -n),
                  (Hu.elements[12] = n),
                  (s = -r * e.aspect + i),
                  (a = r * e.aspect + i),
                  (Vu.elements[0] = (2 * e.near) / (a - s)),
                  (Vu.elements[8] = (a + s) / (a - s)),
                  this.cameraL.projectionMatrix.copy(Vu),
                  (s = -r * e.aspect - i),
                  (a = r * e.aspect - i),
                  (Vu.elements[0] = (2 * e.near) / (a - s)),
                  (Vu.elements[8] = (a + s) / (a - s)),
                  this.cameraR.projectionMatrix.copy(Vu);
              }
              this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Gu),
                this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Hu);
            }
          },
          StreamCopyUsage: 35042,
          StreamDrawUsage: 35040,
          StreamReadUsage: 35041,
          StringKeyframeTrack: Qh,
          SubtractEquation: 101,
          SubtractiveBlending: 3,
          TOUCH: nt,
          TangentSpaceNormalMap: 0,
          TetrahedronGeometry: yh,
          Texture: An,
          TextureLoader: uu,
          TorusGeometry: xh,
          TorusKnotGeometry: Mh,
          Triangle: qi,
          TriangleFanDrawMode: 2,
          TriangleStripDrawMode: 1,
          TrianglesDrawMode: 0,
          TubeGeometry: Sh,
          TwoPassDoubleSide: 2,
          UVMapping: _t,
          Uint16BufferAttribute: ur,
          Uint32BufferAttribute: dr,
          Uint8BufferAttribute: class extends hr {
            constructor(t, e, n) {
              super(new Uint8Array(t), e, n);
            }
          },
          Uint8ClampedBufferAttribute: class extends hr {
            constructor(t, e, n) {
              super(new Uint8ClampedArray(t), e, n);
            }
          },
          Uniform: dd,
          UniformsGroup: class extends Ve {
            constructor() {
              super(),
                (this.isUniformsGroup = !0),
                Object.defineProperty(this, "id", { value: pd++ }),
                (this.name = ""),
                (this.usage = Be),
                (this.uniforms = []);
            }
            add(t) {
              return this.uniforms.push(t), this;
            }
            remove(t) {
              const e = this.uniforms.indexOf(t);
              return -1 !== e && this.uniforms.splice(e, 1), this;
            }
            setName(t) {
              return (this.name = t), this;
            }
            setUsage(t) {
              return (this.usage = t), this;
            }
            dispose() {
              return this.dispatchEvent({ type: "dispose" }), this;
            }
            copy(t) {
              (this.name = t.name), (this.usage = t.usage);
              const e = t.uniforms;
              this.uniforms.length = 0;
              for (let n = 0, i = e.length; n < i; n++)
                this.uniforms.push(e[n].clone());
              return this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
          },
          UniformsLib: hs,
          UniformsUtils: jr,
          UnsignedByteType: Ut,
          UnsignedInt248Type: Ht,
          UnsignedIntType: Dt,
          UnsignedShort4444Type: zt,
          UnsignedShort5551Type: kt,
          UnsignedShortType: Nt,
          VSMShadowMap: st,
          Vector2: sn,
          Vector3: Nn,
          Vector4: Rn,
          VectorKeyframeTrack: tu,
          VideoTexture: class extends An {
            constructor(t, e, n, i, r, s, a, o, l) {
              super(t, e, n, i, r, s, a, o, l),
                (this.isVideoTexture = !0),
                (this.minFilter = void 0 !== s ? s : Lt),
                (this.magFilter = void 0 !== r ? r : Lt),
                (this.generateMipmaps = !1);
              const c = this;
              "requestVideoFrameCallback" in t &&
                t.requestVideoFrameCallback(function e() {
                  (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
                });
            }
            clone() {
              return new this.constructor(this.image).copy(this);
            }
            update() {
              const t = this.image;
              !1 === "requestVideoFrameCallback" in t &&
                t.readyState >= t.HAVE_CURRENT_DATA &&
                (this.needsUpdate = !0);
            }
          },
          WebGL1Renderer: Go,
          WebGL3DRenderTarget: class extends Ln {
            constructor(t = 1, e = 1, n = 1) {
              super(t, e),
                (this.isWebGL3DRenderTarget = !0),
                (this.depth = n),
                (this.texture = new Pn(null, t, e, n)),
                (this.texture.isRenderTargetTexture = !0);
            }
          },
          WebGLArrayRenderTarget: class extends Ln {
            constructor(t = 1, e = 1, n = 1) {
              super(t, e),
                (this.isWebGLArrayRenderTarget = !0),
                (this.depth = n),
                (this.texture = new In(null, t, e, n)),
                (this.texture.isRenderTargetTexture = !0);
            }
          },
          WebGLCoordinateSystem: He,
          WebGLCubeRenderTarget: $r,
          WebGLMultipleRenderTargets: class extends Ln {
            constructor(t = 1, e = 1, n = 1, i = {}) {
              super(t, e, i), (this.isWebGLMultipleRenderTargets = !0);
              const r = this.texture;
              this.texture = [];
              for (let s = 0; s < n; s++)
                (this.texture[s] = r.clone()),
                  (this.texture[s].isRenderTargetTexture = !0);
            }
            setSize(t, e, n = 1) {
              if (this.width !== t || this.height !== e || this.depth !== n) {
                (this.width = t), (this.height = e), (this.depth = n);
                for (let i = 0, r = this.texture.length; i < r; i++)
                  (this.texture[i].image.width = t),
                    (this.texture[i].image.height = e),
                    (this.texture[i].image.depth = n);
                this.dispose();
              }
              this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
            }
            copy(t) {
              this.dispose(),
                (this.width = t.width),
                (this.height = t.height),
                (this.depth = t.depth),
                this.scissor.copy(t.scissor),
                (this.scissorTest = t.scissorTest),
                this.viewport.copy(t.viewport),
                (this.depthBuffer = t.depthBuffer),
                (this.stencilBuffer = t.stencilBuffer),
                null !== t.depthTexture &&
                  (this.depthTexture = t.depthTexture.clone()),
                (this.texture.length = 0);
              for (let e = 0, n = t.texture.length; e < n; e++)
                (this.texture[e] = t.texture[e].clone()),
                  (this.texture[e].isRenderTargetTexture = !0);
              return this;
            }
          },
          WebGLRenderTarget: Ln,
          WebGLRenderer: Ho,
          WebGLUtils: Io,
          WebGPUCoordinateSystem: Ge,
          WireframeGeometry: bh,
          WrapAroundEnding: Re,
          ZeroCurvatureEnding: Ee,
          ZeroFactor: 200,
          ZeroSlopeEnding: Ae,
          ZeroStencilOp: 0,
          _SRGBAFormat: ke,
          sRGBEncoding: Pe,
        },
        Symbol.toStringTag,
        { value: "Module" },
      ),
    ),
    zd = Kd;
  function kd() {
    const t = [
      "keyPanSpeed",
      "stopListenToKeyEvents",
      "quaternion",
      "clientY",
      "256126PpFCfP",
      "_domElementKeyEvents",
      "LEFT",
      "multiplyScalar",
      "updateProjectionMatrix",
      "search",
      "enableRotate",
      "TOUCH_DOLLY_PAN",
      "clientHeight",
      "pointerId",
      "4QshNny",
      "dot",
      "pointercancel",
      "top",
      "addScaledVector",
      "maxPolarAngle",
      "toString",
      "preventDefault",
      "maxAzimuthAngle",
      "deltaY",
      "end",
      "touches",
      "getAzimuthalAngle",
      "max",
      "dispose",
      "36KBIfpC",
      "ONE",
      "MIDDLE",
      "NONE",
      "copy",
      "setFromSpherical",
      "width",
      "DOLLY_ROTATE",
      "pageY",
      "invert",
      "phi",
      "lookAt",
      "maxZoom",
      "normalize",
      "TOUCH_ROTATE",
      "pow",
      "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.",
      "panSpeed",
      "contextmenu",
      "setFromUnitVectors",
      "touchAction",
      "mouseButtons",
      "TOUCH_PAN",
      "button",
      "set",
      "DOLLY",
      "zoomToCursor",
      "matrix",
      "ArrowDown",
      "minPolarAngle",
      "3771439WZeFAY",
      "constructor",
      "enablePan",
      "saveState",
      "sqrt",
      "getPolarAngle",
      "code",
      "setPointerCapture",
      "ctrlKey",
      "pointermove",
      "RIGHT",
      "update",
      "286662wnLBfS",
      "autoRotate",
      "shiftKey",
      "pointerup",
      "crossVectors",
      "BOTTOM",
      "applyQuaternion",
      "enableZoom",
      "cos",
      "getBoundingClientRect",
      "removeEventListener",
      "direction",
      "metaKey",
      "ArrowUp",
      "object",
      "start",
      "zoom",
      "abs",
      "ROTATE",
      "sub",
      "zoomSpeed",
      "enabled",
      "autoRotateSpeed",
      "ArrowRight",
      "isOrthographicCamera",
      "PAN",
      "2696304THEOtR",
      "minAzimuthAngle",
      "unproject",
      "style",
      "clientX",
      "updateMatrixWorld",
      "maxDistance",
      "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.",
      "target",
      "enableDamping",
      "warn",
      "target0",
      "keydown",
      "radius",
      "DEG2RAD",
      "addEventListener",
      "distanceToSquared",
      "subVectors",
      "right",
      "dampingFactor",
      "rotateSpeed",
      "TOUCH_DOLLY_ROTATE",
      "bottom",
      "origin",
      "dispatchEvent",
      "setFromMatrixColumn",
      "minDistance",
      "1551516zbduvk",
      "position",
      "left",
      "length",
      "theta",
      "change",
      "reset",
      "6142112UgXANm",
      "screenSpacePanning",
      "pageX",
      "position0",
      "2031745NUlKUe",
      "releasePointerCapture",
      "min",
      "clone",
      "add",
      "intersectPlane",
      "zoom0",
      "domElement",
      "setFromVector3",
      "wheel",
      "DOLLY_PAN",
      "(((.+)+)+)+$",
      "keys",
    ];
    return (kd = function () {
      return t;
    })();
  }
  !(function (t, e) {
    const n = Kd,
      i = t();
    for (;;)
      try {
        if (
          553851 ===
          -parseInt(n(506)) / 1 +
            -parseInt(n(587)) / 2 +
            -parseInt(n(532)) / 3 +
            (-parseInt(n(597)) / 4) * (parseInt(n(570)) / 5) +
            -parseInt(n(559)) / 6 +
            -parseInt(n(494)) / 7 +
            (parseInt(n(566)) / 8) * (parseInt(n(464)) / 9)
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(kd);
  const Hd = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    Gd = Hd(globalThis, function () {
      const t = Kd;
      return Gd[t(603)]()
        [t(592)]("(((.+)+)+)+$")
        [t(603)]()
        [t(495)](Gd)
        [t(592)](t(581));
    });
  Gd();
  const Vd = { type: zd(564) },
    Wd = { type: zd(521) },
    jd = { type: zd(607) },
    Xd = new ci(),
    qd = new ns(),
    Yd = Math[zd(514)](70 * rn[zd(546)]);
  function Kd(t, e) {
    const n = kd();
    return (Kd = function (t, e) {
      return n[(t -= 461)];
    })(t, e);
  }
  class Zd extends Ve {
    constructor(t, e) {
      const n = zd;
      super(),
        (this[n(520)] = t),
        (this[n(577)] = e),
        (this[n(577)][n(535)][n(484)] = "none"),
        (this.enabled = !0),
        (this[n(540)] = new Nn()),
        (this[n(558)] = 0),
        (this[n(538)] = 1 / 0),
        (this.minZoom = 0),
        (this[n(476)] = 1 / 0),
        (this[n(493)] = 0),
        (this[n(602)] = Math.PI),
        (this[n(533)] = -1 / 0),
        (this[n(605)] = 1 / 0),
        (this[n(541)] = !1),
        (this[n(551)] = 0.05),
        (this.enableZoom = !0),
        (this[n(526)] = 1),
        (this[n(593)] = !0),
        (this[n(552)] = 1),
        (this[n(496)] = !0),
        (this.panSpeed = 1),
        (this.screenSpacePanning = !0),
        (this[n(583)] = 7),
        (this.zoomToCursor = !1),
        (this[n(507)] = !1),
        (this[n(528)] = 2),
        (this[n(582)] = {
          LEFT: "ArrowLeft",
          UP: n(519),
          RIGHT: n(529),
          BOTTOM: n(492),
        }),
        (this[n(485)] = {
          LEFT: et[n(524)],
          MIDDLE: et[n(489)],
          RIGHT: et[n(531)],
        }),
        (this[n(608)] = { ONE: nt[n(524)], TWO: nt[n(580)] }),
        (this[n(543)] = this[n(540)][n(573)]()),
        (this[n(569)] = this.object[n(560)].clone()),
        (this[n(576)] = this[n(520)][n(522)]),
        (this[n(588)] = null),
        (this[n(499)] = function () {
          return o.phi;
        }),
        (this[n(461)] = function () {
          return o[n(563)];
        }),
        (this.getDistance = function () {
          const t = n;
          return this[t(520)][t(560)].distanceTo(this[t(540)]);
        }),
        (this.listenToKeyEvents = function (t) {
          const e = n;
          t[e(547)](e(544), q), (this[e(588)] = t);
        }),
        (this[n(584)] = function () {
          const t = n;
          this[t(588)][t(516)](t(544), q), (this._domElementKeyEvents = null);
        }),
        (this[n(497)] = function () {
          const t = n;
          i[t(543)][t(468)](i[t(540)]),
            i[t(569)][t(468)](i.object.position),
            (i[t(576)] = i[t(520)][t(522)]);
        }),
        (this[n(565)] = function () {
          const t = n;
          i[t(540)][t(468)](i.target0),
            i[t(520)][t(560)][t(468)](i.position0),
            (i[t(520)][t(522)] = i[t(576)]),
            i[t(520)][t(591)](),
            i[t(556)](Vd),
            i[t(505)](),
            (s = r.NONE);
        }),
        (this[n(505)] = (function () {
          const e = n,
            u = new Nn(),
            d = new Un()[e(483)](t.up, new Nn(0, 1, 0)),
            p = d.clone()[e(473)](),
            f = new Nn(),
            m = new Un(),
            g = new Nn(),
            v = 2 * Math.PI;
          return function (_ = null) {
            const y = e,
              b = i.object[y(560)];
            u[y(468)](b).sub(i[y(540)]),
              u[y(512)](d),
              o[y(578)](u),
              i[y(507)] &&
                s === r[y(467)] &&
                E(
                  (function (t) {
                    const e = n;
                    return null !== t
                      ? ((2 * Math.PI) / 60) * i[e(528)] * t
                      : ((2 * Math.PI) / 60 / 60) * i[e(528)];
                  })(_),
                ),
              i[y(541)]
                ? ((o[y(563)] += l[y(563)] * i[y(551)]),
                  (o.phi += l[y(474)] * i.dampingFactor))
                : ((o[y(563)] += l[y(563)]), (o.phi += l[y(474)]));
            let T = i[y(533)],
              w = i[y(605)];
            isFinite(T) &&
              isFinite(w) &&
              (T < -Math.PI ? (T += v) : T > Math.PI && (T -= v),
              w < -Math.PI ? (w += v) : w > Math.PI && (w -= v),
              T <= w
                ? (o[y(563)] = Math[y(462)](T, Math[y(572)](w, o[y(563)])))
                : (o.theta =
                    o.theta > (T + w) / 2
                      ? Math[y(462)](T, o[y(563)])
                      : Math[y(572)](w, o.theta))),
              (o[y(474)] = Math[y(462)](
                i[y(493)],
                Math[y(572)](i[y(602)], o[y(474)]),
              )),
              o.makeSafe(),
              !0 === i[y(541)]
                ? i.target[y(601)](h, i[y(551)])
                : i[y(540)][y(574)](h),
              (i[y(490)] && S) || i[y(520)][y(530)]
                ? (o[y(545)] = N(o[y(545)]))
                : (o[y(545)] = N(o[y(545)] * c)),
              u[y(469)](o),
              u[y(512)](p),
              b[y(468)](i.target)[y(574)](u),
              i[y(520)][y(475)](i[y(540)]),
              !0 === i[y(541)]
                ? ((l[y(563)] *= 1 - i[y(551)]),
                  (l[y(474)] *= 1 - i[y(551)]),
                  h.multiplyScalar(1 - i[y(551)]))
                : (l.set(0, 0, 0), h.set(0, 0, 0));
            let A = !1;
            if (i[y(490)] && S) {
              let e = null;
              if (i[y(520)].isPerspectiveCamera) {
                const t = u[y(562)]();
                e = N(t * c);
                const n = t - e;
                i[y(520)].position[y(601)](x, n), i[y(520)].updateMatrixWorld();
              } else if (i.object[y(530)]) {
                const t = new Nn(M.x, M.y, 0);
                t[y(534)](i[y(520)]),
                  (i.object[y(522)] = Math[y(462)](
                    i.minZoom,
                    Math[y(572)](i[y(476)], i[y(520)][y(522)] / c),
                  )),
                  i[y(520)][y(591)](),
                  (A = !0);
                const n = new Nn(M.x, M.y, 0);
                n[y(534)](i[y(520)]),
                  i[y(520)][y(560)][y(525)](n)[y(574)](t),
                  i[y(520)][y(537)](),
                  (e = u[y(562)]());
              } else
                console[y(542)](
                  "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.",
                ),
                  (i[y(490)] = !1);
              null !== e &&
                (this[y(567)]
                  ? i[y(540)]
                      [y(488)](0, 0, -1)
                      .transformDirection(i[y(520)][y(491)])
                      [y(590)](e)
                      .add(i[y(520)][y(560)])
                  : (Xd[y(555)][y(468)](i[y(520)].position),
                    Xd[y(517)]
                      [y(488)](0, 0, -1)
                      .transformDirection(i.object[y(491)]),
                    Math[y(523)](i[y(520)].up[y(598)](Xd.direction)) < Yd
                      ? t.lookAt(i.target)
                      : (qd.setFromNormalAndCoplanarPoint(
                          i.object.up,
                          i[y(540)],
                        ),
                        Xd[y(575)](qd, i[y(540)]))));
            } else
              i[y(520)][y(530)] &&
                ((i[y(520)][y(522)] = Math.max(
                  i.minZoom,
                  Math[y(572)](i.maxZoom, i.object[y(522)] / c),
                )),
                i[y(520)][y(591)](),
                (A = !0));
            return (
              (c = 1),
              (S = !1),
              !!(
                A ||
                f[y(548)](i.object.position) > a ||
                8 * (1 - m[y(598)](i[y(520)].quaternion)) > a ||
                g[y(548)](i[y(540)]) > 0
              ) &&
                (i[y(556)](Vd),
                f[y(468)](i.object[y(560)]),
                m.copy(i[y(520)][y(585)]),
                g[y(468)](i[y(540)]),
                (A = !1),
                !0)
            );
          };
        })()),
        (this[n(463)] = function () {
          const t = n;
          i.domElement[t(516)](t(482), Y),
            i.domElement[t(516)]("pointerdown", V),
            i.domElement[t(516)]("pointercancel", j),
            i[t(577)].removeEventListener(t(579), X),
            i[t(577)][t(516)]("pointermove", W),
            i.domElement.removeEventListener(t(509), j),
            null !== i._domElementKeyEvents &&
              (i._domElementKeyEvents[t(516)]("keydown", q),
              (i[t(588)] = null));
        });
      const i = this,
        r = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_PAN: 4,
          TOUCH_DOLLY_PAN: 5,
          TOUCH_DOLLY_ROTATE: 6,
        };
      let s = r[n(467)];
      const a = 1e-6,
        o = new gd(),
        l = new gd();
      let c = 1;
      const h = new Nn(),
        u = new sn(),
        d = new sn(),
        p = new sn(),
        f = new sn(),
        m = new sn(),
        g = new sn(),
        v = new sn(),
        _ = new sn(),
        y = new sn(),
        x = new Nn(),
        M = new sn();
      let S = !1;
      const b = [],
        T = {};
      function w() {
        const t = n;
        return Math.pow(0.95, i[t(526)]);
      }
      function E(t) {
        l[n(563)] -= t;
      }
      function A(t) {
        l[n(474)] -= t;
      }
      const R = (function () {
          const t = new Nn();
          return function (e, n) {
            const i = Kd;
            t.setFromMatrixColumn(n, 0), t[i(590)](-e), h[i(574)](t);
          };
        })(),
        C = (function () {
          const t = new Nn();
          return function (e, n) {
            const r = Kd;
            !0 === i.screenSpacePanning
              ? t[r(557)](n, 1)
              : (t[r(557)](n, 0), t[r(510)](i.object.up, t)),
              t[r(590)](e),
              h.add(t);
          };
        })(),
        L = (function () {
          const t = new Nn();
          return function (e, n) {
            const r = Kd,
              s = i[r(577)];
            if (i.object.isPerspectiveCamera) {
              const a = i[r(520)][r(560)];
              t[r(468)](a).sub(i[r(540)]);
              let o = t[r(562)]();
              (o *= Math.tan(((i[r(520)].fov / 2) * Math.PI) / 180)),
                R((2 * e * o) / s.clientHeight, i[r(520)][r(491)]),
                C((2 * n * o) / s.clientHeight, i[r(520)].matrix);
            } else
              i.object[r(530)]
                ? (R(
                    (e * (i[r(520)][r(550)] - i[r(520)][r(561)])) /
                      i[r(520)].zoom /
                      s.clientWidth,
                    i[r(520)][r(491)],
                  ),
                  C(
                    (n * (i[r(520)][r(600)] - i[r(520)][r(554)])) /
                      i[r(520)].zoom /
                      s[r(595)],
                    i.object[r(491)],
                  ))
                : (console.warn(r(480)), (i.enablePan = !1));
          };
        })();
      function I(t) {
        const e = n;
        i[e(520)].isPerspectiveCamera || i[e(520)].isOrthographicCamera
          ? (c /= t)
          : (console[e(542)](e(539)), (i[e(513)] = !1));
      }
      function P(t) {
        const e = n;
        i[e(520)].isPerspectiveCamera || i[e(520)][e(530)]
          ? (c *= t)
          : (console[e(542)](
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.",
            ),
            (i[e(513)] = !1));
      }
      function U(t) {
        const e = n;
        if (!i.zoomToCursor) return;
        S = !0;
        const r = i[e(577)][e(515)](),
          s = t[e(536)] - r.left,
          a = t[e(586)] - r[e(600)],
          o = r[e(470)],
          l = r.height;
        (M.x = (s / o) * 2 - 1),
          (M.y = (-a / l) * 2 + 1),
          x[e(488)](M.x, M.y, 1)
            .unproject(i[e(520)])
            [e(525)](i.object[e(560)])
            [e(477)]();
      }
      function N(t) {
        const e = n;
        return Math.max(i.minDistance, Math[e(572)](i.maxDistance, t));
      }
      function O(t) {
        const e = n;
        u[e(488)](t[e(536)], t.clientY);
      }
      function D(t) {
        const e = n;
        f.set(t[e(536)], t[e(586)]);
      }
      function F() {
        const t = n;
        if (1 === b[t(562)]) u[t(488)](b[0].pageX, b[0].pageY);
        else {
          const e = 0.5 * (b[0][t(568)] + b[1][t(568)]),
            n = 0.5 * (b[0][t(472)] + b[1][t(472)]);
          u[t(488)](e, n);
        }
      }
      function B() {
        const t = n;
        if (1 === b.length) f[t(488)](b[0].pageX, b[0][t(472)]);
        else {
          const e = 0.5 * (b[0][t(568)] + b[1][t(568)]),
            n = 0.5 * (b[0].pageY + b[1].pageY);
          f[t(488)](e, n);
        }
      }
      function z() {
        const t = n,
          e = b[0][t(568)] - b[1].pageX,
          i = b[0][t(472)] - b[1][t(472)],
          r = Math[t(498)](e * e + i * i);
        v[t(488)](0, r);
      }
      function k(t) {
        const e = n;
        if (1 == b[e(562)]) d.set(t[e(568)], t[e(472)]);
        else {
          const n = Z(t),
            i = 0.5 * (t[e(568)] + n.x),
            r = 0.5 * (t[e(472)] + n.y);
          d[e(488)](i, r);
        }
        p[e(549)](d, u).multiplyScalar(i[e(552)]);
        const r = i[e(577)];
        E((2 * Math.PI * p.x) / r[e(595)]),
          A((2 * Math.PI * p.y) / r[e(595)]),
          u[e(468)](d);
      }
      function H(t) {
        const e = n;
        if (1 === b.length) m[e(488)](t[e(568)], t.pageY);
        else {
          const n = Z(t),
            i = 0.5 * (t[e(568)] + n.x),
            r = 0.5 * (t[e(472)] + n.y);
          m[e(488)](i, r);
        }
        g.subVectors(m, f)[e(590)](i[e(481)]), L(g.x, g.y), f.copy(m);
      }
      function G(t) {
        const e = n,
          r = Z(t),
          s = t[e(568)] - r.x,
          a = t.pageY - r.y,
          o = Math[e(498)](s * s + a * a);
        _[e(488)](0, o),
          y[e(488)](0, Math[e(479)](_.y / v.y, i[e(526)])),
          I(y.y),
          v.copy(_);
      }
      function V(t) {
        const e = n;
        var a;
        !1 !== i[e(527)] &&
          (0 === b[e(562)] &&
            (i.domElement[e(501)](t[e(596)]),
            i[e(577)][e(547)](e(503), W),
            i.domElement[e(547)](e(509), j)),
          (a = t),
          b.push(a),
          "touch" === t.pointerType
            ? (function (t) {
                const e = n;
                switch ((K(t), b[e(562)])) {
                  case 1:
                    switch (i[e(608)][e(465)]) {
                      case nt[e(524)]:
                        if (!1 === i[e(593)]) return;
                        F(), (s = r[e(478)]);
                        break;
                      case nt.PAN:
                        if (!1 === i[e(496)]) return;
                        B(), (s = r[e(486)]);
                        break;
                      default:
                        s = r[e(467)];
                    }
                    break;
                  case 2:
                    switch (i[e(608)].TWO) {
                      case nt[e(580)]:
                        if (!1 === i.enableZoom && !1 === i[e(496)]) return;
                        (function () {
                          const t = n;
                          i[t(513)] && z(), i[t(496)] && B();
                        })(),
                          (s = r.TOUCH_DOLLY_PAN);
                        break;
                      case nt[e(471)]:
                        if (!1 === i.enableZoom && !1 === i[e(593)]) return;
                        (function () {
                          const t = n;
                          i[t(513)] && z(), i[t(593)] && F();
                        })(),
                          (s = r.TOUCH_DOLLY_ROTATE);
                        break;
                      default:
                        s = r.NONE;
                    }
                    break;
                  default:
                    s = r[e(467)];
                }
                s !== r[e(467)] && i[e(556)](Wd);
              })(t)
            : (function (t) {
                const e = n;
                let a;
                switch (t[e(487)]) {
                  case 0:
                    a = i[e(485)][e(589)];
                    break;
                  case 1:
                    a = i.mouseButtons[e(466)];
                    break;
                  case 2:
                    a = i[e(485)][e(504)];
                    break;
                  default:
                    a = -1;
                }
                switch (a) {
                  case et.DOLLY:
                    if (!1 === i[e(513)]) return;
                    (function (t) {
                      const e = n;
                      U(t), v[e(488)](t[e(536)], t[e(586)]);
                    })(t),
                      (s = r[e(489)]);
                    break;
                  case et[e(524)]:
                    if (t.ctrlKey || t[e(518)] || t.shiftKey) {
                      if (!1 === i.enablePan) return;
                      D(t), (s = r[e(531)]);
                    } else {
                      if (!1 === i[e(593)]) return;
                      O(t), (s = r[e(524)]);
                    }
                    break;
                  case et[e(531)]:
                    if (t[e(502)] || t[e(518)] || t[e(508)]) {
                      if (!1 === i[e(593)]) return;
                      O(t), (s = r[e(524)]);
                    } else {
                      if (!1 === i[e(496)]) return;
                      D(t), (s = r[e(531)]);
                    }
                    break;
                  default:
                    s = r.NONE;
                }
                s !== r.NONE && i[e(556)](Wd);
              })(t));
      }
      function W(t) {
        !1 !== i[n(527)] &&
          ("touch" === t.pointerType
            ? (function (t) {
                const e = n;
                switch ((K(t), s)) {
                  case r.TOUCH_ROTATE:
                    if (!1 === i[e(593)]) return;
                    k(t), i.update();
                    break;
                  case r.TOUCH_PAN:
                    if (!1 === i[e(496)]) return;
                    H(t), i[e(505)]();
                    break;
                  case r[e(594)]:
                    if (!1 === i.enableZoom && !1 === i[e(496)]) return;
                    (function (t) {
                      const e = n;
                      i.enableZoom && G(t), i[e(496)] && H(t);
                    })(t),
                      i[e(505)]();
                    break;
                  case r[e(553)]:
                    if (!1 === i[e(513)] && !1 === i[e(593)]) return;
                    (function (t) {
                      const e = n;
                      i[e(513)] && G(t), i[e(593)] && k(t);
                    })(t),
                      i[e(505)]();
                    break;
                  default:
                    s = r.NONE;
                }
              })(t)
            : (function (t) {
                const e = n;
                switch (s) {
                  case r.ROTATE:
                    if (!1 === i[e(593)]) return;
                    !(function (t) {
                      const e = n;
                      d[e(488)](t[e(536)], t[e(586)]),
                        p.subVectors(d, u)[e(590)](i.rotateSpeed);
                      const r = i[e(577)];
                      E((2 * Math.PI * p.x) / r[e(595)]),
                        A((2 * Math.PI * p.y) / r[e(595)]),
                        u[e(468)](d),
                        i.update();
                    })(t);
                    break;
                  case r[e(489)]:
                    if (!1 === i.enableZoom) return;
                    !(function (t) {
                      const e = n;
                      _[e(488)](t[e(536)], t.clientY),
                        y[e(549)](_, v),
                        y.y > 0 ? I(w()) : y.y < 0 && P(w()),
                        v[e(468)](_),
                        i[e(505)]();
                    })(t);
                    break;
                  case r[e(531)]:
                    if (!1 === i[e(496)]) return;
                    !(function (t) {
                      const e = n;
                      m.set(t[e(536)], t.clientY),
                        g.subVectors(m, f)[e(590)](i.panSpeed),
                        L(g.x, g.y),
                        f.copy(m),
                        i[e(505)]();
                    })(t);
                }
              })(t));
      }
      function j(t) {
        const e = n;
        (function (t) {
          const e = n;
          delete T[t.pointerId];
          for (let n = 0; n < b[e(562)]; n++)
            if (b[n].pointerId == t[e(596)]) return void b.splice(n, 1);
        })(t),
          0 === b[e(562)] &&
            (i[e(577)][e(571)](t[e(596)]),
            i[e(577)][e(516)](e(503), W),
            i.domElement.removeEventListener(e(509), j)),
          i[e(556)](jd),
          (s = r[e(467)]);
      }
      function X(t) {
        const e = n;
        !1 !== i.enabled &&
          !1 !== i[e(513)] &&
          s === r[e(467)] &&
          (t[e(604)](),
          i[e(556)](Wd),
          (function (t) {
            const e = n;
            U(t), t[e(606)] < 0 ? P(w()) : t[e(606)] > 0 && I(w()), i[e(505)]();
          })(t),
          i.dispatchEvent(jd));
      }
      function q(t) {
        !1 !== i.enabled &&
          !1 !== i.enablePan &&
          (function (t) {
            const e = n;
            let r = !1;
            switch (t[e(500)]) {
              case i.keys.UP:
                t[e(502)] || t[e(518)] || t[e(508)]
                  ? A((2 * Math.PI * i.rotateSpeed) / i[e(577)][e(595)])
                  : L(0, i[e(583)]),
                  (r = !0);
                break;
              case i[e(582)][e(511)]:
                t[e(502)] || t[e(518)] || t[e(508)]
                  ? A((-2 * Math.PI * i.rotateSpeed) / i.domElement[e(595)])
                  : L(0, -i[e(583)]),
                  (r = !0);
                break;
              case i.keys[e(589)]:
                t[e(502)] || t.metaKey || t.shiftKey
                  ? E((2 * Math.PI * i[e(552)]) / i[e(577)][e(595)])
                  : L(i[e(583)], 0),
                  (r = !0);
                break;
              case i[e(582)][e(504)]:
                t[e(502)] || t[e(518)] || t.shiftKey
                  ? E((-2 * Math.PI * i.rotateSpeed) / i.domElement[e(595)])
                  : L(-i.keyPanSpeed, 0),
                  (r = !0);
            }
            r && (t[e(604)](), i[e(505)]());
          })(t);
      }
      function Y(t) {
        !1 !== i[n(527)] && t.preventDefault();
      }
      function K(t) {
        const e = n;
        let i = T[t.pointerId];
        void 0 === i && ((i = new sn()), (T[t.pointerId] = i)),
          i.set(t[e(568)], t[e(472)]);
      }
      function Z(t) {
        const e = n,
          i = t[e(596)] === b[0].pointerId ? b[1] : b[0];
        return T[i[e(596)]];
      }
      i[n(577)][n(547)](n(482), Y),
        i.domElement[n(547)]("pointerdown", V),
        i[n(577)][n(547)](n(599), j),
        i[n(577)][n(547)](n(579), X, { passive: !1 }),
        this.update();
    }
  }
  !(function (t, e) {
    const n = ep,
      i = t();
    for (;;)
      try {
        if (
          116588 ===
          -parseInt(n(242)) / 1 +
            (-parseInt(n(258)) / 2) * (parseInt(n(259)) / 3) +
            (parseInt(n(206)) / 4) * (-parseInt(n(200)) / 5) +
            -parseInt(n(227)) / 6 +
            -parseInt(n(224)) / 7 +
            (-parseInt(n(247)) / 8) * (-parseInt(n(264)) / 9) +
            parseInt(n(186)) / 10
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(tp);
  const Jd = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    $d = Jd(globalThis, function () {
      const t = ep;
      return $d
        .toString()
        [t(194)](t(201))
        [t(174)]()
        [t(171)]($d)
        [t(194)]("(((.+)+)+)+$");
    });
  function Qd(t, e) {
    const n = ep;
    if (0 === e) return console.warn(n(178)), t;
    if (2 === e || 1 === e) {
      let i = t[n(176)]();
      if (null === i) {
        const e = [],
          r = t[n(238)](n(262));
        if (void 0 === r) return console[n(173)](n(240)), t;
        for (let t = 0; t < r.count; t++) e[n(192)](t);
        t[n(170)](e), (i = t.getIndex());
      }
      const r = i[n(187)] - 2,
        s = [];
      if (2 === e)
        for (let t = 1; t <= r; t++)
          s[n(192)](i[n(239)](0)),
            s.push(i[n(239)](t)),
            s[n(192)](i[n(239)](t + 1));
      else
        for (let t = 0; t < r; t++)
          t % 2 == 0
            ? (s[n(192)](i[n(239)](t)),
              s[n(192)](i.getX(t + 1)),
              s[n(192)](i[n(239)](t + 2)))
            : (s[n(192)](i[n(239)](t + 2)),
              s[n(192)](i.getX(t + 1)),
              s[n(192)](i[n(239)](t)));
      s[n(254)] / 3 !== r && console[n(173)](n(223));
      const a = t[n(229)]();
      return a.setIndex(s), a[n(253)](), a;
    }
    return console.error(n(217), e), t;
  }
  function tp() {
    const t = [
      "start",
      "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.",
      "isInterleavedBufferAttribute",
      "generateTangents",
      "meshPerAttribute",
      "copy",
      "setX",
      "5228170gkMlDf",
      "count",
      "log10",
      "subVectors",
      ".  .morphAttributes must be consistent throughout all geometries.",
      "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.",
      "push",
      "set",
      "search",
      '. All geometries must have compatible attributes; make sure "',
      " attribute.",
      "dot",
      "material",
      "sort",
      "305aGoMkN",
      "(((.+)+)+)+$",
      "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ",
      "min",
      "normal",
      "gpuType",
      "2084hITQUB",
      "toNonIndexed",
      "morphTargets",
      "get",
      "isReady",
      "setW",
      "max",
      "array",
      "BYTES_PER_ELEMENT",
      "slice",
      "warn",
      "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
      "AttributeBuffers of different types cannot be interleaved",
      "sub",
      "THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.",
      "normalized",
      "pow",
      "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.",
      "753207VZSpXx",
      "hasAttribute",
      "groups",
      "1288968ooyCPX",
      "morphTargetsRelative",
      "clone",
      "geometry",
      "add",
      "index",
      "tangent",
      "isInstancedInterleavedBufferAttribute",
      "getZ",
      "THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().",
      "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.",
      "getAttribute",
      "getX",
      "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.",
      ". .morphTargetsRelative must be consistent throughout all geometries.",
      "119185oRTNXh",
      "isArray",
      "setY",
      "addScaledVector",
      "THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ",
      "1000sQWGLG",
      "has",
      "crossVectors",
      ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.",
      "attributes",
      "normalize",
      "clearGroups",
      "length",
      "getW",
      'BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.',
      "isSkinnedMesh",
      "2eMvexa",
      "444627QfUcuO",
      "addGroup",
      "size",
      "position",
      "setZ",
      "15507SfZQcP",
      "getY",
      ". The geometry must have either an index or a position attribute",
      "itemSize",
      "fromBufferAttribute",
      "applyBoneTransform",
      "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.",
      "morphAttributes",
      "materialIndex",
      "BufferGeometryUtils: Initialized MikkTSpace library required.",
      "setIndex",
      "constructor",
      "setXYZ",
      "error",
      "toString",
      "setAttribute",
      "getIndex",
      "morphTargetInfluences",
      "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.",
    ];
    return (tp = function () {
      return t;
    })();
  }
  function ep(t, e) {
    const n = tp();
    return (ep = function (t, e) {
      return n[(t -= 161)];
    })(t, e);
  }
  $d();
  const np = sp;
  !(function (t, e) {
    const n = sp,
      i = t();
    for (;;)
      try {
        if (
          642645 ===
          parseInt(n(485)) / 1 +
            (-parseInt(n(551)) / 2) * (parseInt(n(849)) / 3) +
            -parseInt(n(750)) / 4 +
            -parseInt(n(448)) / 5 +
            (-parseInt(n(472)) / 6) * (-parseInt(n(851)) / 7) +
            (parseInt(n(423)) / 8) * (-parseInt(n(728)) / 9) +
            (-parseInt(n(722)) / 10) * (-parseInt(n(435)) / 11)
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(qp);
  const ip = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    rp = ip(globalThis, function () {
      const t = sp;
      return rp.toString().search(t(798))[t(710)]()[t(862)](rp).search(t(798));
    });
  function sp(t, e) {
    const n = qp();
    return (sp = function (t, e) {
      return n[(t -= 405)];
    })(t, e);
  }
  rp();
  class ap extends au {
    constructor(t) {
      const e = sp;
      super(t),
        (this[e(449)] = null),
        (this[e(412)] = null),
        (this.meshoptDecoder = null),
        (this[e(508)] = []),
        this[e(622)](function (t) {
          return new dp(t);
        }),
        this[e(622)](function (t) {
          return new xp(t);
        }),
        this.register(function (t) {
          return new Mp(t);
        }),
        this.register(function (t) {
          return new Sp(t);
        }),
        this[e(622)](function (t) {
          return new fp(t);
        }),
        this[e(622)](function (t) {
          return new mp(t);
        }),
        this[e(622)](function (t) {
          return new gp(t);
        }),
        this[e(622)](function (t) {
          return new vp(t);
        }),
        this[e(622)](function (t) {
          return new up(t);
        }),
        this[e(622)](function (t) {
          return new _p(t);
        }),
        this[e(622)](function (t) {
          return new pp(t);
        }),
        this[e(622)](function (t) {
          return new yp(t);
        }),
        this[e(622)](function (t) {
          return new cp(t);
        }),
        this[e(622)](function (t) {
          return new bp(t);
        }),
        this[e(622)](function (t) {
          return new Tp(t);
        });
    }
    [np(438)](t, e, n, i) {
      const r = np,
        s = this;
      let a;
      (a =
        "" !== this.resourcePath
          ? this[r(717)]
          : "" !== this.path
          ? this.path
          : Pu[r(742)](t)),
        this.manager.itemStart(t);
      const o = function (e) {
          const n = r;
          i ? i(e) : console[n(868)](e),
            s[n(753)].itemError(t),
            s[n(753)][n(405)](t);
        },
        l = new cu(this[r(753)]);
      l[r(603)](this[r(497)]),
        l[r(831)](r(534)),
        l[r(575)](this[r(550)]),
        l[r(772)](this[r(830)]),
        l[r(438)](
          t,
          function (n) {
            const i = r;
            try {
              s[i(859)](
                n,
                a,
                function (n) {
                  const r = i;
                  e(n), s[r(753)].itemEnd(t);
                },
                o,
              );
            } catch (l) {
              o(l);
            }
          },
          n,
          o,
        );
    }
    setDRACOLoader(t) {
      return (this.dracoLoader = t), this;
    }
    [np(596)]() {
      throw new Error(np(586));
    }
    [np(670)](t) {
      return (this.ktx2Loader = t), this;
    }
    setMeshoptDecoder(t) {
      return (this.meshoptDecoder = t), this;
    }
    register(t) {
      return (
        -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
        this
      );
    }
    [np(818)](t) {
      const e = np;
      return (
        -1 !== this[e(508)].indexOf(t) &&
          this.pluginCallbacks.splice(this[e(508)][e(612)](t), 1),
        this
      );
    }
    [np(859)](t, e, n, i) {
      const r = np;
      let s;
      const a = {},
        o = {},
        l = new TextDecoder();
      if (typeof t === r(600)) s = JSON[r(859)](t);
      else if (t instanceof ArrayBuffer) {
        if (l[r(833)](new Uint8Array(t, 0, 4)) === wp) {
          try {
            a[lp[r(623)]] = new Ap(t);
          } catch (h) {
            return void (i && i(h));
          }
          s = JSON[r(859)](a[lp[r(623)]][r(447)]);
        } else s = JSON[r(859)](l[r(833)](t));
      } else s = t;
      if (void 0 === s[r(491)] || s.asset[r(442)][0] < 2)
        return void (i && i(new Error(r(864))));
      const c = new $p(s, {
        path: e || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this[r(550)],
        manager: this[r(753)],
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this[r(812)],
      });
      c[r(453)][r(575)](this[r(550)]);
      for (let u = 0; u < this[r(508)][r(823)]; u++) {
        const t = this[r(508)][u](c);
        (o[t[r(561)]] = t), (a[t[r(561)]] = !0);
      }
      if (s[r(581)])
        for (let u = 0; u < s[r(581)].length; ++u) {
          const t = s[r(581)][u],
            e = s[r(473)] || [];
          switch (t) {
            case lp[r(490)]:
              a[t] = new hp();
              break;
            case lp[r(801)]:
              a[t] = new Rp(s, this[r(449)]);
              break;
            case lp.KHR_TEXTURE_TRANSFORM:
              a[t] = new Cp();
              break;
            case lp[r(773)]:
              a[t] = new Lp();
              break;
            default:
              e[r(612)](t) >= 0 &&
                void 0 === o[t] &&
                console[r(745)](r(779) + t + '".');
          }
        }
      c.setExtensions(a), c[r(634)](o), c[r(859)](n, i);
    }
    [np(415)](t, e) {
      const n = this;
      return new Promise(function (i, r) {
        n[sp(859)](t, e, i, r);
      });
    }
  }
  function op() {
    let t = {};
    return {
      get: function (e) {
        return t[e];
      },
      add: function (e, n) {
        t[e] = n;
      },
      remove: function (e) {
        delete t[e];
      },
      removeAll: function () {
        t = {};
      },
    };
  }
  const lp = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: np(852),
    KHR_LIGHTS_PUNCTUAL: np(590),
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: np(406),
    KHR_MATERIALS_SHEEN: np(819),
    KHR_MATERIALS_SPECULAR: np(521),
    KHR_MATERIALS_TRANSMISSION: np(489),
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: np(542),
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: np(567),
    KHR_TEXTURE_BASISU: np(688),
    KHR_TEXTURE_TRANSFORM: np(673),
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: np(479),
    EXT_TEXTURE_WEBP: np(633),
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: np(706),
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
  };
  class cp {
    constructor(t) {
      const e = np;
      (this.parser = t),
        (this[e(561)] = lp[e(721)]),
        (this[e(752)] = { refs: {}, uses: {} });
    }
    [np(665)]() {
      const t = np,
        e = this[t(792)],
        n = this.parser.json[t(738)] || [];
      for (let i = 0, r = n[t(823)]; i < r; i++) {
        const r = n[i];
        r[t(582)] &&
          r[t(582)][this[t(561)]] &&
          void 0 !== r.extensions[this[t(561)]][t(730)] &&
          e._addNodeRef(this[t(752)], r[t(582)][this.name][t(730)]);
      }
    }
    [np(771)](t) {
      const e = np,
        n = this[e(792)],
        i = e(683) + t;
      let r = n[e(752)].get(i);
      if (r) return r;
      const s = n.json,
        a = (((s.extensions && s.extensions[this.name]) || {})[e(585)] || [])[
          t
        ];
      let o;
      const l = new tr(16777215);
      void 0 !== a[e(580)] && l[e(743)](...a[e(580)], Oe);
      const c = void 0 !== a.range ? a[e(545)] : 0;
      switch (a[e(762)]) {
        case e(724):
          (o = new Eu(l)),
            o[e(693)].position[e(711)](0, 0, -1),
            o.add(o[e(693)]);
          break;
        case e(642):
          (o = new Tu(l)), (o[e(691)] = c);
          break;
        case e(487):
          (o = new yu(l)),
            (o.distance = c),
            (a[e(487)] = a[e(487)] || {}),
            (a[e(487)][e(713)] =
              void 0 !== a[e(487)][e(713)] ? a[e(487)].innerConeAngle : 0),
            (a[e(487)][e(615)] =
              void 0 !== a.spot[e(615)]
                ? a[e(487)].outerConeAngle
                : Math.PI / 4),
            (o[e(754)] = a[e(487)][e(615)]),
            (o.penumbra = 1 - a[e(487)].innerConeAngle / a.spot[e(615)]),
            o.target[e(566)][e(711)](0, 0, -1),
            o[e(427)](o[e(693)]);
          break;
        default:
          throw new Error(
            "THREE.GLTFLoader: Unexpected light type: " + a[e(762)],
          );
      }
      return (
        o[e(566)].set(0, 0, 0),
        (o[e(455)] = 2),
        jp(o, a),
        void 0 !== a[e(805)] && (o.intensity = a.intensity),
        (o[e(561)] = n[e(825)](a[e(561)] || e(410) + t)),
        (r = Promise[e(468)](o)),
        n.cache[e(427)](i, r),
        r
      );
    }
    [np(460)](t, e) {
      const n = np;
      if (t === n(730)) return this[n(771)](e);
    }
    createNodeAttachment(t) {
      const e = np,
        n = this,
        i = this.parser,
        r = i[e(653)].nodes[t],
        s = ((r[e(582)] && r.extensions[this.name]) || {}).light;
      return void 0 === s
        ? null
        : this[e(771)](s)[e(452)](function (t) {
            const r = e;
            return i[r(611)](n[r(752)], s, t);
          });
    }
  }
  let hp = class {
      constructor() {
        const t = np;
        this[t(561)] = lp[t(490)];
      }
      [np(541)]() {
        return nr;
      }
      [np(765)](t, e, n) {
        const i = np,
          r = [];
        (t[i(580)] = new tr(1, 1, 1)), (t.opacity = 1);
        const s = e[i(476)];
        if (s) {
          if (Array.isArray(s[i(866)])) {
            const e = s.baseColorFactor;
            t[i(580)][i(743)](...e, Oe), (t[i(584)] = e[3]);
          }
          void 0 !== s.baseColorTexture &&
            r.push(n[i(700)](t, i(572), s[i(643)], Ne));
        }
        return Promise[i(757)](r);
      }
    },
    up = class {
      constructor(t) {
        const e = np;
        (this[e(792)] = t), (this.name = lp[e(811)]);
      }
      [np(486)](t, e) {
        const n = np,
          i = this[n(792)][n(653)][n(515)][t];
        if (!i[n(582)] || !i[n(582)][this[n(561)]]) return Promise.resolve();
        const r = i[n(582)][this.name][n(598)];
        return void 0 !== r && (e.emissiveIntensity = r), Promise[n(468)]();
      }
    },
    dp = class {
      constructor(t) {
        const e = np;
        (this[e(792)] = t), (this.name = lp[e(444)]);
      }
      [np(541)](t) {
        const e = np,
          n = this[e(792)][e(653)].materials[t];
        return n[e(582)] && n.extensions[this[e(561)]] ? Ch : null;
      }
      extendMaterialParams(t, e) {
        const n = np,
          i = this[n(792)],
          r = i[n(653)].materials[t];
        if (!r[n(582)] || !r[n(582)][this[n(561)]]) return Promise[n(468)]();
        const s = [],
          a = r[n(582)][this.name];
        if (
          (void 0 !== a.clearcoatFactor && (e[n(746)] = a[n(656)]),
          void 0 !== a[n(780)] &&
            s.push(i.assignTexture(e, n(558), a.clearcoatTexture)),
          void 0 !== a[n(869)] && (e[n(739)] = a.clearcoatRoughnessFactor),
          void 0 !== a[n(758)] && s.push(i[n(700)](e, n(820), a[n(758)])),
          void 0 !== a.clearcoatNormalTexture &&
            (s.push(i[n(700)](e, n(810), a.clearcoatNormalTexture)),
            void 0 !== a.clearcoatNormalTexture[n(732)]))
        ) {
          const t = a[n(484)][n(732)];
          e.clearcoatNormalScale = new sn(t, t);
        }
        return Promise[n(757)](s);
      }
    },
    pp = class {
      constructor(t) {
        const e = np;
        (this.parser = t), (this[e(561)] = lp[e(466)]);
      }
      [np(541)](t) {
        const e = np,
          n = this[e(792)][e(653)].materials[t];
        return n[e(582)] && n[e(582)][this[e(561)]] ? Ch : null;
      }
      [np(486)](t, e) {
        const n = np,
          i = this.parser,
          r = i[n(653)][n(515)][t];
        if (!r.extensions || !r[n(582)][this[n(561)]]) return Promise[n(468)]();
        const s = [],
          a = r[n(582)][this.name];
        return (
          void 0 !== a[n(652)] && (e[n(855)] = a[n(652)]),
          void 0 !== a[n(636)] && s[n(647)](i[n(700)](e, n(689), a[n(636)])),
          void 0 !== a.iridescenceIor && (e[n(826)] = a[n(858)]),
          void 0 === e[n(564)] && (e[n(564)] = [100, 400]),
          void 0 !== a[n(857)] && (e[n(564)][0] = a[n(857)]),
          void 0 !== a[n(799)] &&
            (e.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
          void 0 !== a.iridescenceThicknessTexture &&
            s[n(647)](i[n(700)](e, "iridescenceThicknessMap", a[n(465)])),
          Promise[n(757)](s)
        );
      }
    },
    fp = class {
      constructor(t) {
        const e = np;
        (this[e(792)] = t), (this.name = lp[e(441)]);
      }
      [np(541)](t) {
        const e = np,
          n = this[e(792)][e(653)].materials[t];
        return n[e(582)] && n[e(582)][this.name] ? Ch : null;
      }
      [np(486)](t, e) {
        const n = np,
          i = this.parser,
          r = i[n(653)][n(515)][t];
        if (!r.extensions || !r[n(582)][this[n(561)]]) return Promise[n(468)]();
        const s = [];
        (e[n(737)] = new tr(0, 0, 0)), (e[n(494)] = 0), (e.sheen = 1);
        const a = r[n(582)][this.name];
        return (
          void 0 !== a[n(865)] && e[n(737)].setRGB(...a[n(865)], Oe),
          void 0 !== a[n(778)] && (e[n(494)] = a[n(778)]),
          void 0 !== a.sheenColorTexture &&
            s[n(647)](i[n(700)](e, n(562), a[n(854)], Ne)),
          void 0 !== a.sheenRoughnessTexture &&
            s.push(i[n(700)](e, n(492), a.sheenRoughnessTexture)),
          Promise[n(757)](s)
        );
      }
    },
    mp = class {
      constructor(t) {
        const e = np;
        (this[e(792)] = t), (this.name = lp[e(871)]);
      }
      [np(541)](t) {
        const e = np,
          n = this[e(792)][e(653)][e(515)][t];
        return n[e(582)] && n[e(582)][this.name] ? Ch : null;
      }
      extendMaterialParams(t, e) {
        const n = np,
          i = this[n(792)],
          r = i.json[n(515)][t];
        if (!r[n(582)] || !r[n(582)][this[n(561)]]) return Promise[n(468)]();
        const s = [],
          a = r.extensions[this[n(561)]];
        return (
          void 0 !== a[n(459)] && (e[n(627)] = a[n(459)]),
          void 0 !== a.transmissionTexture &&
            s[n(647)](i.assignTexture(e, n(816), a[n(680)])),
          Promise[n(757)](s)
        );
      }
    },
    gp = class {
      constructor(t) {
        const e = np;
        (this[e(792)] = t), (this[e(561)] = lp[e(867)]);
      }
      [np(541)](t) {
        const e = np,
          n = this[e(792)].json[e(515)][t];
        return n[e(582)] && n[e(582)][this[e(561)]] ? Ch : null;
      }
      [np(486)](t, e) {
        const n = np,
          i = this[n(792)],
          r = i[n(653)][n(515)][t];
        if (!r.extensions || !r[n(582)][this[n(561)]]) return Promise[n(468)]();
        const s = [],
          a = r[n(582)][this[n(561)]];
        (e[n(795)] = void 0 !== a[n(650)] ? a[n(650)] : 0),
          void 0 !== a[n(424)] &&
            s[n(647)](i.assignTexture(e, n(861), a.thicknessTexture)),
          (e[n(646)] = a[n(646)] || 1 / 0);
        const o = a[n(687)] || [1, 1, 1];
        return (e[n(687)] = new tr()[n(743)](...o, Oe)), Promise[n(757)](s);
      }
    },
    vp = class {
      constructor(t) {
        const e = np;
        (this[e(792)] = t), (this[e(561)] = lp[e(517)]);
      }
      getMaterialType(t) {
        const e = np,
          n = this[e(792)].json[e(515)][t];
        return n[e(582)] && n[e(582)][this[e(561)]] ? Ch : null;
      }
      extendMaterialParams(t, e) {
        const n = np,
          i = this[n(792)][n(653)][n(515)][t];
        if (!i[n(582)] || !i[n(582)][this[n(561)]]) return Promise.resolve();
        const r = i[n(582)][this[n(561)]];
        return (e.ior = void 0 !== r.ior ? r[n(845)] : 1.5), Promise[n(468)]();
      }
    },
    _p = class {
      constructor(t) {
        const e = np;
        (this.parser = t), (this[e(561)] = lp[e(624)]);
      }
      [np(541)](t) {
        const e = np,
          n = this[e(792)].json[e(515)][t];
        return n[e(582)] && n[e(582)][this[e(561)]] ? Ch : null;
      }
      extendMaterialParams(t, e) {
        const n = np,
          i = this[n(792)],
          r = i[n(653)][n(515)][t];
        if (!r[n(582)] || !r[n(582)][this.name]) return Promise.resolve();
        const s = [],
          a = r[n(582)][this[n(561)]];
        (e[n(576)] = void 0 !== a[n(597)] ? a[n(597)] : 1),
          void 0 !== a.specularTexture &&
            s.push(i[n(700)](e, "specularIntensityMap", a.specularTexture));
        const o = a[n(501)] || [1, 1, 1];
        return (
          (e[n(847)] = new tr()[n(743)](...o, Oe)),
          void 0 !== a[n(782)] &&
            s[n(647)](i[n(700)](e, n(790), a[n(782)], Ne)),
          Promise.all(s)
        );
      }
    },
    yp = class {
      constructor(t) {
        const e = np;
        (this[e(792)] = t), (this[e(561)] = lp[e(418)]);
      }
      getMaterialType(t) {
        const e = np,
          n = this.parser[e(653)][e(515)][t];
        return n[e(582)] && n[e(582)][this[e(561)]] ? Ch : null;
      }
      [np(486)](t, e) {
        const n = np,
          i = this[n(792)],
          r = i[n(653)][n(515)][t];
        if (!r[n(582)] || !r[n(582)][this.name]) return Promise.resolve();
        const s = [],
          a = r.extensions[this[n(561)]];
        return (
          void 0 !== a.anisotropyStrength && (e[n(660)] = a.anisotropyStrength),
          void 0 !== a[n(528)] && (e[n(528)] = a[n(528)]),
          void 0 !== a[n(594)] &&
            s.push(i[n(700)](e, n(507), a.anisotropyTexture)),
          Promise.all(s)
        );
      }
    };
  class xp {
    constructor(t) {
      const e = np;
      (this.parser = t), (this[e(561)] = lp.KHR_TEXTURE_BASISU);
    }
    [np(475)](t) {
      const e = np,
        n = this[e(792)],
        i = n[e(653)],
        r = i[e(614)][t];
      if (!r.extensions || !r[e(582)][this[e(561)]]) return null;
      const s = r.extensions[this[e(561)]],
        a = n[e(413)][e(412)];
      if (!a) {
        if (i[e(473)] && i.extensionsRequired[e(612)](this.name) >= 0)
          throw new Error(e(860));
        return null;
      }
      return n.loadTextureImage(t, s[e(422)], a);
    }
  }
  class Mp {
    constructor(t) {
      const e = np;
      (this[e(792)] = t), (this[e(561)] = lp[e(609)]), (this[e(474)] = null);
    }
    [np(475)](t) {
      const e = np,
        n = this[e(561)],
        i = this[e(792)],
        r = i.json,
        s = r.textures[t];
      if (!s.extensions || !s.extensions[n]) return null;
      const a = s.extensions[n],
        o = r[e(436)][a[e(422)]];
      let l = i.textureLoader;
      if (o.uri) {
        const t = i[e(413)].manager[e(785)](o[e(625)]);
        null !== t && (l = t);
      }
      return this[e(698)]().then(function (s) {
        const o = e;
        if (s) return i[o(429)](t, a[o(422)], l);
        if (r[o(473)] && r[o(473)][o(612)](n) >= 0) throw new Error(o(553));
        return i.loadTexture(t);
      });
    }
    [np(698)]() {
      const t = np;
      return (
        !this[t(474)] &&
          (this[t(474)] = new Promise(function (e) {
            const n = t,
              i = new Image();
            (i[n(663)] = n(777)),
              (i[n(651)] = i[n(789)] =
                function () {
                  e(1 === i[n(505)]);
                });
          })),
        this[t(474)]
      );
    }
  }
  class Sp {
    constructor(t) {
      const e = np;
      (this[e(792)] = t), (this[e(561)] = lp[e(589)]), (this[e(474)] = null);
    }
    [np(475)](t) {
      const e = np,
        n = this.name,
        i = this.parser,
        r = i[e(653)],
        s = r[e(614)][t];
      if (!s.extensions || !s[e(582)][n]) return null;
      const a = s[e(582)][n],
        o = r[e(436)][a.source];
      let l = i.textureLoader;
      if (o[e(625)]) {
        const t = i[e(413)][e(753)][e(785)](o.uri);
        null !== t && (l = t);
      }
      return this[e(698)]()[e(452)](function (s) {
        const o = e;
        if (s) return i[o(429)](t, a[o(422)], l);
        if (r.extensionsRequired && r[o(473)][o(612)](n) >= 0)
          throw new Error(o(631));
        return i[o(475)](t);
      });
    }
    [np(698)]() {
      const t = np;
      return (
        !this[t(474)] &&
          (this[t(474)] = new Promise(function (e) {
            const n = t,
              i = new Image();
            (i[n(663)] = n(876)),
              (i[n(651)] = i[n(789)] =
                function () {
                  e(1 === i[n(505)]);
                });
          })),
        this[t(474)]
      );
    }
  }
  class bp {
    constructor(t) {
      const e = np;
      (this[e(561)] = lp[e(498)]), (this[e(792)] = t);
    }
    [np(842)](t) {
      const e = np,
        n = this.parser[e(653)],
        i = n.bufferViews[t];
      if (i[e(582)] && i[e(582)][this[e(561)]]) {
        const t = i.extensions[this[e(561)]],
          r = this[e(792)][e(460)](e(841), t.buffer),
          s = this[e(792)][e(413)][e(812)];
        if (!s || !s[e(787)]) {
          if (n.extensionsRequired && n[e(473)].indexOf(this[e(561)]) >= 0)
            throw new Error(e(520));
          return null;
        }
        return r.then(function (n) {
          const i = e,
            r = t[i(661)] || 0,
            a = t[i(674)] || 0,
            o = t[i(428)],
            l = t.byteStride,
            c = new Uint8Array(n, r, a);
          return s[i(829)]
            ? s[i(829)](o, l, c, t[i(784)], t[i(668)])[i(452)](function (t) {
                return t[i(841)];
              })
            : s[i(863)].then(function () {
                const e = i,
                  n = new ArrayBuffer(o * l);
                return (
                  s[e(686)](new Uint8Array(n), o, l, c, t[e(784)], t.filter), n
                );
              });
        });
      }
      return null;
    }
  }
  class Tp {
    constructor(t) {
      const e = np;
      (this[e(561)] = lp[e(775)]), (this.parser = t);
    }
    [np(715)](t) {
      const e = np,
        n = this[e(792)][e(653)],
        i = n[e(738)][t];
      if (!i[e(582)] || !i[e(582)][this[e(561)]] || void 0 === i.mesh)
        return null;
      const r = n.meshes[i[e(835)]];
      for (const l of r[e(813)])
        if (
          l[e(784)] !== Np[e(723)] &&
          l[e(784)] !== Np[e(749)] &&
          l[e(784)] !== Np[e(873)] &&
          void 0 !== l[e(784)]
        )
          return null;
      const s = i.extensions[this[e(561)]][e(736)],
        a = [],
        o = {};
      for (const l in s)
        a[e(647)](
          this[e(792)]
            .getDependency("accessor", s[l])
            [e(452)]((t) => ((o[l] = t), o[l])),
        );
      return a[e(823)] < 1
        ? null
        : (a[e(647)](this[e(792)][e(715)](t)),
          Promise[e(757)](a)[e(452)]((t) => {
            const n = e,
              i = t.pop(),
              r = i.isGroup ? i[n(461)] : [i],
              s = t[0][n(428)],
              a = [];
            for (const e of r) {
              const t = new hi(),
                i = new Nn(),
                r = new Un(),
                l = new Nn(1, 1, 1),
                c = new Fl(e[n(679)], e[n(573)], s);
              for (let e = 0; e < s; e++)
                o.TRANSLATION && i[n(579)](o.TRANSLATION, e),
                  o[n(731)] && r[n(579)](o[n(731)], e),
                  o.SCALE && l[n(579)](o.SCALE, e),
                  c[n(704)](e, t.compose(i, r, l));
              for (const s in o)
                s !== n(638) &&
                  s !== n(731) &&
                  "SCALE" !== s &&
                  e[n(679)][n(568)](s, o[s]);
              Oi[n(703)][n(767)][n(628)](c, e),
                this[n(792)][n(839)](c),
                a[n(647)](c);
            }
            return i.isGroup ? (i[n(776)](), i[n(427)](...a), i) : a[0];
          }));
    }
  }
  const wp = "glTF",
    Ep = { JSON: 1313821514, BIN: 5130562 };
  class Ap {
    constructor(t) {
      const e = np;
      (this[e(561)] = lp[e(623)]), (this[e(447)] = null), (this.body = null);
      const n = new DataView(t, 0, 12),
        i = new TextDecoder();
      if (
        ((this[e(587)] = {
          magic: i.decode(new Uint8Array(t[e(519)](0, 4))),
          version: n[e(458)](4, !0),
          length: n.getUint32(8, !0),
        }),
        this.header[e(532)] !== wp)
      )
        throw new Error(e(794));
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const r = this[e(587)].length - 12,
        s = new DataView(t, 12);
      let a = 0;
      for (; a < r; ) {
        const n = s.getUint32(a, !0);
        a += 4;
        const r = s.getUint32(a, !0);
        if (((a += 4), r === Ep[e(610)])) {
          const r = new Uint8Array(t, 12 + a, n);
          this[e(447)] = i[e(833)](r);
        } else if (r === Ep[e(658)]) {
          const i = 12 + a;
          this[e(630)] = t[e(519)](i, i + n);
        }
        a += n;
      }
      if (null === this[e(447)]) throw new Error(e(574));
    }
  }
  class Rp {
    constructor(t, e) {
      const n = np;
      if (!e) throw new Error(n(419));
      (this[n(561)] = lp.KHR_DRACO_MESH_COMPRESSION),
        (this.json = t),
        (this.dracoLoader = e),
        this[n(449)].preload();
    }
    decodePrimitive(t, e) {
      const n = np,
        i = this.json,
        r = this[n(449)],
        s = t[n(582)][this[n(561)]][n(421)],
        a = t.extensions[this[n(561)]][n(736)],
        o = {},
        l = {},
        c = {};
      for (const h in a) {
        const t = zp[h] || h.toLowerCase();
        o[t] = a[h];
      }
      for (const h in t[n(736)]) {
        const e = zp[h] || h.toLowerCase();
        if (void 0 !== a[h]) {
          const r = i.accessors[t[n(736)][h]],
            s = Op[r[n(718)]];
          (c[e] = s[n(561)]), (l[e] = !0 === r[n(525)]);
        }
      }
      return e.getDependency(n(421), s)[n(452)](function (t) {
        return new Promise(function (e) {
          r.decodeDracoFile(
            t,
            function (t) {
              const n = sp;
              for (const e in t[n(736)]) {
                const i = t[n(736)][e],
                  r = l[e];
                void 0 !== r && (i[n(525)] = r);
              }
              e(t);
            },
            o,
            c,
          );
        });
      });
    }
  }
  class Cp {
    constructor() {
      this.name = lp.KHR_TEXTURE_TRANSFORM;
    }
    [np(443)](t, e) {
      const n = np;
      return (void 0 !== e[n(856)] && e[n(856)] !== t[n(433)]) ||
        void 0 !== e[n(734)] ||
        void 0 !== e[n(467)] ||
        void 0 !== e[n(732)]
        ? ((t = t[n(616)]()),
          void 0 !== e[n(856)] && (t[n(433)] = e[n(856)]),
          void 0 !== e[n(734)] && t[n(734)][n(870)](e[n(734)]),
          void 0 !== e[n(467)] && (t[n(467)] = e[n(467)]),
          void 0 !== e[n(732)] && t[n(804)][n(870)](e[n(732)]),
          (t[n(526)] = !0),
          t)
        : t;
    }
  }
  class Lp {
    constructor() {
      const t = np;
      this[t(561)] = lp[t(773)];
    }
  }
  class Ip extends Vh {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    [np(537)](t) {
      const e = np,
        n = this[e(549)],
        i = this[e(797)],
        r = this.valueSize,
        s = t * r * 3 + r;
      for (let a = 0; a !== r; a++) n[a] = i[s + a];
      return n;
    }
    [np(796)](t, e, n, i) {
      const r = np,
        s = this[r(549)],
        a = this[r(797)],
        o = this.valueSize,
        l = 2 * o,
        c = 3 * o,
        h = i - e,
        u = (n - e) / h,
        d = u * u,
        p = d * u,
        f = t * c,
        m = f - c,
        g = -2 * p + 3 * d,
        v = p - d,
        _ = 1 - g,
        y = v - d + u;
      for (let x = 0; x !== o; x++) {
        const t = a[m + x + o],
          e = a[m + x + l] * h,
          n = a[f + x + o],
          i = a[f + x] * h;
        s[x] = _ * t + y * e + g * n + v * i;
      }
      return s;
    }
  }
  const Pp = new Un();
  class Up extends Ip {
    [np(796)](t, e, n, i) {
      const r = np,
        s = super[r(796)](t, e, n, i);
      return Pp[r(870)](s)[r(509)]()[r(493)](s), s;
    }
  }
  const Np = {
      FLOAT: 5126,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      LINEAR: 9729,
      REPEAT: 10497,
      SAMPLER_2D: 35678,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123,
    },
    Op = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array,
    },
    Dp = { 9728: At, 9729: Lt, 9984: Rt, 9985: It, 9986: Ct, 9987: Pt },
    Fp = { 33071: wt, 33648: Et, 10497: Tt },
    Bp = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
    zp = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: np(814),
      TEXCOORD_0: "uv",
      TEXCOORD_1: np(539),
      TEXCOORD_2: np(552),
      TEXCOORD_3: "uv3",
      COLOR_0: np(580),
      WEIGHTS_0: "skinWeight",
      JOINTS_0: np(763),
    },
    kp = {
      scale: np(732),
      translation: np(566),
      rotation: "quaternion",
      weights: "morphTargetInfluences",
    },
    Hp = { CUBICSPLINE: void 0, LINEAR: Te, STEP: be },
    Gp = { OPAQUE: np(434), MASK: np(417), BLEND: "BLEND" };
  function Vp(t) {
    const e = np;
    return (
      void 0 === t[e(425)] &&
        (t.DefaultMaterial = new Rh({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: !1,
          depthTest: !0,
          side: at,
        })),
      t[e(425)]
    );
  }
  function Wp(t, e, n) {
    const i = np;
    for (const r in n[i(582)])
      void 0 === t[r] &&
        ((e[i(478)][i(837)] = e.userData[i(837)] || {}),
        (e[i(478)][i(837)][r] = n[i(582)][r]));
  }
  function jp(t, e) {
    const n = np;
    void 0 !== e.extras &&
      (typeof e.extras === n(802)
        ? Object[n(657)](t[n(478)], e[n(827)])
        : console[n(745)](n(741) + e[n(827)]));
  }
  function Xp(t, e) {
    const n = np;
    if ((t.updateMorphTargets(), void 0 !== e[n(702)]))
      for (let i = 0, r = e.weights[n(823)]; i < r; i++)
        t[n(681)][i] = e.weights[i];
    if (e[n(827)] && Array[n(570)](e.extras[n(655)])) {
      const i = e.extras[n(655)];
      if (t.morphTargetInfluences[n(823)] === i[n(823)]) {
        t[n(430)] = {};
        for (let e = 0, r = i[n(823)]; e < r; e++) t[n(430)][i[e]] = e;
      } else
        console[n(745)](
          "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.",
        );
    }
  }
  function qp() {
    const t = [
      "THREE.GLTFLoader: No DRACOLoader instance provided.",
      "THREE.GLTFLoader: Couldn't load texture",
      "bufferView",
      "source",
      "3368HAFkhw",
      "thicknessTexture",
      "DefaultMaterial",
      "loadNode",
      "add",
      "count",
      "loadTextureImage",
      "morphTargetDictionary",
      "values",
      "normalMap",
      "channel",
      "OPAQUE",
      "22xSBkzG",
      "images",
      "sampler",
      "load",
      "catch",
      "ClonedMaterial:",
      "KHR_MATERIALS_SHEEN",
      "version",
      "extendTexture",
      "KHR_MATERIALS_CLEARCOAT",
      'THREE.GLTFLoader: Failed to load buffer "',
      "uses",
      "content",
      "3455780GIBpyA",
      "dracoLoader",
      "setCrossOrigin",
      "associations",
      "then",
      "fileLoader",
      "index",
      "decay",
      "floor",
      "scene",
      "getUint32",
      "transmissionFactor",
      "getDependency",
      "children",
      "loadCamera",
      "roughnessMap",
      "updateMatrix",
      "iridescenceThicknessTexture",
      "KHR_MATERIALS_IRIDESCENCE",
      "rotation",
      "resolve",
      "radius",
      "unshift",
      "isInterpolantFactoryMethodGLTFCubicSpline",
      "54RibvYS",
      "extensionsRequired",
      "isSupported",
      "loadTexture",
      "pbrMetallicRoughness",
      "KHR_TEXTURE_TRANSFORM",
      "userData",
      "KHR_materials_emissive_strength",
      "PointsMaterial:",
      "_invokeOne",
      "setExtensions",
      "LineBasicMaterial:",
      "clearcoatNormalTexture",
      "753704bIqfpi",
      "extendMaterialParams",
      "spot",
      "normalizeSkinWeights",
      "KHR_materials_transmission",
      "KHR_MATERIALS_UNLIT",
      "asset",
      "sheenRoughnessMap",
      "toArray",
      "sheenRoughness",
      "metalness",
      "_instance_",
      "path",
      "EXT_MESHOPT_COMPRESSION",
      "applyMatrix4",
      "resolveURL",
      "specularColorFactor",
      "wrapS",
      "targets",
      "uuid",
      "height",
      "THREE.GLTFLoader: Missing camera parameters.",
      "anisotropyMap",
      "pluginCallbacks",
      "normalize",
      "itemSize",
      "isSkinnedMesh",
      "output",
      "toLowerCase",
      "createNodeAttachment",
      "materials",
      "plugins",
      "KHR_MATERIALS_IOR",
      "metallicRoughnessTexture",
      "slice",
      "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files",
      "KHR_materials_specular",
      'THREE.GLTFLoader: Joint "%s" could not be found.',
      "quaternion",
      "forEach",
      "normalized",
      "needsUpdate",
      "_addNodeRef",
      "anisotropyRotation",
      "createInterpolant",
      "LINE_STRIP",
      "xmag",
      "magic",
      "metallicFactor",
      "arraybuffer",
      "loadBuffer",
      "indices",
      "copySampleValue_",
      "loadMesh",
      "uv1",
      "strength",
      "getMaterialType",
      "KHR_materials_anisotropy",
      "joints",
      "cameras",
      "range",
      "zfar",
      "beforeRoot",
      "emissiveFactor",
      "resultBuffer",
      "requestHeader",
      "2UoshRo",
      "uv2",
      "THREE.GLTFLoader: WebP required by asset but unsupported.",
      "THREE.GLTFLoader: ",
      "emissiveMap",
      "BLEND",
      "camera",
      "clearcoatMap",
      "crossOrigin",
      "decodePrimitive",
      "name",
      "sheenColorMap",
      "input",
      "iridescenceThicknessRange",
      "workingColorSpace",
      "position",
      "KHR_materials_volume",
      "setAttribute",
      "isPoints",
      "isArray",
      "sort",
      "map",
      "material",
      "THREE.GLTFLoader: JSON content not found.",
      "setRequestHeader",
      "specularIntensity",
      "sizeAttenuation",
      "wrapT",
      "fromBufferAttribute",
      "color",
      "extensionsUsed",
      "extensions",
      "sourceCache",
      "opacity",
      "lights",
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
      "header",
      "depthWrite",
      "EXT_TEXTURE_AVIF",
      "KHR_lights_punctual",
      "nodeCache",
      "isImageBitmapLoader",
      "nodeNamesUsed",
      "anisotropyTexture",
      "sparse",
      "setDDSLoader",
      "specularFactor",
      "emissiveStrength",
      "isBone",
      "string",
      "_loadNodeShallow",
      "cameraCache",
      "setPath",
      "yfov",
      "meshCache",
      "minFilter",
      "buffers",
      "COLOR_0",
      "EXT_TEXTURE_WEBP",
      "JSON",
      "_getNodeRef",
      "indexOf",
      "_createAnimationTracks",
      "textures",
      "outerConeAngle",
      "clone",
      "textureLoader",
      "removeAll",
      "_getArrayFromAccessor",
      "abs",
      "sanitizeNodeName",
      "register",
      "KHR_BINARY_GLTF",
      "KHR_MATERIALS_SPECULAR",
      "uri",
      "max",
      "transmission",
      "call",
      "match",
      "body",
      "THREE.GLTFLoader: AVIF required by asset but unsupported.",
      "morphAttributes",
      "EXT_texture_webp",
      "setPlugins",
      "setX",
      "iridescenceTexture",
      "roughnessFactor",
      "TRANSLATION",
      "flipY",
      "flatShading",
      "loadGeometries",
      "point",
      "baseColorTexture",
      "radToDeg",
      "draco:",
      "attenuationDistance",
      "push",
      "pop",
      "use-credentials",
      "thicknessFactor",
      "onload",
      "iridescenceFactor",
      "json",
      "refs",
      "targetNames",
      "clearcoatFactor",
      "assign",
      "BIN",
      "textureCache",
      "anisotropy",
      "byteOffset",
      "THREE.GLTFLoader: Unsupported normalized accessor component type.",
      "src",
      "loadMaterial",
      "_markDefs",
      "emissive",
      "loadSkin",
      "filter",
      "znear",
      "setKTX2Loader",
      "promise",
      "samplers",
      "KHR_texture_transform",
      "byteLength",
      "occlusionTexture",
      "entries",
      "vertexColors",
      "THREE.GLTFLoader: Primitive mode unsupported: ",
      "geometry",
      "transmissionTexture",
      "morphTargetInfluences",
      "multiplyScalar",
      "light:",
      "keys",
      "flat-shading:",
      "decodeGltfBuffer",
      "attenuationColor",
      "KHR_texture_basisu",
      "iridescenceMap",
      "_invokeAll",
      "distance",
      "mesh_",
      "target",
      "center",
      "loadScene",
      '" not supported.',
      "accessor",
      "detectSupport",
      "min",
      "assignTexture",
      "magFilter",
      "weights",
      "prototype",
      "setMatrixAt",
      "lightCache",
      "EXT_meshopt_compression",
      "search",
      "scenes",
      "accessors",
      "toString",
      "set",
      "createObjectURL",
      "innerConeAngle",
      "distanceTo",
      "createNodeMesh",
      " is missing URI and bufferView",
      "resourcePath",
      "componentType",
      "ymag",
      "undefined",
      "KHR_LIGHTS_PUNCTUAL",
      "8992400HYEbut",
      "TRIANGLES",
      "directional",
      "data:image/",
      " buffer type is not supported.",
      "normalTexture",
      "8091KnDVEL",
      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.",
      "light",
      "ROTATION",
      "scale",
      "normalScale",
      "offset",
      "matrix",
      "attributes",
      "sheenColor",
      "nodes",
      "clearcoatRoughness",
      "has",
      "THREE.GLTFLoader: Ignoring primitive type .extras, ",
      "extractUrlBase",
      "setRGB",
      "doubleSided",
      "warn",
      "clearcoat",
      "meshes",
      "afterRoot",
      "TRIANGLE_STRIP",
      "4209804qHpYMs",
      "POINTS",
      "cache",
      "manager",
      "angle",
      "setY",
      "webkitURL",
      "all",
      "clearcoatRoughnessTexture",
      "vertex-colors:",
      "setZ",
      "parameters",
      "type",
      "skinIndex",
      "emissiveTexture",
      "extendParams",
      "get",
      "copy",
      "array",
      "byteStride",
      "metalnessMap",
      "_loadLight",
      "setWithCredentials",
      "KHR_MESH_QUANTIZATION",
      "node",
      "EXT_MESH_GPU_INSTANCING",
      "clear",
      "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
      "sheenRoughnessFactor",
      'THREE.GLTFLoader: Unknown extension "',
      "clearcoatTexture",
      "channels",
      "specularColorTexture",
      "image/webp",
      "mode",
      "getHandler",
      "THREE.GLTFLoader: Missing min/max properties for accessor POSITION.",
      "supported",
      "traverse",
      "onerror",
      "specularColorMap",
      "transparent",
      "parser",
      "clearcoatNormalScale",
      "THREE.GLTFLoader: Unsupported glTF-Binary header.",
      "thickness",
      "interpolate_",
      "sampleValues",
      "(((.+)+)+)+$",
      "iridescenceThicknessMaximum",
      "animation",
      "KHR_DRACO_MESH_COMPRESSION",
      "object",
      "getValueSize",
      "repeat",
      "intensity",
      "expandByVector",
      "Unknown type: ",
      "interpolation",
      "isMesh",
      "clearcoatNormalMap",
      "KHR_MATERIALS_EMISSIVE_STRENGTH",
      "meshoptDecoder",
      "primitives",
      "tangent",
      "_createCubicSplineTrackInterpolant",
      "transmissionMap",
      "translation",
      "unregister",
      "KHR_materials_sheen",
      "clearcoatRoughnessMap",
      "POSITION",
      "alphaMode",
      "length",
      "NORMAL",
      "createUniqueName",
      "iridescenceIOR",
      "extras",
      "SCALAR",
      "decodeGltfBufferAsync",
      "withCredentials",
      "setResponseType",
      "boundingSphere",
      "decode",
      "Firefox",
      "mesh",
      "loadAnimation",
      "gltfExtensions",
      "primitiveCache",
      "assignFinalMaterial",
      "getDependencies",
      "buffer",
      "loadBufferView",
      "loadImageSource",
      "CUBICSPLINE",
      "ior",
      "BYTES_PER_ELEMENT",
      "specularColor",
      "InterleavedBuffer:",
      "286623EcBpnM",
      "userAgent",
      "239624GRmvpf",
      "KHR_draco_mesh_compression",
      "skins",
      "sheenColorTexture",
      "iridescence",
      "texCoord",
      "iridescenceThicknessMinimum",
      "iridescenceIor",
      "parse",
      "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures",
      "thicknessMap",
      "constructor",
      "ready",
      "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.",
      "sheenColorFactor",
      "baseColorFactor",
      "KHR_MATERIALS_VOLUME",
      "error",
      "clearcoatRoughnessFactor",
      "fromArray",
      "KHR_MATERIALS_TRANSMISSION",
      "normal",
      "TRIANGLE_FAN",
      "side",
      "orthographic",
      "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
      "THREE.GLTFLoader: Image ",
      "itemEnd",
      "KHR_materials_ior",
      "LINES",
      "skin",
      "perspective",
      "light_",
      "mimeType",
      "ktx2Loader",
      "options",
      "loadAccessor",
      "parseAsync",
      "aspectRatio",
      "MASK",
      "KHR_MATERIALS_ANISOTROPY",
    ];
    return (qp = function () {
      return t;
    })();
  }
  function Yp(t) {
    const e = np;
    let n;
    const i = t[e(582)] && t[e(582)][lp[e(801)]];
    if (
      ((n = i
        ? e(645) + i[e(421)] + ":" + i[e(536)] + ":" + Kp(i[e(736)])
        : t[e(536)] + ":" + Kp(t.attributes) + ":" + t[e(784)]),
      void 0 !== t[e(503)])
    )
      for (let r = 0, s = t[e(503)][e(823)]; r < s; r++)
        n += ":" + Kp(t[e(503)][r]);
    return n;
  }
  function Kp(t) {
    const e = np;
    let n = "";
    const i = Object[e(684)](t)[e(571)]();
    for (let r = 0, s = i[e(823)]; r < s; r++) n += i[r] + ":" + t[i[r]] + ";";
    return n;
  }
  function Zp(t) {
    const e = np;
    switch (t) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error(e(662));
    }
  }
  const Jp = new hi();
  class $p {
    constructor(t = {}, e = {}) {
      const n = np;
      (this[n(653)] = t),
        (this[n(582)] = {}),
        (this[n(516)] = {}),
        (this[n(413)] = e),
        (this.cache = new op()),
        (this[n(451)] = new Map()),
        (this[n(838)] = {}),
        (this[n(591)] = {}),
        (this[n(605)] = { refs: {}, uses: {} }),
        (this[n(602)] = { refs: {}, uses: {} }),
        (this[n(705)] = { refs: {}, uses: {} }),
        (this.sourceCache = {}),
        (this.textureCache = {}),
        (this[n(593)] = {});
      let i = !1,
        r = !1,
        s = -1;
      typeof navigator !== n(720) &&
        ((i =
          !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)),
        (r = navigator.userAgent.indexOf(n(834)) > -1),
        (s = r ? navigator[n(850)][n(629)](/Firefox\/([0-9]+)\./)[1] : -1)),
        typeof createImageBitmap === n(720) || i || (r && s < 98)
          ? (this.textureLoader = new uu(this[n(413)].manager))
          : (this[n(617)] = new Bu(this[n(413)][n(753)])),
        this[n(617)][n(450)](this[n(413)][n(559)]),
        this[n(617)][n(575)](this[n(413)][n(550)]),
        (this[n(453)] = new cu(this.options.manager)),
        this[n(453)][n(831)](n(534)),
        this[n(413)][n(559)] === n(649) && this[n(453)][n(772)](!0);
    }
    [np(482)](t) {
      this[np(582)] = t;
    }
    setPlugins(t) {
      this[np(516)] = t;
    }
    parse(t, e) {
      const n = np,
        i = this,
        r = this[n(653)],
        s = this[n(582)];
      this[n(752)][n(618)](),
        (this[n(591)] = {}),
        this._invokeAll(function (t) {
          const e = n;
          return t[e(665)] && t[e(665)]();
        }),
        Promise.all(
          this[n(690)](function (t) {
            const e = n;
            return t[e(547)] && t[e(547)]();
          }),
        )
          [n(452)](function () {
            const t = n;
            return Promise[t(757)]([
              i[t(840)](t(457)),
              i.getDependencies(t(800)),
              i[t(840)](t(557)),
            ]);
          })
          [n(452)](function (e) {
            const a = n,
              o = {
                scene: e[0][r[a(457)] || 0],
                scenes: e[0],
                animations: e[1],
                cameras: e[2],
                asset: r.asset,
                parser: i,
                userData: {},
              };
            Wp(s, o, r),
              jp(o, r),
              Promise.all(
                i[a(690)](function (t) {
                  const e = a;
                  return t.afterRoot && t[e(748)](o);
                }),
              ).then(function () {
                t(o);
              });
          })
          .catch(e);
    }
    _markDefs() {
      const t = np,
        e = this[t(653)][t(738)] || [],
        n = this.json[t(853)] || [],
        i = this.json[t(747)] || [];
      for (let r = 0, s = n.length; r < s; r++) {
        const i = n[r][t(543)];
        for (let n = 0, r = i[t(823)]; n < r; n++) e[i[n]].isBone = !0;
      }
      for (let r = 0, s = e[t(823)]; r < s; r++) {
        const n = e[r];
        void 0 !== n[t(835)] &&
          (this[t(527)](this[t(605)], n[t(835)]),
          void 0 !== n[t(408)] && (i[n.mesh].isSkinnedMesh = !0)),
          void 0 !== n.camera && this[t(527)](this[t(602)], n[t(557)]);
      }
    }
    [np(527)](t, e) {
      const n = np;
      void 0 !== e &&
        (void 0 === t[n(654)][e] && (t.refs[e] = t[n(446)][e] = 0),
        t.refs[e]++);
    }
    [np(611)](t, e, n) {
      const i = np;
      if (t[i(654)][e] <= 1) return n;
      const r = n[i(616)](),
        s = (t, e) => {
          const n = i,
            r = this.associations[n(766)](t);
          null != r && this[n(451)][n(711)](e, r);
          for (const [i, a] of t.children[n(676)]()) s(a, e[n(461)][i]);
        };
      return s(n, r), (r[i(561)] += i(496) + t[i(446)][e]++), r;
    }
    [np(481)](t) {
      const e = np,
        n = Object[e(431)](this.plugins);
      n[e(647)](this);
      for (let i = 0; i < n[e(823)]; i++) {
        const e = t(n[i]);
        if (e) return e;
      }
      return null;
    }
    [np(690)](t) {
      const e = np,
        n = Object[e(431)](this[e(516)]);
      n[e(470)](this);
      const i = [];
      for (let r = 0; r < n[e(823)]; r++) {
        const s = t(n[r]);
        s && i[e(647)](s);
      }
      return i;
    }
    getDependency(t, e) {
      const n = np,
        i = t + ":" + e;
      let r = this[n(752)][n(766)](i);
      if (!r) {
        switch (t) {
          case n(457):
            r = this[n(695)](e);
            break;
          case "node":
            r = this[n(481)](function (t) {
              const i = n;
              return t[i(426)] && t[i(426)](e);
            });
            break;
          case n(835):
            r = this[n(481)](function (t) {
              const i = n;
              return t.loadMesh && t[i(538)](e);
            });
            break;
          case "accessor":
            r = this[n(414)](e);
            break;
          case n(421):
            r = this[n(481)](function (t) {
              const i = n;
              return t[i(842)] && t[i(842)](e);
            });
            break;
          case n(841):
            r = this[n(535)](e);
            break;
          case n(573):
            r = this._invokeOne(function (t) {
              const i = n;
              return t[i(664)] && t[i(664)](e);
            });
            break;
          case "texture":
            r = this[n(481)](function (t) {
              const i = n;
              return t[i(475)] && t[i(475)](e);
            });
            break;
          case n(408):
            r = this[n(667)](e);
            break;
          case n(800):
            r = this[n(481)](function (t) {
              const i = n;
              return t[i(836)] && t[i(836)](e);
            });
            break;
          case n(557):
            r = this[n(462)](e);
            break;
          default:
            if (
              ((r = this[n(481)](function (i) {
                const r = n;
                return i != this && i[r(460)] && i[r(460)](t, e);
              })),
              !r)
            )
              throw new Error(n(807) + t);
        }
        this[n(752)][n(427)](i, r);
      }
      return r;
    }
    [np(840)](t) {
      const e = np;
      let n = this.cache[e(766)](t);
      if (!n) {
        const i = this,
          r = this.json[t + ("mesh" === t ? "es" : "s")] || [];
        (n = Promise[e(757)](
          r[e(572)](function (n, r) {
            return i[e(460)](t, r);
          }),
        )),
          this[e(752)].add(t, n);
      }
      return n;
    }
    [np(535)](t) {
      const e = np,
        n = this[e(653)][e(607)][t],
        i = this[e(453)];
      if (n[e(762)] && n[e(762)] !== e(534))
        throw new Error(e(554) + n[e(762)] + e(726));
      if (void 0 === n[e(625)] && 0 === t)
        return Promise[e(468)](this[e(582)][lp[e(623)]][e(630)]);
      const r = this[e(413)];
      return new Promise(function (t, s) {
        const a = e;
        i[a(438)](Pu[a(500)](n[a(625)], r.path), t, void 0, function () {
          const t = a;
          s(new Error(t(445) + n[t(625)] + '".'));
        });
      });
    }
    [np(842)](t) {
      const e = np,
        n = this.json.bufferViews[t];
      return this[e(460)](e(841), n[e(841)]).then(function (t) {
        const i = e,
          r = n.byteLength || 0,
          s = n[i(661)] || 0;
        return t.slice(s, s + r);
      });
    }
    loadAccessor(t) {
      const e = np,
        n = this,
        i = this.json,
        r = this.json[e(709)][t];
      if (void 0 === r[e(421)] && void 0 === r[e(595)]) {
        const t = Bp[r.type],
          n = Op[r[e(718)]],
          i = !0 === r.normalized,
          s = new n(r[e(428)] * t);
        return Promise[e(468)](new hr(s, t, i));
      }
      const s = [];
      return (
        void 0 !== r[e(421)]
          ? s[e(647)](this[e(460)](e(421), r[e(421)]))
          : s.push(null),
        void 0 !== r[e(595)] &&
          (s[e(647)](this[e(460)]("bufferView", r[e(595)][e(536)][e(421)])),
          s[e(647)](this.getDependency(e(421), r[e(595)][e(431)].bufferView))),
        Promise[e(757)](s)[e(452)](function (t) {
          const s = e,
            a = t[0],
            o = Bp[r[s(762)]],
            l = Op[r.componentType],
            c = l[s(846)],
            h = c * o,
            u = r.byteOffset || 0,
            d =
              void 0 !== r[s(421)] ? i.bufferViews[r[s(421)]][s(769)] : void 0,
            p = !0 === r[s(525)];
          let f, m;
          if (d && d !== h) {
            const t = Math[s(456)](u / d),
              e =
                s(848) +
                r[s(421)] +
                ":" +
                r.componentType +
                ":" +
                t +
                ":" +
                r.count;
            let i = n[s(752)][s(766)](e);
            !i &&
              ((f = new l(a, t * d, (r[s(428)] * d) / c)),
              (i = new Xo(f, d / c)),
              n[s(752)].add(e, i)),
              (m = new Yo(i, o, (u % d) / c, p));
          } else (f = null === a ? new l(r[s(428)] * o) : new l(a, u, r[s(428)] * o)), (m = new hr(f, o, p));
          if (void 0 !== r[s(595)]) {
            const e = Bp[s(828)],
              n = Op[r[s(595)][s(536)].componentType],
              i = r[s(595)][s(536)].byteOffset || 0,
              c = r[s(595)].values[s(661)] || 0,
              h = new n(t[1], i, r[s(595)][s(428)] * e),
              u = new l(t[2], c, r[s(595)][s(428)] * o);
            null !== a &&
              (m = new hr(m[s(768)][s(519)](), m[s(510)], m[s(525)]));
            for (let t = 0, r = h[s(823)]; t < r; t++) {
              const e = h[t];
              if (
                (m.setX(e, u[t * o]),
                o >= 2 && m[s(755)](e, u[t * o + 1]),
                o >= 3 && m[s(760)](e, u[t * o + 2]),
                o >= 4 && m.setW(e, u[t * o + 3]),
                o >= 5)
              )
                throw new Error(s(729));
            }
          }
          return m;
        })
      );
    }
    loadTexture(t) {
      const e = np,
        n = this[e(653)],
        i = this[e(413)],
        r = n[e(614)][t].source,
        s = n[e(436)][r];
      let a = this.textureLoader;
      if (s[e(625)]) {
        const t = i[e(753)][e(785)](s.uri);
        null !== t && (a = t);
      }
      return this.loadTextureImage(t, r, a);
    }
    [np(429)](t, e, n) {
      const i = np,
        r = this,
        s = this.json,
        a = s[i(614)][t],
        o = s[i(436)][e],
        l = (o[i(625)] || o[i(421)]) + ":" + a.sampler;
      if (this[i(659)][l]) return this[i(659)][l];
      const c = this[i(843)](e, n)
        [i(452)](function (e) {
          const n = i;
          (e[n(639)] = !1),
            (e[n(561)] = a.name || o[n(561)] || ""),
            "" === e[n(561)] &&
              typeof o[n(625)] === n(600) &&
              !1 === o[n(625)].startsWith(n(725)) &&
              (e[n(561)] = o[n(625)]);
          const l = (s[n(672)] || {})[a[n(437)]] || {};
          return (
            (e[n(701)] = Dp[l[n(701)]] || Lt),
            (e[n(606)] = Dp[l[n(606)]] || Pt),
            (e[n(502)] = Fp[l.wrapS] || Tt),
            (e[n(578)] = Fp[l[n(578)]] || Tt),
            r.associations[n(711)](e, { textures: t }),
            e
          );
        })
        [i(439)](function () {
          return null;
        });
      return (this.textureCache[l] = c), c;
    }
    [np(843)](t, e) {
      const n = np,
        i = this[n(653)],
        r = this[n(413)];
      if (void 0 !== this[n(583)][t])
        return this[n(583)][t][n(452)]((t) => t.clone());
      const s = i[n(436)][t],
        a = self.URL || self[n(756)];
      let o = s[n(625)] || "",
        l = !1;
      if (void 0 !== s[n(421)])
        o = this.getDependency(n(421), s[n(421)]).then(function (t) {
          const e = n;
          l = !0;
          const i = new Blob([t], { type: s[e(411)] });
          return (o = a[e(712)](i)), o;
        });
      else if (void 0 === s[n(625)]) throw new Error(n(877) + t + n(716));
      const c = Promise[n(468)](o)
        .then(function (t) {
          return new Promise(function (n, i) {
            const s = sp;
            let a = n;
            !0 === e[s(592)] &&
              (a = function (t) {
                const e = s,
                  i = new An(t);
                (i[e(526)] = !0), n(i);
              }),
              e[s(438)](Pu.resolveURL(t, r[s(497)]), a, void 0, i);
          });
        })
        [n(452)](function (t) {
          const e = n;
          return (
            !0 === l && a.revokeObjectURL(o),
            (t[e(478)].mimeType =
              s.mimeType ||
              (function (t) {
                const e = np;
                return t[e(707)](/\.jpe?g($|\?)/i) > 0 ||
                  0 === t[e(707)](/^data\:image\/jpeg/)
                  ? "image/jpeg"
                  : t[e(707)](/\.webp($|\?)/i) > 0 ||
                    0 === t[e(707)](/^data\:image\/webp/)
                  ? e(783)
                  : "image/png";
              })(s[e(625)])),
            t
          );
        })
        [n(439)](function (t) {
          const e = n;
          throw (console[e(868)](e(420), o), t);
        });
      return (this[n(583)][t] = c), c;
    }
    [np(700)](t, e, n, i) {
      const r = np,
        s = this;
      return this[r(460)]("texture", n[r(454)])[r(452)](function (a) {
        const o = r;
        if (!a) return null;
        if (
          (void 0 !== n[o(856)] &&
            n[o(856)] > 0 &&
            ((a = a[o(616)]()).channel = n[o(856)]),
          s[o(582)][lp[o(477)]])
        ) {
          const t = void 0 !== n[o(582)] ? n.extensions[lp[o(477)]] : void 0;
          if (t) {
            const e = s[o(451)].get(a);
            (a = s[o(582)][lp[o(477)]][o(443)](a, t)), s[o(451)][o(711)](a, e);
          }
        }
        return void 0 !== i && (a.colorSpace = i), (t[e] = a), a;
      });
    }
    [np(839)](t) {
      const e = np,
        n = t[e(679)];
      let i = t[e(573)];
      const r = void 0 === n[e(736)].tangent,
        s = void 0 !== n.attributes.color,
        a = void 0 === n[e(736)][e(872)];
      if (t[e(569)]) {
        const t = e(480) + i[e(504)];
        let n = this.cache[e(766)](t);
        !n &&
          ((n = new Kl()),
          Ki[e(703)].copy[e(628)](n, i),
          n[e(580)].copy(i[e(580)]),
          (n[e(572)] = i[e(572)]),
          (n[e(577)] = !1),
          this[e(752)][e(427)](t, n)),
          (i = n);
      } else if (t.isLine) {
        const t = e(483) + i[e(504)];
        let n = this[e(752)][e(766)](t);
        !n &&
          ((n = new Bl()),
          Ki[e(703)].copy[e(628)](n, i),
          n.color[e(767)](i.color),
          (n[e(572)] = i[e(572)]),
          this.cache[e(427)](t, n)),
          (i = n);
      }
      if (r || s || a) {
        let t = e(440) + i[e(504)] + ":";
        r && (t += "derivative-tangents:"),
          s && (t += e(759)),
          a && (t += e(685));
        let n = this[e(752)][e(766)](t);
        n ||
          ((n = i[e(616)]()),
          s && (n[e(677)] = !0),
          a && (n[e(640)] = !0),
          r &&
            (n[e(733)] && (n[e(733)].y *= -1),
            n.clearcoatNormalScale && (n[e(793)].y *= -1)),
          this[e(752)][e(427)](t, n),
          this[e(451)][e(711)](n, this[e(451)].get(i))),
          (i = n);
      }
      t.material = i;
    }
    getMaterialType() {
      return Rh;
    }
    loadMaterial(t) {
      const e = np,
        n = this,
        i = this[e(653)],
        r = this[e(582)],
        s = i[e(515)][t];
      let a;
      const o = {},
        l = [];
      if ((s[e(582)] || {})[lp[e(490)]]) {
        const t = r[lp[e(490)]];
        (a = t[e(541)]()), l[e(647)](t.extendParams(o, s, n));
      } else {
        const i = s[e(476)] || {};
        if (
          ((o.color = new tr(1, 1, 1)),
          (o[e(584)] = 1),
          Array[e(570)](i.baseColorFactor))
        ) {
          const t = i.baseColorFactor;
          o[e(580)][e(743)](t[0], t[1], t[2], Oe), (o[e(584)] = t[3]);
        }
        void 0 !== i.baseColorTexture &&
          l[e(647)](n[e(700)](o, "map", i[e(643)], Ne)),
          (o[e(495)] = void 0 !== i[e(533)] ? i.metallicFactor : 1),
          (o.roughness = void 0 !== i[e(637)] ? i[e(637)] : 1),
          void 0 !== i[e(518)] &&
            (l[e(647)](n[e(700)](o, e(770), i.metallicRoughnessTexture)),
            l[e(647)](n.assignTexture(o, e(463), i.metallicRoughnessTexture))),
          (a = this._invokeOne(function (n) {
            const i = e;
            return n[i(541)] && n[i(541)](t);
          })),
          l[e(647)](
            Promise.all(
              this[e(690)](function (n) {
                const i = e;
                return n[i(486)] && n[i(486)](t, o);
              }),
            ),
          );
      }
      !0 === s[e(744)] && (o[e(874)] = 2);
      const c = s[e(822)] || Gp[e(434)];
      if (
        (c === Gp[e(556)]
          ? ((o[e(791)] = !0), (o[e(588)] = !1))
          : ((o[e(791)] = !1),
            c === Gp.MASK &&
              (o.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
        void 0 !== s.normalTexture &&
          a !== nr &&
          (l[e(647)](n.assignTexture(o, e(432), s.normalTexture)),
          (o.normalScale = new sn(1, 1)),
          void 0 !== s[e(727)][e(732)]))
      ) {
        const t = s.normalTexture[e(732)];
        o.normalScale.set(t, t);
      }
      return (
        void 0 !== s[e(675)] &&
          a !== nr &&
          (l.push(n[e(700)](o, "aoMap", s[e(675)])),
          void 0 !== s[e(675)][e(540)] &&
            (o.aoMapIntensity = s.occlusionTexture[e(540)])),
        void 0 !== s.emissiveFactor &&
          a !== nr &&
          (o[e(666)] = new tr().setRGB(...s[e(548)], Oe)),
        void 0 !== s[e(764)] &&
          a !== nr &&
          l[e(647)](n.assignTexture(o, e(555), s[e(764)], Ne)),
        Promise[e(757)](l)[e(452)](function () {
          const i = e,
            l = new a(o);
          return (
            s[i(561)] && (l.name = s[i(561)]),
            jp(l, s),
            n.associations[i(711)](l, { materials: t }),
            s[i(582)] && Wp(r, l, s),
            l
          );
        })
      );
    }
    [np(825)](t) {
      const e = np,
        n = ld[e(621)](t || "");
      return n in this[e(593)]
        ? n + "_" + ++this[e(593)][n]
        : ((this.nodeNamesUsed[n] = 0), n);
    }
    [np(641)](t) {
      const e = np,
        n = this,
        i = this[e(582)],
        r = this[e(838)];
      function s(t) {
        const r = e;
        return i[lp[r(801)]][r(560)](t, n)[r(452)](function (e) {
          return Qp(e, t, n);
        });
      }
      const a = [];
      for (let o = 0, l = t[e(823)]; o < l; o++) {
        const i = t[o],
          l = Yp(i),
          c = r[l];
        if (c) a[e(647)](c[e(671)]);
        else {
          let t;
          (t =
            i.extensions && i.extensions[lp[e(801)]]
              ? s(i)
              : Qp(new Mr(), i, n)),
            (r[l] = { primitive: i, promise: t }),
            a[e(647)](t);
        }
      }
      return Promise.all(a);
    }
    [np(538)](t) {
      const e = np,
        n = this,
        i = this[e(653)],
        r = this[e(582)],
        s = i.meshes[t],
        a = s[e(813)],
        o = [];
      for (let l = 0, c = a[e(823)]; l < c; l++) {
        const t =
          void 0 === a[l][e(573)]
            ? Vp(this[e(752)])
            : this[e(460)]("material", a[l][e(573)]);
        o[e(647)](t);
      }
      return (
        o.push(n[e(641)](a)),
        Promise.all(o)[e(452)](function (i) {
          const o = e,
            l = i[o(519)](0, i[o(823)] - 1),
            c = i[i.length - 1],
            h = [];
          for (let e = 0, d = c[o(823)]; e < d; e++) {
            const i = c[e],
              u = a[e];
            let d;
            const p = l[e];
            if (
              u[o(784)] === Np.TRIANGLES ||
              u[o(784)] === Np[o(749)] ||
              u[o(784)] === Np[o(873)] ||
              void 0 === u.mode
            )
              (d = !0 === s[o(511)] ? new bl(i, p) : new zr(i, p)),
                !0 === d[o(511)] && d[o(488)](),
                u[o(784)] === Np[o(749)]
                  ? (d[o(679)] = Qd(d[o(679)], 1))
                  : u[o(784)] === Np[o(873)] && (d[o(679)] = Qd(d[o(679)], 2));
            else if (u[o(784)] === Np[o(407)]) d = new ql(i, p);
            else if (u[o(784)] === Np[o(530)]) d = new Wl(i, p);
            else if (u.mode === Np.LINE_LOOP) d = new Yl(i, p);
            else {
              if (u[o(784)] !== Np[o(751)]) throw new Error(o(678) + u[o(784)]);
              d = new tc(i, p);
            }
            Object.keys(d[o(679)].morphAttributes)[o(823)] > 0 && Xp(d, s),
              (d[o(561)] = n[o(825)](s[o(561)] || o(692) + t)),
              jp(d, s),
              u[o(582)] && Wp(r, d, u),
              n[o(839)](d),
              h[o(647)](d);
          }
          for (let e = 0, r = h.length; e < r; e++)
            n[o(451)][o(711)](h[e], { meshes: t, primitives: e });
          if (1 === h[o(823)]) return s[o(582)] && Wp(r, h[0], s), h[0];
          const u = new Uo();
          s[o(582)] && Wp(r, u, s), n.associations.set(u, { meshes: t });
          for (let t = 0, e = h[o(823)]; t < e; t++) u[o(427)](h[t]);
          return u;
        })
      );
    }
    loadCamera(t) {
      const e = np;
      let n;
      const i = this.json[e(544)][t],
        r = i[i.type];
      if (r)
        return (
          i[e(762)] === e(409)
            ? (n = new Yr(
                rn[e(644)](r[e(604)]),
                r[e(416)] || 1,
                r[e(669)] || 1,
                r[e(546)] || 2e6,
              ))
            : i.type === e(875) &&
              (n = new ys(
                -r[e(531)],
                r[e(531)],
                r[e(719)],
                -r[e(719)],
                r.znear,
                r[e(546)],
              )),
          i[e(561)] && (n.name = this[e(825)](i[e(561)])),
          jp(n, i),
          Promise[e(468)](n)
        );
      console.warn(e(506));
    }
    loadSkin(t) {
      const e = np,
        n = this[e(653)][e(853)][t],
        i = [];
      for (let r = 0, s = n[e(543)][e(823)]; r < s; r++)
        i[e(647)](this._loadNodeShallow(n[e(543)][r]));
      return (
        void 0 !== n.inverseBindMatrices
          ? i.push(this[e(460)](e(697), n.inverseBindMatrices))
          : i.push(null),
        Promise.all(i)[e(452)](function (t) {
          const i = e,
            r = t[i(648)](),
            s = t,
            a = [],
            o = [];
          for (let e = 0, l = s[i(823)]; e < l; e++) {
            const t = s[e];
            if (t) {
              a[i(647)](t);
              const n = new hi();
              null !== r && n.fromArray(r[i(768)], 16 * e), o[i(647)](n);
            } else console[i(745)](i(522), n[i(543)][e]);
          }
          return new Rl(a, o);
        })
      );
    }
    [np(836)](t) {
      const e = np,
        n = this[e(653)],
        i = this,
        r = n.animations[t],
        s = r.name ? r[e(561)] : "animation_" + t,
        a = [],
        o = [],
        l = [],
        c = [],
        h = [];
      for (let u = 0, d = r[e(781)][e(823)]; u < d; u++) {
        const t = r[e(781)][u],
          n = r.samplers[t[e(437)]],
          i = t[e(693)],
          s = i[e(774)],
          d = void 0 !== r[e(761)] ? r[e(761)][n.input] : n[e(563)],
          p = void 0 !== r[e(761)] ? r[e(761)][n[e(512)]] : n.output;
        void 0 !== i[e(774)] &&
          (a[e(647)](this[e(460)](e(774), s)),
          o[e(647)](this[e(460)](e(697), d)),
          l[e(647)](this[e(460)]("accessor", p)),
          c[e(647)](n),
          h[e(647)](i));
      }
      return Promise[e(757)]([
        Promise[e(757)](a),
        Promise.all(o),
        Promise.all(l),
        Promise.all(c),
        Promise[e(757)](h),
      ])[e(452)](function (t) {
        const n = e,
          r = t[0],
          a = t[1],
          o = t[2],
          l = t[3],
          c = t[4],
          h = [];
        for (let e = 0, s = r[n(823)]; e < s; e++) {
          const t = r[e],
            s = a[e],
            u = o[e],
            d = l[e],
            p = c[e];
          if (void 0 === t) continue;
          t.updateMatrix && t[n(464)]();
          const f = i._createAnimationTracks(t, s, u, d, p);
          if (f) for (let e = 0; e < f[n(823)]; e++) h[n(647)](f[e]);
        }
        return new eu(s, void 0, h);
      });
    }
    [np(715)](t) {
      const e = np,
        n = this[e(653)],
        i = this,
        r = n[e(738)][t];
      return void 0 === r[e(835)]
        ? null
        : i[e(460)](e(835), r.mesh)[e(452)](function (t) {
            const n = e,
              s = i._getNodeRef(i[n(605)], r[n(835)], t);
            return (
              void 0 !== r[n(702)] &&
                s[n(788)](function (t) {
                  const e = n;
                  if (t[e(809)])
                    for (let n = 0, i = r[e(702)][e(823)]; n < i; n++)
                      t.morphTargetInfluences[n] = r.weights[n];
                }),
              s
            );
          });
    }
    [np(426)](t) {
      const e = np,
        n = this,
        i = this.json.nodes[t],
        r = n[e(601)](t),
        s = [],
        a = i.children || [];
      for (let l = 0, c = a[e(823)]; l < c; l++)
        s.push(n.getDependency(e(774), a[l]));
      const o =
        void 0 === i[e(408)]
          ? Promise[e(468)](null)
          : n[e(460)](e(408), i.skin);
      return Promise.all([r, Promise[e(757)](s), o]).then(function (t) {
        const n = e,
          i = t[0],
          r = t[1],
          s = t[2];
        null !== s &&
          i[n(788)](function (t) {
            t[n(511)] && t.bind(s, Jp);
          });
        for (let e = 0, a = r[n(823)]; e < a; e++) i[n(427)](r[e]);
        return i;
      });
    }
    _loadNodeShallow(t) {
      const e = np,
        n = this[e(653)],
        i = this.extensions,
        r = this;
      if (void 0 !== this.nodeCache[t]) return this[e(591)][t];
      const s = n.nodes[t],
        a = s.name ? r[e(825)](s[e(561)]) : "",
        o = [],
        l = r._invokeOne(function (n) {
          const i = e;
          return n.createNodeMesh && n[i(715)](t);
        });
      return (
        l && o[e(647)](l),
        void 0 !== s[e(557)] &&
          o[e(647)](
            r[e(460)]("camera", s[e(557)])[e(452)](function (t) {
              const n = e;
              return r[n(611)](r[n(602)], s.camera, t);
            }),
          ),
        r
          ._invokeAll(function (n) {
            const i = e;
            return n[i(514)] && n[i(514)](t);
          })
          [e(524)](function (t) {
            o.push(t);
          }),
        (this[e(591)][t] = Promise[e(757)](o)[e(452)](function (n) {
          const o = e;
          let l;
          if (
            ((l =
              !0 === s[o(599)]
                ? new Tl()
                : n.length > 1
                ? new Uo()
                : 1 === n[o(823)]
                ? n[0]
                : new Oi()),
            l !== n[0])
          )
            for (let t = 0, e = n.length; t < e; t++) l[o(427)](n[t]);
          if (
            (s[o(561)] && ((l[o(478)].name = s[o(561)]), (l[o(561)] = a)),
            jp(l, s),
            s.extensions && Wp(i, l, s),
            void 0 !== s.matrix)
          ) {
            const t = new hi();
            t[o(870)](s[o(735)]), l[o(499)](t);
          } else void 0 !== s[o(817)] && l[o(566)][o(870)](s[o(817)]), void 0 !== s.rotation && l[o(523)][o(870)](s.rotation), void 0 !== s[o(732)] && l[o(732)][o(870)](s.scale);
          return (
            !r[o(451)][o(740)](l) && r.associations[o(711)](l, {}),
            (r[o(451)][o(766)](l)[o(738)] = t),
            l
          );
        })),
        this[e(591)][t]
      );
    }
    [np(695)](t) {
      const e = np,
        n = this.extensions,
        i = this[e(653)][e(708)][t],
        r = this,
        s = new Uo();
      i[e(561)] && (s[e(561)] = r[e(825)](i[e(561)])),
        jp(s, i),
        i[e(582)] && Wp(n, s, i);
      const a = i.nodes || [],
        o = [];
      for (let l = 0, c = a[e(823)]; l < c; l++)
        o[e(647)](r.getDependency(e(774), a[l]));
      return Promise[e(757)](o)[e(452)](function (t) {
        const n = e;
        for (let e = 0, i = t[n(823)]; e < i; e++) s[n(427)](t[e]);
        return (
          (r[n(451)] = ((t) => {
            const e = n,
              i = new Map();
            for (const [n, s] of r[e(451)])
              (n instanceof Ki || n instanceof An) && i[e(711)](n, s);
            return (
              t[e(788)]((t) => {
                const n = e,
                  s = r[n(451)].get(t);
                null != s && i[n(711)](t, s);
              }),
              i
            );
          })(s)),
          s
        );
      });
    }
    [np(613)](t, e, n, i, r) {
      const s = np,
        a = [],
        o = t[s(561)] ? t[s(561)] : t[s(504)],
        l = [];
      let c;
      switch (
        (kp[r[s(497)]] === kp[s(702)]
          ? t[s(788)](function (t) {
              const e = s;
              t[e(681)] && l[e(647)](t[e(561)] ? t[e(561)] : t[e(504)]);
            })
          : l.push(o),
        kp[r[s(497)]])
      ) {
        case kp[s(702)]:
          c = Zh;
          break;
        case kp[s(467)]:
          c = $h;
          break;
        case kp[s(566)]:
        case kp[s(732)]:
          c = tu;
          break;
        default:
          if (1 === n.itemSize) c = Zh;
          else c = tu;
      }
      const h = void 0 !== i[s(808)] ? Hp[i[s(808)]] : Te,
        u = this._getArrayFromAccessor(n);
      for (let d = 0, p = l[s(823)]; d < p; d++) {
        const t = new c(l[d] + "." + kp[r[s(497)]], e[s(768)], u, h);
        i.interpolation === s(844) && this[s(815)](t), a[s(647)](t);
      }
      return a;
    }
    [np(619)](t) {
      const e = np;
      let n = t[e(768)];
      if (t.normalized) {
        const t = Zp(n[e(862)]),
          i = new Float32Array(n[e(823)]);
        for (let r = 0, s = n[e(823)]; r < s; r++) i[r] = n[r] * t;
        n = i;
      }
      return n;
    }
    [np(815)](t) {
      const e = np;
      (t[e(529)] = function (t) {
        const n = e;
        return new (this instanceof $h ? Up : Ip)(
          this.times,
          this[n(431)],
          this[n(803)]() / 3,
          t,
        );
      }),
        (t[e(529)][e(471)] = !0);
    }
  }
  function Qp(t, e, n) {
    const i = np,
      r = e[i(736)],
      s = [];
    function a(e, r) {
      const s = i;
      return n[s(460)](s(697), e).then(function (e) {
        t[s(568)](r, e);
      });
    }
    for (const o in r) {
      const e = zp[o] || o[i(513)]();
      e in t[i(736)] || s[i(647)](a(r[o], e));
    }
    if (void 0 !== e[i(536)] && !t[i(454)]) {
      const r = n[i(460)](i(697), e[i(536)])[i(452)](function (e) {
        t.setIndex(e);
      });
      s[i(647)](r);
    }
    return (
      xn[i(565)] !== Oe &&
        i(608) in r &&
        console.warn(
          'THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "' +
            xn.workingColorSpace +
            i(696),
        ),
      jp(t, e),
      (function (t, e, n) {
        const i = np,
          r = e[i(736)],
          s = new Fn();
        if (void 0 === r[i(821)]) return;
        {
          const t = n.json[i(709)][r[i(821)]],
            e = t[i(699)],
            a = t[i(626)];
          if (void 0 === e || void 0 === a) return void console[i(745)](i(786));
          if (
            (s.set(new Nn(e[0], e[1], e[2]), new Nn(a[0], a[1], a[2])),
            t.normalized)
          ) {
            const e = Zp(Op[t.componentType]);
            s[i(699)][i(682)](e), s[i(626)][i(682)](e);
          }
        }
        const a = e[i(503)];
        if (void 0 !== a) {
          const t = new Nn(),
            e = new Nn();
          for (let r = 0, s = a[i(823)]; r < s; r++) {
            const s = a[r];
            if (void 0 !== s[i(821)]) {
              const r = n[i(653)][i(709)][s[i(821)]],
                a = r[i(699)],
                o = r[i(626)];
              if (void 0 !== a && void 0 !== o) {
                if (
                  (e[i(635)](
                    Math[i(626)](Math[i(620)](a[0]), Math[i(620)](o[0])),
                  ),
                  e.setY(Math[i(626)](Math[i(620)](a[1]), Math[i(620)](o[1]))),
                  e[i(760)](Math.max(Math[i(620)](a[2]), Math.abs(o[2]))),
                  r[i(525)])
                ) {
                  const t = Zp(Op[r[i(718)]]);
                  e[i(682)](t);
                }
                t[i(626)](e);
              } else console[i(745)](i(786));
            }
          }
          s[i(806)](t);
        }
        t.boundingBox = s;
        const o = new ei();
        s.getCenter(o[i(694)]),
          (o[i(469)] = s[i(699)][i(714)](s[i(626)]) / 2),
          (t[i(832)] = o);
      })(t, e, n),
      Promise.all(s)[i(452)](function () {
        const r = i;
        return void 0 !== e[r(503)]
          ? (function (t, e, n) {
              const i = np;
              let r = !1,
                s = !1,
                a = !1;
              for (let h = 0, u = e[i(823)]; h < u; h++) {
                const t = e[h];
                if (
                  (void 0 !== t.POSITION && (r = !0),
                  void 0 !== t.NORMAL && (s = !0),
                  void 0 !== t[i(608)] && (a = !0),
                  r && s && a)
                )
                  break;
              }
              if (!r && !s && !a) return Promise[i(468)](t);
              const o = [],
                l = [],
                c = [];
              for (let h = 0, u = e[i(823)]; h < u; h++) {
                const u = e[h];
                if (r) {
                  const e =
                    void 0 !== u[i(821)]
                      ? n[i(460)](i(697), u.POSITION)
                      : t[i(736)][i(566)];
                  o.push(e);
                }
                if (s) {
                  const e =
                    void 0 !== u[i(824)]
                      ? n[i(460)]("accessor", u[i(824)])
                      : t[i(736)][i(872)];
                  l.push(e);
                }
                if (a) {
                  const e =
                    void 0 !== u[i(608)]
                      ? n.getDependency(i(697), u[i(608)])
                      : t.attributes[i(580)];
                  c[i(647)](e);
                }
              }
              return Promise[i(757)]([
                Promise[i(757)](o),
                Promise.all(l),
                Promise[i(757)](c),
              ]).then(function (e) {
                const n = i,
                  o = e[0],
                  l = e[1],
                  c = e[2];
                return (
                  r && (t[n(632)][n(566)] = o),
                  s && (t[n(632)].normal = l),
                  a && (t[n(632)][n(580)] = c),
                  (t.morphTargetsRelative = !0),
                  t
                );
              });
            })(t, e[r(503)], n)
          : t;
      })
    );
  }
  !(function (t, e) {
    const n = of,
      i = t();
    for (;;)
      try {
        if (
          389769 ===
          parseInt(n(473)) / 1 +
            parseInt(n(478)) / 2 +
            (parseInt(n(467)) / 3) * (-parseInt(n(486)) / 4) +
            (-parseInt(n(470)) / 5) * (parseInt(n(457)) / 6) +
            (parseInt(n(469)) / 7) * (-parseInt(n(463)) / 8) +
            (parseInt(n(481)) / 9) * (-parseInt(n(479)) / 10) +
            (-parseInt(n(466)) / 11) * (-parseInt(n(484)) / 12)
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(lf);
  const tf = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    ef = tf(globalThis, function () {
      const t = of;
      return ef[t(485)]()[t(462)](t(488))[t(485)]()[t(464)](ef).search(t(488));
    });
  let nf, rf, sf, af;
  function of(t, e) {
    const n = lf();
    return (of = function (t, e) {
      return n[(t -= 457)];
    })(t, e);
  }
  function lf() {
    const t = [
      "\n            varying vec2 vUv;\n            void main(){\n                vUv = uv;\n                gl_Position = vec4(position.xy * 1.0,0.,.999999);\n            }",
      "needsUpdate",
      "1247132OLCtdb",
      "10WuJwYB",
      "image",
      "6246918aSIrDn",
      "uniforms",
      "defines",
      "72IGjFkf",
      "toString",
      "92yganqF",
      "\n            uniform sampler2D blitTexture; \n            varying vec2 vUv;\n\n            void main(){ \n                gl_FragColor = vec4(vUv.xy, 0, 1);\n                \n                #ifdef IS_SRGB\n                gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n                #else\n                gl_FragColor = texture2D( blitTexture, vUv);\n                #endif\n            }",
      "(((.+)+)+)+$",
      "setSize",
      "30WDqjHU",
      "name",
      "wrapS",
      "minFilter",
      "magFilter",
      "search",
      "4737136pJjcEI",
      "constructor",
      "clear",
      "2740870KVdPvB",
      "99417fsGydV",
      "wrapT",
      "7aqEpzc",
      "231030BRTVwG",
      "domElement",
      "dispose",
      "550654nQTAXv",
      "add",
      "min",
    ];
    return (lf = function () {
      return t;
    })();
  }
  function cf(t, e = 1 / 0, n = null) {
    const i = of;
    rf || (rf = new ls(2, 2, 1, 1)),
      sf ||
        (sf = new Xr({
          uniforms: { blitTexture: new dd(t) },
          vertexShader: i(476),
          fragmentShader: i(487),
        })),
      (sf[i(482)].blitTexture.value = t),
      (sf[i(483)].IS_SRGB = t.colorSpace == Ne),
      (sf[i(477)] = !0),
      !af && ((af = new zr(rf, sf)), (af.frustrumCulled = !1));
    const r = new Yr(),
      s = new jo();
    s[i(474)](af),
      !n && (n = nf = new Ho({ antialias: !1 })),
      n[i(489)](
        Math.min(t[i(480)].width, e),
        Math[i(475)](t[i(480)].height, e),
      ),
      n[i(465)](),
      n.render(s, r);
    const a = new An(n[i(471)]);
    return (
      (a[i(460)] = t[i(460)]),
      (a[i(461)] = t[i(461)]),
      (a[i(459)] = t.wrapS),
      (a[i(468)] = t[i(468)]),
      (a[i(458)] = t.name),
      nf && (nf[i(472)](), (nf = null)),
      a
    );
  }
  ef();
  const hf = Uf;
  !(function (t, e) {
    const n = Uf,
      i = t();
    for (;;)
      try {
        if (
          136057 ===
          parseInt(n(196)) / 1 +
            parseInt(n(187)) / 2 +
            (-parseInt(n(368)) / 3) * (parseInt(n(362)) / 4) +
            -parseInt(n(373)) / 5 +
            (parseInt(n(229)) / 6) * (-parseInt(n(380)) / 7) +
            (parseInt(n(281)) / 8) * (-parseInt(n(238)) / 9) +
            (parseInt(n(510)) / 10) * (parseInt(n(364)) / 11)
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(Ff);
  const uf = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n[Uf(301)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    df = uf(globalThis, function () {
      const t = Uf;
      return df
        .toString()
        [t(443)](t(245))
        [t(564)]()
        [t(297)](df)
        [t(443)](t(245));
    });
  df();
  const pf = {
    POSITION: [
      hf(496),
      "byte normalized",
      hf(181),
      hf(299),
      hf(492),
      "short normalized",
      hf(213),
      hf(417),
    ],
    NORMAL: [hf(366), hf(477)],
    TANGENT: ["byte normalized", hf(477)],
    TEXCOORD: [
      hf(496),
      hf(366),
      "unsigned byte",
      "short",
      "short normalized",
      "unsigned short",
    ],
  };
  class ff {
    constructor() {
      const t = hf;
      (this[t(280)] = []),
        this.register(function (t) {
          return new Ef(t);
        }),
        this.register(function (t) {
          return new Af(t);
        }),
        this[t(390)](function (t) {
          return new Lf(t);
        }),
        this[t(390)](function (t) {
          return new If(t);
        }),
        this[t(390)](function (t) {
          return new Pf(t);
        }),
        this[t(390)](function (t) {
          return new Nf(t);
        }),
        this[t(390)](function (t) {
          return new Rf(t);
        }),
        this[t(390)](function (t) {
          return new Cf(t);
        }),
        this[t(390)](function (t) {
          return new Of(t);
        }),
        this.register(function (t) {
          return new Df(t);
        }),
        this.register(function (t) {
          return new Bf(t);
        });
    }
    [hf(390)](t) {
      const e = hf;
      return -1 === this[e(280)].indexOf(t) && this[e(280)][e(534)](t), this;
    }
    [hf(464)](t) {
      const e = hf;
      return (
        -1 !== this[e(280)].indexOf(t) &&
          this[e(280)][e(398)](this[e(280)][e(275)](t), 1),
        this
      );
    }
    [hf(425)](t, e, n, i) {
      const r = hf,
        s = new wf(),
        a = [];
      for (let o = 0, l = this.pluginCallbacks.length; o < l; o++)
        a[r(534)](this.pluginCallbacks[o](s));
      s[r(302)](a), s[r(428)](t, e, i)[r(466)](n);
    }
    [hf(279)](t, e) {
      const n = this;
      return new Promise(function (i, r) {
        n[Uf(425)](t, i, r, e);
      });
    }
  }
  const mf = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      BYTE: 5120,
      UNSIGNED_BYTE: 5121,
      SHORT: 5122,
      UNSIGNED_SHORT: 5123,
      INT: 5124,
      UNSIGNED_INT: 5125,
      FLOAT: 5126,
      ARRAY_BUFFER: 34962,
      ELEMENT_ARRAY_BUFFER: 34963,
      NEAREST: 9728,
      LINEAR: 9729,
      NEAREST_MIPMAP_NEAREST: 9984,
      LINEAR_MIPMAP_NEAREST: 9985,
      NEAREST_MIPMAP_LINEAR: 9986,
      LINEAR_MIPMAP_LINEAR: 9987,
      CLAMP_TO_EDGE: 33071,
      MIRRORED_REPEAT: 33648,
      REPEAT: 10497,
    },
    gf = hf(306),
    vf = {};
  (vf[1003] = mf[hf(222)]),
    (vf[1004] = mf[hf(527)]),
    (vf[1005] = mf.NEAREST_MIPMAP_LINEAR),
    (vf[1006] = mf.LINEAR),
    (vf[1007] = mf.LINEAR_MIPMAP_NEAREST),
    (vf[1008] = mf.LINEAR_MIPMAP_LINEAR),
    (vf[1001] = mf[hf(422)]),
    (vf[1e3] = mf[hf(233)]),
    (vf[1002] = mf[hf(292)]);
  const _f = {
      scale: hf(526),
      position: "translation",
      quaternion: hf(474),
      morphTargetInfluences: "weights",
    },
    yf = new tr();
  function xf(t, e) {
    const n = hf;
    return (
      t[n(277)] === e[n(277)] &&
      t[n(246)](function (t, n) {
        return t === e[n];
      })
    );
  }
  function Mf(t) {
    return 4 * Math.ceil(t / 4);
  }
  function Sf(t, e = 0) {
    const n = hf,
      i = Mf(t[n(331)]);
    if (i !== t[n(331)]) {
      const r = new Uint8Array(i);
      if ((r[n(502)](new Uint8Array(t)), 0 !== e))
        for (let s = t[n(331)]; s < i; s++) r[s] = e;
      return r[n(369)];
    }
    return t;
  }
  function bf() {
    const t = hf;
    return typeof document === t(197) && typeof OffscreenCanvas !== t(197)
      ? new OffscreenCanvas(1, 1)
      : document[t(291)]("canvas");
  }
  function Tf(t, e) {
    const n = hf;
    if (void 0 !== t.toBlob) return new Promise((n) => t.toBlob(n, e));
    let i;
    return (
      e === n(310) ? (i = 0.92) : e === n(439) && (i = 0.8),
      t[n(333)]({ type: e, quality: i })
    );
  }
  class wf {
    constructor() {
      const t = hf;
      (this[t(178)] = []),
        (this[t(383)] = {}),
        (this[t(221)] = []),
        (this[t(489)] = []),
        (this[t(216)] = 0),
        (this[t(489)] = []),
        (this[t(271)] = new Map()),
        (this.skins = []),
        (this.extensionsUsed = {}),
        (this[t(254)] = {}),
        (this[t(171)] = new Map()),
        (this.uid = 0),
        (this[t(270)] = { asset: { version: t(256), generator: t(452) } }),
        (this[t(186)] = {
          meshes: new Map(),
          attributes: new Map(),
          attributesNormalized: new Map(),
          materials: new Map(),
          textures: new Map(),
          images: new Map(),
        });
    }
    setPlugins(t) {
      this[hf(178)] = t;
    }
    [hf(428)](t, e) {
      return c(this, arguments, function* (t, e, n = {}) {
        const i = hf;
        (this[i(383)] = Object[i(517)](
          {
            binary: !1,
            trs: !1,
            onlyVisible: !0,
            maxTextureSize: 1 / 0,
            animations: [],
            includeCustomExtensions: !1,
          },
          n,
        )),
          this[i(383)][i(188)][i(277)] > 0 && (this[i(383)].trs = !0),
          this.processInput(t),
          yield Promise[i(521)](this[i(221)]);
        const r = this,
          s = r[i(489)],
          a = r[i(270)];
        n = r.options;
        const o = r[i(261)],
          l = r[i(254)],
          c = new Blob(s, { type: i(413) }),
          h = Object[i(300)](o),
          u = Object.keys(l);
        if (
          (h[i(277)] > 0 && (a[i(261)] = h),
          u[i(277)] > 0 && (a[i(254)] = u),
          a.buffers &&
            a[i(489)][i(277)] > 0 &&
            (a[i(489)][0][i(331)] = c[i(406)]),
          !0 === n[i(180)])
        ) {
          const t = new FileReader();
          t[i(172)](c),
            (t[i(426)] = function () {
              const n = i,
                r = Sf(t[n(167)]),
                s = new DataView(new ArrayBuffer(8));
              s.setUint32(0, r.byteLength, !0), s[n(242)](4, 5130562, !0);
              const o = Sf(
                  (function (t) {
                    const e = hf;
                    return new TextEncoder()[e(332)](t)[e(369)];
                  })(JSON.stringify(a)),
                  32,
                ),
                l = new DataView(new ArrayBuffer(8));
              l[n(242)](0, o[n(331)], !0), l[n(242)](4, 1313821514, !0);
              const c = new ArrayBuffer(12),
                h = new DataView(c);
              h.setUint32(0, 1179937895, !0), h[n(242)](4, 2, !0);
              const u = 12 + l[n(331)] + o[n(331)] + s[n(331)] + r[n(331)];
              h[n(242)](8, u, !0);
              const d = new Blob([c, l, o, s, r], { type: n(413) }),
                p = new FileReader();
              p[n(172)](d),
                (p.onloadend = function () {
                  e(p[n(167)]);
                });
            });
        } else if (a[i(489)] && a.buffers[i(277)] > 0) {
          const t = new FileReader();
          t[i(470)](c),
            (t[i(426)] = function () {
              const n = i,
                r = t.result;
              (a[n(489)][0][n(434)] = r), e(a);
            });
        } else e(a);
      });
    }
    serializeUserData(t, e) {
      const n = hf;
      if (0 === Object[n(300)](t.userData)[n(277)]) return;
      const i = this.options,
        r = this[n(261)];
      try {
        const s = JSON[n(425)](JSON[n(394)](t[n(235)]));
        if (i[n(215)] && s.gltfExtensions) {
          void 0 === e[n(207)] && (e[n(207)] = {});
          for (const t in s[n(431)]) (e[n(207)][t] = s[n(431)][t]), (r[t] = !0);
          delete s.gltfExtensions;
        }
        Object.keys(s)[n(277)] > 0 && (e[n(512)] = s);
      } catch (s) {
        console[n(175)](n(282) + t[n(384)] + "' " + n(234) + s.message);
      }
    }
    [hf(346)](t, e = !1) {
      const n = hf;
      if (!1 === this.uids[n(411)](t)) {
        const e = new Map();
        e[n(502)](!0, this.uid++),
          e[n(502)](!1, this[n(421)]++),
          this[n(171)][n(502)](t, e);
      }
      return this.uids[n(438)](t)[n(438)](e);
    }
    [hf(344)](t) {
      const e = hf;
      if (this.cache[e(193)].has(t)) return !1;
      const n = new Nn();
      for (let i = 0, r = t[e(532)]; i < r; i++)
        if (Math[e(573)](n[e(429)](t, i).length() - 1) > 5e-4) return !1;
      return !0;
    }
    [hf(249)](t) {
      const e = hf,
        n = this[e(186)];
      if (n[e(193)][e(411)](t)) return n.attributesNormalized[e(438)](t);
      const i = t[e(174)](),
        r = new Nn();
      for (let s = 0, a = i[e(532)]; s < a; s++)
        r.fromBufferAttribute(i, s),
          0 === r.x && 0 === r.y && 0 === r.z ? r[e(463)](1) : r[e(472)](),
          i[e(549)](s, r.x, r.y, r.z);
      return n[e(193)][e(502)](t, i), i;
    }
    applyTextureTransform(t, e) {
      const n = hf;
      let i = !1;
      const r = {};
      (0 !== e.offset.x || 0 !== e[n(294)].y) &&
        ((r[n(294)] = e.offset[n(399)]()), (i = !0)),
        0 !== e.rotation && ((r[n(474)] = e[n(474)]), (i = !0)),
        (1 !== e.repeat.x || 1 !== e[n(430)].y) &&
          ((r.scale = e[n(430)][n(399)]()), (i = !0)),
        i &&
          ((t[n(207)] = t[n(207)] || {}),
          (t[n(207)][n(460)] = r),
          (this[n(261)][n(460)] = !0));
    }
    [hf(324)](t, e) {
      const n = hf;
      if (t === e) return t;
      function i(t) {
        const e = Uf;
        return t[e(445)] === Ne
          ? function (t) {
              return t < 0.04045
                ? 0.0773993808 * t
                : Math[e(339)](0.9478672986 * t + 0.0521327014, 2.4);
            }
          : function (t) {
              return t;
            };
      }
      console[n(175)](
        "THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.",
      ),
        t instanceof nc && (t = cf(t)),
        e instanceof nc && (e = cf(e));
      const r = t ? t.image : null,
        s = e ? e[n(402)] : null,
        a = Math[n(361)](r ? r[n(305)] : 0, s ? s[n(305)] : 0),
        o = Math[n(361)](r ? r[n(416)] : 0, s ? s[n(416)] : 0),
        l = bf();
      (l[n(305)] = a), (l[n(416)] = o);
      const c = l[n(319)]("2d");
      (c[n(497)] = n(312)), c[n(357)](0, 0, a, o);
      const h = c.getImageData(0, 0, a, o);
      if (r) {
        c.drawImage(r, 0, 0, a, o);
        const e = i(t),
          s = c.getImageData(0, 0, a, o)[n(525)];
        for (let t = 2; t < s[n(277)]; t += 4) h.data[t] = 256 * e(s[t] / 256);
      }
      if (s) {
        c.drawImage(s, 0, 0, a, o);
        const t = i(e),
          r = c[n(541)](0, 0, a, o).data;
        for (let e = 1; e < r[n(277)]; e += 4)
          h[n(525)][e] = 256 * t(r[e] / 256);
      }
      c[n(458)](h, 0, 0);
      const u = (t || e).clone();
      return (
        (u[n(262)] = new Tn(l)),
        (u.colorSpace = Ue),
        (u.channel = (t || e)[n(414)]),
        t && e && t.channel !== e[n(414)] && console[n(175)](n(203)),
        u
      );
    }
    processBuffer(t) {
      const e = hf,
        n = this[e(270)],
        i = this[e(489)];
      return n[e(489)] || (n[e(489)] = [{ byteLength: 0 }]), i[e(534)](t), 0;
    }
    [hf(370)](t, e, n, i, r) {
      const s = hf,
        a = this[s(270)];
      let o;
      switch ((a[s(451)] || (a.bufferViews = []), e)) {
        case mf[s(524)]:
        case mf[s(195)]:
          o = 1;
          break;
        case mf[s(503)]:
        case mf.UNSIGNED_SHORT:
          o = 2;
          break;
        default:
          o = 4;
      }
      const l = Mf(i * t.itemSize * o),
        c = new DataView(new ArrayBuffer(l));
      let h = 0;
      for (let d = n; d < n + i; d++)
        for (let n = 0; n < t[s(166)]; n++) {
          let i;
          t[s(166)] > 4
            ? (i = t[s(551)][d * t[s(166)] + n])
            : (0 === n
                ? (i = t[s(467)](d))
                : 1 === n
                ? (i = t[s(220)](d))
                : 2 === n
                ? (i = t.getZ(d))
                : 3 === n && (i = t[s(322)](d)),
              !0 === t[s(391)] && (i = rn[s(472)](i, t[s(551)]))),
            e === mf.FLOAT
              ? c.setFloat32(h, i, !0)
              : e === mf[s(440)]
              ? c.setInt32(h, i, !0)
              : e === mf[s(260)]
              ? c.setUint32(h, i, !0)
              : e === mf[s(503)]
              ? c.setInt16(h, i, !0)
              : e === mf[s(276)]
              ? c.setUint16(h, i, !0)
              : e === mf[s(524)]
              ? c[s(507)](h, i)
              : e === mf.UNSIGNED_BYTE && c.setUint8(h, i),
            (h += o);
        }
      const u = {
        buffer: this[s(382)](c.buffer),
        byteOffset: this[s(216)],
        byteLength: l,
      };
      void 0 !== r && (u[s(386)] = r),
        r === mf[s(550)] && (u[s(456)] = t.itemSize * o),
        (this[s(216)] += l),
        a[s(451)][s(534)](u);
      return { id: a[s(451)][s(277)] - 1, byteLength: 0 };
    }
    [hf(287)](t) {
      const e = hf,
        n = this,
        i = n[e(270)];
      return (
        i[e(451)] || (i[e(451)] = []),
        new Promise(function (r) {
          const s = e,
            a = new FileReader();
          a[s(172)](t),
            (a[s(426)] = function () {
              const t = s,
                e = Sf(a[t(167)]),
                o = {
                  buffer: n.processBuffer(e),
                  byteOffset: n.byteOffset,
                  byteLength: e[t(331)],
                };
              (n[t(216)] += e.byteLength), r(i[t(451)][t(534)](o) - 1);
            });
        })
      );
    }
    [hf(378)](t, e, n, i) {
      const r = hf,
        s = this.json,
        a = {
          1: r(304),
          2: "VEC2",
          3: r(243),
          4: r(347),
          9: r(548),
          16: "MAT4",
        };
      let o;
      if (t[r(551)].constructor === Float32Array) o = mf[r(542)];
      else if (t.array[r(297)] === Int32Array) o = mf[r(440)];
      else if (t.array[r(297)] === Uint32Array) o = mf.UNSIGNED_INT;
      else if (t[r(551)][r(297)] === Int16Array) o = mf[r(503)];
      else if (t.array.constructor === Uint16Array) o = mf[r(276)];
      else if (t[r(551)][r(297)] === Int8Array) o = mf[r(524)];
      else {
        if (t[r(551)][r(297)] !== Uint8Array)
          throw new Error(
            "THREE.GLTFExporter: Unsupported bufferAttribute component type: " +
              t.array[r(297)].name,
          );
        o = mf[r(195)];
      }
      if ((void 0 === n && (n = 0), void 0 === i && (i = t[r(532)]), 0 === i))
        return null;
      const l = (function (t, e, n) {
        const i = hf,
          r = {
            min: new Array(t[i(166)]).fill(Number[i(389)]),
            max: new Array(t[i(166)])[i(418)](Number.NEGATIVE_INFINITY),
          };
        for (let s = e; s < e + n; s++)
          for (let e = 0; e < t[i(166)]; e++) {
            let n;
            t.itemSize > 4
              ? (n = t[i(551)][s * t[i(166)] + e])
              : (0 === e
                  ? (n = t[i(467)](s))
                  : 1 === e
                  ? (n = t.getY(s))
                  : 2 === e
                  ? (n = t.getZ(s))
                  : 3 === e && (n = t[i(322)](s)),
                !0 === t.normalized && (n = rn[i(472)](n, t[i(551)]))),
              (r[i(459)][e] = Math[i(459)](r[i(459)][e], n)),
              (r[i(361)][e] = Math[i(361)](r.max[e], n));
          }
        return r;
      })(t, n, i);
      let c;
      void 0 !== e && (c = t === e[r(449)] ? mf[r(303)] : mf[r(550)]);
      const h = this[r(370)](t, o, n, i, c),
        u = {
          bufferView: h.id,
          byteOffset: h[r(216)],
          componentType: o,
          count: i,
          max: l.max,
          min: l[r(459)],
          type: a[t[r(166)]],
        };
      return (
        !0 === t[r(391)] && (u[r(391)] = !0),
        s[r(566)] || (s[r(566)] = []),
        s[r(566)][r(534)](u) - 1
      );
    }
    [hf(388)](t, e, n, i = hf(407)) {
      const r = hf;
      if (null !== t) {
        const s = this,
          a = s[r(186)],
          o = s.json,
          l = s[r(383)],
          c = s.pending;
        a[r(498)][r(411)](t) || a[r(498)][r(502)](t, {});
        const h = a[r(498)][r(438)](t),
          u = i + r(225) + n[r(564)]();
        if (void 0 !== h[u]) return h[u];
        o[r(498)] || (o[r(498)] = []);
        const d = { mimeType: i },
          p = bf();
        (p[r(305)] = Math[r(459)](t[r(305)], l[r(348)])),
          (p.height = Math[r(459)](t[r(416)], l[r(348)]));
        const f = p.getContext("2d");
        if (
          (!0 === n && (f[r(340)](0, p[r(416)]), f[r(526)](1, -1)),
          void 0 !== t[r(525)])
        ) {
          e !== Gt && console.error(r(285), e),
            (t.width > l[r(348)] || t[r(416)] > l.maxTextureSize) &&
              console[r(175)](r(412), t);
          const n = new Uint8ClampedArray(t[r(416)] * t.width * 4);
          for (let e = 0; e < n[r(277)]; e += 4)
            (n[e + 0] = t[r(525)][e + 0]),
              (n[e + 1] = t.data[e + 1]),
              (n[e + 2] = t[r(525)][e + 2]),
              (n[e + 3] = t[r(525)][e + 3]);
          f.putImageData(new ImageData(n, t[r(305)], t[r(416)]), 0, 0);
        } else f.drawImage(t, 0, 0, p.width, p[r(416)]);
        !0 === l[r(180)]
          ? c[r(534)](
              Tf(p, i)
                [r(315)]((t) => s.processBufferViewImage(t))
                [r(315)]((t) => {
                  d[r(519)] = t;
                }),
            )
          : void 0 !== p.toDataURL
          ? (d.uri = p[r(350)](i))
          : c.push(
              Tf(p, i)
                .then((t) => new FileReader()[r(470)](t))
                [r(315)]((t) => {
                  d[r(434)] = t;
                }),
            );
        const m = o[r(498)].push(d) - 1;
        return (h[u] = m), m;
      }
      throw new Error(r(516));
    }
    [hf(251)](t) {
      const e = hf,
        n = this[e(270)];
      n[e(200)] || (n.samplers = []);
      const i = {
        magFilter: vf[t[e(247)]],
        minFilter: vf[t.minFilter],
        wrapS: vf[t[e(543)]],
        wrapT: vf[t[e(535)]],
      };
      return n[e(200)].push(i) - 1;
    }
    processTexture(t) {
      const e = hf,
        n = this[e(383)],
        i = this[e(186)],
        r = this.json;
      if (i[e(396)][e(411)](t)) return i[e(396)][e(438)](t);
      r[e(396)] || (r[e(396)] = []),
        t instanceof nc && (t = cf(t, n.maxTextureSize));
      let s = t[e(235)][e(343)];
      s === e(439) && (s = e(407));
      const a = {
        sampler: this[e(251)](t),
        source: this.processImage(t.image, t[e(537)], t[e(360)], s),
      };
      t[e(384)] && (a[e(384)] = t.name),
        this._invokeAll(function (n) {
          n[e(504)] && n.writeTexture(t, a);
        });
      const o = r[e(396)][e(534)](a) - 1;
      return i[e(396)].set(t, o), o;
    }
    processMaterial(t) {
      const e = hf,
        n = this[e(186)],
        i = this[e(270)];
      if (n[e(205)][e(411)](t)) return n[e(205)][e(438)](t);
      if (t.isShaderMaterial) return console[e(175)](e(219)), null;
      i[e(205)] || (i.materials = []);
      const r = { pbrMetallicRoughness: {} };
      !0 !== t[e(365)] && !0 !== t[e(323)] && console.warn(e(476));
      const s = t[e(259)][e(399)]().concat([t[e(214)]]);
      if (
        (!xf(s, [1, 1, 1, 1]) && (r[e(169)].baseColorFactor = s),
        t[e(365)]
          ? ((r[e(169)][e(295)] = t[e(239)]),
            (r.pbrMetallicRoughness[e(432)] = t.roughness))
          : ((r[e(169)].metallicFactor = 0.5),
            (r.pbrMetallicRoughness[e(432)] = 0.5)),
        t[e(552)] || t[e(481)])
      ) {
        const n = this.buildMetalRoughTexture(t[e(552)], t[e(481)]),
          i = { index: this[e(400)](n), channel: n[e(414)] };
        this[e(293)](i, n), (r[e(169)].metallicRoughnessTexture = i);
      }
      if (t[e(513)]) {
        const n = { index: this[e(400)](t.map), texCoord: t[e(513)][e(414)] };
        this[e(293)](n, t.map), (r.pbrMetallicRoughness[e(320)] = n);
      }
      if (t.emissive) {
        const n = t.emissive;
        if (
          (Math[e(361)](n.r, n.g, n.b) > 0 &&
            (r[e(409)] = t.emissive[e(399)]()),
          t[e(557)])
        ) {
          const n = {
            index: this[e(400)](t[e(557)]),
            texCoord: t[e(557)][e(414)],
          };
          this[e(293)](n, t[e(557)]), (r[e(316)] = n);
        }
      }
      if (t[e(404)]) {
        const n = {
          index: this.processTexture(t[e(404)]),
          texCoord: t[e(404)].channel,
        };
        t.normalScale && 1 !== t[e(232)].x && (n[e(526)] = t.normalScale.x),
          this[e(293)](n, t[e(404)]),
          (r[e(375)] = n);
      }
      if (t[e(224)]) {
        const n = { index: this[e(400)](t.aoMap), texCoord: t[e(224)][e(414)] };
        1 !== t[e(353)] && (n.strength = t.aoMapIntensity),
          this[e(293)](n, t.aoMap),
          (r.occlusionTexture = n);
      }
      t.transparent
        ? (r.alphaMode = e(453))
        : t[e(538)] > 0 && ((r[e(559)] = e(337)), (r[e(485)] = t[e(538)])),
        2 === t[e(480)] && (r[e(483)] = !0),
        "" !== t[e(384)] && (r.name = t[e(384)]),
        this[e(272)](t, r),
        this[e(329)](function (n) {
          n[e(387)] && n.writeMaterial(t, r);
        });
      const a = i.materials[e(534)](r) - 1;
      return n[e(205)][e(502)](t, a), a;
    }
    [hf(230)](t) {
      const e = hf,
        n = this[e(186)],
        i = this[e(270)],
        r = [t[e(284)][e(170)]];
      if (Array[e(313)](t[e(204)]))
        for (let y = 0, x = t.material[e(277)]; y < x; y++)
          r.push(t[e(204)][y].uuid);
      else r.push(t[e(204)][e(170)]);
      const s = r[e(317)](":");
      if (n[e(547)][e(411)](s)) return n[e(547)].get(s);
      const a = t[e(284)];
      let o;
      o = t.isLineSegments
        ? mf[e(192)]
        : t[e(433)]
        ? mf.LINE_LOOP
        : t[e(210)]
        ? mf[e(435)]
        : t[e(288)]
        ? mf[e(328)]
        : t[e(204)][e(206)]
        ? mf[e(192)]
        : mf.TRIANGLES;
      const l = {},
        c = {},
        h = [],
        u = [],
        d = {
          uv: e(289),
          uv1: e(189),
          color: e(450),
          skinWeight: e(321),
          skinIndex: e(530),
        },
        p = a.getAttribute(e(469));
      void 0 !== p &&
        !this[e(344)](p) &&
        (console[e(175)](e(554)),
        a[e(336)](e(469), this.createNormalizedNormalAttribute(p)));
      let f = null;
      for (let y in a[e(563)]) {
        if (y[e(367)](0, 5) === e(447)) continue;
        const t = a.attributes[y];
        y = d[y] || y[e(241)]();
        if (
          (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/[
            e(479)
          ](y) || (y = "_" + y),
          n[e(563)][e(411)](this[e(346)](t)))
        ) {
          c[y] = n[e(563)][e(438)](this[e(346)](t));
          continue;
        }
        f = null;
        const i = t[e(551)];
        y === e(530) &&
          !(i instanceof Uint16Array) &&
          !(i instanceof Uint8Array) &&
          (console[e(175)](e(509)),
          (f = new hr(new Uint16Array(i), t[e(166)], t.normalized)));
        const r = this[e(378)](f || t, a);
        null !== r &&
          (!y.startsWith("_") && this[e(401)](y, t),
          (c[y] = r),
          n.attributes[e(502)](this.getUID(t), r));
      }
      if (
        (void 0 !== p && a[e(336)](e(469), p), 0 === Object[e(300)](c)[e(277)])
      )
        return null;
      if (void 0 !== t[e(265)] && t[e(265)].length > 0) {
        const i = [],
          r = [],
          s = {};
        if (void 0 !== t[e(264)])
          for (const n in t.morphTargetDictionary) s[t[e(264)][n]] = n;
        for (let o = 0; o < t[e(265)][e(277)]; ++o) {
          const l = {};
          let c = !1;
          for (const t in a[e(185)]) {
            if (t !== e(211) && t !== e(469)) {
              !c &&
                (console.warn(
                  "GLTFExporter: Only POSITION and NORMAL morph are supported.",
                ),
                (c = !0));
              continue;
            }
            const i = a[e(185)][t][o],
              r = t[e(241)](),
              s = a[e(563)][t];
            if (n.attributes.has(this[e(346)](i, !0))) {
              l[r] = n.attributes[e(438)](this[e(346)](i, !0));
              continue;
            }
            const h = i[e(174)]();
            if (!a[e(397)])
              for (let t = 0, n = i[e(532)]; t < n; t++)
                for (let r = 0; r < i.itemSize; r++)
                  0 === r && h[e(463)](t, i[e(467)](t) - s[e(467)](t)),
                    1 === r && h[e(528)](t, i[e(220)](t) - s[e(220)](t)),
                    2 === r && h[e(248)](t, i[e(533)](t) - s[e(533)](t)),
                    3 === r && h.setW(t, i[e(322)](t) - s[e(322)](t));
            (l[r] = this[e(378)](h, a)),
              n.attributes[e(502)](this[e(346)](s, !0), l[r]);
          }
          u.push(l), i.push(t[e(265)][o]), void 0 !== t[e(264)] && r.push(s[o]);
        }
        (l[e(437)] = i),
          r[e(277)] > 0 && ((l[e(512)] = {}), (l[e(512)][e(194)] = r));
      }
      const m = Array[e(313)](t[e(204)]);
      if (m && 0 === a[e(253)][e(277)]) return null;
      const g = m ? t[e(204)] : [t[e(204)]],
        v = m
          ? a[e(253)]
          : [{ materialIndex: 0, start: void 0, count: void 0 }];
      for (let y = 0, x = v[e(277)]; y < x; y++) {
        const t = { mode: o, attributes: c };
        if (
          (this[e(272)](a, t),
          u[e(277)] > 0 && (t[e(379)] = u),
          null !== a[e(449)])
        ) {
          let i = this[e(346)](a[e(449)]);
          (void 0 !== v[y][e(267)] || void 0 !== v[y][e(532)]) &&
            (i += ":" + v[y].start + ":" + v[y][e(532)]),
            n[e(563)].has(i)
              ? (t[e(372)] = n[e(563)].get(i))
              : ((t[e(372)] = this[e(378)](
                  a.index,
                  a,
                  v[y][e(267)],
                  v[y][e(532)],
                )),
                n[e(563)].set(i, t[e(372)])),
            null === t[e(372)] && delete t[e(372)];
        }
        const i = this[e(325)](g[v[y].materialIndex]);
        null !== i && (t[e(204)] = i), h[e(534)](t);
      }
      (l.primitives = h),
        i.meshes || (i[e(547)] = []),
        this._invokeAll(function (n) {
          const i = e;
          n[i(177)] && n[i(177)](t, l);
        });
      const _ = i[e(547)].push(l) - 1;
      return n[e(547)][e(502)](s, _), _;
    }
    [hf(401)](t, e) {
      const n = hf;
      if (this.extensionsUsed[gf]) return;
      let i;
      switch (e.array.constructor) {
        case Int8Array:
          i = n(496);
          break;
        case Uint8Array:
          i = "unsigned byte";
          break;
        case Int16Array:
          i = "short";
          break;
        case Uint16Array:
          i = "unsigned short";
          break;
        default:
          return;
      }
      e[n(391)] && (i += n(486));
      const r = t[n(436)]("_", 1)[0];
      pf[r] &&
        pf[r][n(341)](i) &&
        ((this[n(261)][gf] = !0), (this[n(254)][gf] = !0));
    }
    [hf(506)](t) {
      const e = hf,
        n = this[e(270)];
      n[e(446)] || (n[e(446)] = []);
      const i = t[e(522)],
        r = { type: e(i ? 461 : 567) };
      return (
        i
          ? (r[e(461)] = {
              xmag: 2 * t.right,
              ymag: 2 * t[e(523)],
              zfar: t[e(183)] <= 0 ? 0.001 : t[e(183)],
              znear: t.near < 0 ? 0 : t[e(377)],
            })
          : (r[e(567)] = {
              aspectRatio: t.aspect,
              yfov: rn[e(540)](t[e(286)]),
              zfar: t[e(183)] <= 0 ? 0.001 : t.far,
              znear: t[e(377)] < 0 ? 0 : t[e(377)],
            }),
        "" !== t[e(384)] && (r[e(384)] = t[e(536)]),
        n[e(446)][e(534)](r) - 1
      );
    }
    processAnimation(t, e) {
      const n = hf,
        i = this[n(270)],
        r = this.nodeMap;
      i[n(188)] || (i[n(188)] = []);
      const s = (t = ff[n(545)][n(335)](t[n(174)](), e)).tracks,
        a = [],
        o = [];
      for (let l = 0; l < s[n(277)]; ++l) {
        const t = s[l],
          i = ld[n(338)](t[n(384)]);
        let c = ld[n(381)](e, i[n(240)]);
        const h = _f[i[n(212)]];
        if (
          (i[n(514)] === n(330) &&
            (c = !0 === c[n(202)] ? c.skeleton[n(269)](i[n(555)]) : void 0),
          !c || !h)
        )
          return console[n(175)](n(572), t[n(384)]), null;
        const u = 1;
        let d,
          p = t[n(571)][n(277)] / t[n(309)][n(277)];
        h === _f[n(265)] && (p /= c[n(265)].length),
          !0 === t[n(395)][n(490)]
            ? ((d = n(273)), (p /= 3))
            : (d = t[n(392)]() === be ? n(374) : "LINEAR"),
          o.push({
            input: this[n(378)](new hr(t[n(309)], u)),
            output: this[n(378)](new hr(t[n(571)], p)),
            interpolation: d,
          }),
          a[n(534)]({
            sampler: o[n(277)] - 1,
            target: { node: r[n(438)](c), path: h },
          });
      }
      return (
        i[n(188)].push({
          name: t[n(384)] || n(565) + i.animations[n(277)],
          samplers: o,
          channels: a,
        }),
        i[n(188)][n(277)] - 1
      );
    }
    [hf(351)](t) {
      const e = hf,
        n = this[e(270)],
        i = this[e(271)],
        r = n[e(457)][i.get(t)],
        s = t[e(393)];
      if (void 0 === s) return null;
      const a = t[e(393)][e(330)][0];
      if (void 0 === a) return null;
      const o = [],
        l = new Float32Array(16 * s.bones[e(277)]),
        c = new hi();
      for (let h = 0; h < s[e(330)].length; ++h)
        o[e(534)](i[e(438)](s.bones[h])),
          c.copy(s[e(244)][h]),
          c[e(355)](t[e(278)])[e(399)](l, 16 * h);
      void 0 === n[e(501)] && (n[e(501)] = []),
        n[e(501)].push({
          inverseBindMatrices: this[e(378)](new hr(l, 16)),
          joints: o,
          skeleton: i[e(438)](a),
        });
      return (r.skin = n[e(501)][e(277)] - 1);
    }
    [hf(268)](t) {
      const e = hf,
        n = this.json,
        i = this[e(383)],
        r = this[e(271)];
      n[e(457)] || (n[e(457)] = []);
      const s = {};
      if (i[e(307)]) {
        const n = t[e(493)][e(399)](),
          i = t.position.toArray(),
          r = t[e(526)].toArray();
        !xf(n, [0, 0, 0, 1]) && (s[e(474)] = n),
          !xf(i, [0, 0, 0]) && (s[e(441)] = i),
          !xf(r, [1, 1, 1]) && (s[e(526)] = r);
      } else t.matrixAutoUpdate && t[e(403)](), !1 === xf(t[e(231)].elements, [1,
                0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (s[e(231)] = t[e(231)][e(314)]);
      if (
        ("" !== t[e(384)] && (s.name = String(t.name)),
        this[e(272)](t, s),
        t[e(311)] || t.isLine || t[e(288)])
      ) {
        const e = this.processMesh(t);
        null !== e && (s.mesh = e);
      } else t.isCamera && (s[e(560)] = this[e(506)](t));
      if ((t[e(202)] && this[e(501)].push(t), t[e(318)].length > 0)) {
        const n = [];
        for (let r = 0, s = t.children[e(277)]; r < s; r++) {
          const s = t[e(318)][r];
          if (s[e(515)] || !1 === i[e(352)]) {
            const t = this.processNode(s);
            null !== t && n.push(t);
          }
        }
        n[e(277)] > 0 && (s[e(318)] = n);
      }
      this._invokeAll(function (n) {
        const i = e;
        n.writeNode && n[i(236)](t, s);
      });
      const a = n[e(457)][e(534)](s) - 1;
      return r.set(t, a), a;
    }
    [hf(570)](t) {
      const e = hf,
        n = this[e(270)],
        i = this[e(383)];
      !n[e(556)] && ((n[e(556)] = []), (n[e(520)] = 0));
      const r = {};
      "" !== t[e(384)] && (r.name = t.name), n[e(556)].push(r);
      const s = [];
      for (let a = 0, o = t[e(318)][e(277)]; a < o; a++) {
        const n = t.children[a];
        if (n[e(515)] || !1 === i[e(352)]) {
          const t = this[e(268)](n);
          null !== t && s[e(534)](t);
        }
      }
      s[e(277)] > 0 && (r[e(457)] = s), this[e(272)](t, r);
    }
    processObjects(t) {
      const e = hf,
        n = new jo();
      n[e(384)] = e(283);
      for (let i = 0; i < t[e(277)]; i++) n[e(318)].push(t[i]);
      this[e(570)](n);
    }
    [hf(419)](t) {
      const e = hf,
        n = this[e(383)];
      (t = t instanceof Array ? t : [t]),
        this[e(329)](function (n) {
          n[e(237)] && n.beforeParse(t);
        });
      const i = [];
      for (let r = 0; r < t.length; r++)
        t[r] instanceof jo ? this[e(570)](t[r]) : i[e(534)](t[r]);
      i[e(277)] > 0 && this[e(511)](i);
      for (let r = 0; r < this.skins[e(277)]; ++r)
        this[e(351)](this[e(501)][r]);
      for (let r = 0; r < n[e(188)].length; ++r)
        this.processAnimation(n.animations[r], t[0]);
      this._invokeAll(function (n) {
        const i = e;
        n.afterParse && n[i(415)](t);
      });
    }
    _invokeAll(t) {
      const e = hf;
      for (let n = 0, i = this.plugins[e(277)]; n < i; n++) t(this.plugins[n]);
    }
  }
  class Ef {
    constructor(t) {
      const e = hf;
      (this[e(168)] = t), (this[e(384)] = e(478));
    }
    [hf(236)](t, e) {
      const n = hf;
      if (!t[n(518)]) return;
      if (!t[n(255)] && !t[n(257)] && !t[n(569)])
        return void console[n(175)](n(531), t);
      const i = this.writer,
        r = i[n(270)],
        s = i[n(261)],
        a = {};
      t.name && (a[n(384)] = t[n(384)]),
        (a.color = t[n(259)][n(399)]()),
        (a[n(420)] = t[n(420)]),
        t[n(255)]
          ? (a[n(536)] = "directional")
          : t[n(257)]
          ? ((a[n(536)] = n(358)), t.distance > 0 && (a.range = t[n(173)]))
          : t.isSpotLight &&
            ((a[n(536)] = n(371)),
            t[n(173)] > 0 && (a[n(546)] = t[n(173)]),
            (a[n(371)] = {}),
            (a.spot[n(553)] = (t[n(454)] - 1) * t[n(473)] * -1),
            (a[n(371)].outerConeAngle = t[n(473)])),
        void 0 !== t[n(208)] &&
          2 !== t[n(208)] &&
          console[n(175)](n(405) + n(274)),
        t[n(386)] &&
          (t[n(386)][n(465)] !== t ||
            0 !== t.target[n(211)].x ||
            0 !== t[n(386)].position.y ||
            -1 !== t[n(386)][n(211)].z) &&
          console[n(175)](n(495) + n(182)),
        !s[this[n(384)]] &&
          ((r.extensions = r[n(207)] || {}),
          (r[n(207)][this[n(384)]] = { lights: [] }),
          (s[this.name] = !0));
      const o = r.extensions[this[n(384)]][n(327)];
      o.push(a),
        (e[n(207)] = e[n(207)] || {}),
        (e.extensions[this.name] = { light: o[n(277)] - 1 });
    }
  }
  class Af {
    constructor(t) {
      const e = hf;
      (this[e(168)] = t), (this[e(384)] = e(296));
    }
    [hf(387)](t, e) {
      const n = hf;
      if (!t[n(323)]) return;
      const i = this[n(168)].extensionsUsed;
      (e[n(207)] = e[n(207)] || {}),
        (e[n(207)][this[n(384)]] = {}),
        (i[this[n(384)]] = !0),
        (e[n(169)].metallicFactor = 0),
        (e.pbrMetallicRoughness[n(432)] = 0.9);
    }
  }
  class Rf {
    constructor(t) {
      const e = hf;
      (this.writer = t), (this[e(384)] = e(342));
    }
    writeMaterial(t, e) {
      const n = hf;
      if (!t.isMeshPhysicalMaterial || 0 === t.clearcoat) return;
      const i = this[n(168)],
        r = i[n(261)],
        s = {};
      if (((s[n(505)] = t.clearcoat), t[n(494)])) {
        const e = {
          index: i.processTexture(t.clearcoatMap),
          texCoord: t[n(494)][n(414)],
        };
        i[n(293)](e, t[n(494)]), (s[n(359)] = e);
      }
      if (((s[n(165)] = t.clearcoatRoughness), t[n(568)])) {
        const e = {
          index: i[n(400)](t[n(568)]),
          texCoord: t.clearcoatRoughnessMap[n(414)],
        };
        i[n(293)](e, t[n(568)]), (s[n(184)] = e);
      }
      if (t[n(508)]) {
        const e = { index: i[n(400)](t[n(508)]), texCoord: t[n(508)][n(414)] };
        i[n(293)](e, t[n(508)]), (s.clearcoatNormalTexture = e);
      }
      (e[n(207)] = e[n(207)] || {}),
        (e.extensions[this.name] = s),
        (r[this[n(384)]] = !0);
    }
  }
  class Cf {
    constructor(t) {
      const e = hf;
      (this[e(168)] = t), (this[e(384)] = e(544));
    }
    [hf(387)](t, e) {
      const n = hf;
      if (!t[n(349)] || 0 === t[n(482)]) return;
      const i = this.writer,
        r = i.extensionsUsed,
        s = {};
      if (((s[n(164)] = t[n(482)]), t[n(424)])) {
        const e = { index: i[n(400)](t[n(424)]), texCoord: t[n(424)][n(414)] };
        i[n(293)](e, t[n(424)]), (s.iridescenceTexture = e);
      }
      if (
        ((s[n(334)] = t[n(539)]),
        (s.iridescenceThicknessMinimum = t[n(423)][0]),
        (s[n(444)] = t.iridescenceThicknessRange[1]),
        t[n(408)])
      ) {
        const e = {
          index: i.processTexture(t.iridescenceThicknessMap),
          texCoord: t[n(408)][n(414)],
        };
        i[n(293)](e, t[n(408)]), (s.iridescenceThicknessTexture = e);
      }
      (e[n(207)] = e.extensions || {}),
        (e[n(207)][this.name] = s),
        (r[this[n(384)]] = !0);
    }
  }
  class Lf {
    constructor(t) {
      const e = hf;
      (this[e(168)] = t), (this[e(384)] = "KHR_materials_transmission");
    }
    [hf(387)](t, e) {
      const n = hf;
      if (!t[n(349)] || 0 === t[n(562)]) return;
      const i = this[n(168)],
        r = i[n(261)],
        s = {};
      if (((s[n(218)] = t[n(562)]), t.transmissionMap)) {
        const e = {
          index: i[n(400)](t[n(308)]),
          texCoord: t.transmissionMap.channel,
        };
        i[n(293)](e, t[n(308)]), (s[n(356)] = e);
      }
      (e[n(207)] = e.extensions || {}),
        (e[n(207)][this[n(384)]] = s),
        (r[this[n(384)]] = !0);
    }
  }
  class If {
    constructor(t) {
      const e = hf;
      (this[e(168)] = t), (this[e(384)] = e(561));
    }
    [hf(387)](t, e) {
      const n = hf;
      if (!t.isMeshPhysicalMaterial || 0 === t[n(562)]) return;
      const i = this[n(168)],
        r = i[n(261)],
        s = {};
      if (((s[n(201)] = t[n(363)]), t[n(345)])) {
        const e = {
          index: i[n(400)](t[n(345)]),
          texCoord: t.thicknessMap[n(414)],
        };
        i[n(293)](e, t[n(345)]), (s[n(471)] = e);
      }
      (s[n(462)] = t[n(462)]),
        (s[n(529)] = t[n(529)][n(399)]()),
        (e.extensions = e[n(207)] || {}),
        (e.extensions[this[n(384)]] = s),
        (r[this[n(384)]] = !0);
    }
  }
  class Pf {
    constructor(t) {
      const e = hf;
      (this[e(168)] = t), (this[e(384)] = e(258));
    }
    [hf(387)](t, e) {
      const n = hf;
      if (!t.isMeshPhysicalMaterial || 1.5 === t[n(484)]) return;
      const i = this[n(168)][n(261)],
        r = {};
      (r[n(484)] = t.ior),
        (e[n(207)] = e[n(207)] || {}),
        (e[n(207)][this[n(384)]] = r),
        (i[this.name] = !0);
    }
  }
  function Uf(t, e) {
    const n = Ff();
    return (Uf = function (t, e) {
      return n[(t -= 163)];
    })(t, e);
  }
  class Nf {
    constructor(t) {
      const e = hf;
      (this[e(168)] = t), (this[e(384)] = e(491));
    }
    [hf(387)](t, e) {
      const n = hf;
      if (
        !t[n(349)] ||
        (1 === t.specularIntensity &&
          t[n(198)][n(475)](yf) &&
          !t[n(385)] &&
          !t.specularColorTexture)
      )
        return;
      const i = this.writer,
        r = i.extensionsUsed,
        s = {};
      if (t.specularIntensityMap) {
        const e = {
          index: i.processTexture(t[n(385)]),
          texCoord: t[n(385)][n(414)],
        };
        i[n(293)](e, t[n(385)]), (s[n(209)] = e);
      }
      if (t[n(354)]) {
        const e = {
          index: i.processTexture(t[n(354)]),
          texCoord: t.specularColorMap.channel,
        };
        i[n(293)](e, t[n(354)]), (s[n(455)] = e);
      }
      (s[n(227)] = t[n(487)]),
        (s[n(442)] = t[n(198)][n(399)]()),
        (e.extensions = e[n(207)] || {}),
        (e[n(207)][this[n(384)]] = s),
        (r[this.name] = !0);
    }
  }
  class Of {
    constructor(t) {
      const e = hf;
      (this.writer = t), (this[e(384)] = e(252));
    }
    [hf(387)](t, e) {
      const n = hf;
      if (!t[n(349)] || 0 == t.sheen) return;
      const i = this[n(168)],
        r = i[n(261)],
        s = {};
      if (t[n(223)]) {
        const e = {
          index: i.processTexture(t[n(223)]),
          texCoord: t[n(223)][n(414)],
        };
        i[n(293)](e, t[n(223)]), (s[n(376)] = e);
      }
      if (t[n(499)]) {
        const e = {
          index: i[n(400)](t[n(499)]),
          texCoord: t.sheenColorMap[n(414)],
        };
        i[n(293)](e, t[n(499)]), (s[n(266)] = e);
      }
      (s[n(488)] = t[n(263)]),
        (s.sheenColorFactor = t[n(558)].toArray()),
        (e.extensions = e[n(207)] || {}),
        (e[n(207)][this[n(384)]] = s),
        (r[this[n(384)]] = !0);
    }
  }
  class Df {
    constructor(t) {
      const e = hf;
      (this[e(168)] = t), (this[e(384)] = e(217));
    }
    [hf(387)](t, e) {
      const n = hf;
      if (!t[n(349)] || 0 == t[n(190)]) return;
      const i = this[n(168)],
        r = i[n(261)],
        s = {};
      if (t[n(427)]) {
        const e = { index: i[n(400)](t[n(427)]) };
        i[n(293)](e, t[n(427)]), (s[n(468)] = e);
      }
      (s[n(410)] = t.anisotropy),
        (s[n(176)] = t.anisotropyRotation),
        (e.extensions = e[n(207)] || {}),
        (e[n(207)][this[n(384)]] = s),
        (r[this.name] = !0);
    }
  }
  function Ff() {
    const t = [
      "geometry",
      "GLTFExporter: Only RGBAFormat is supported.",
      "fov",
      "processBufferViewImage",
      "isPoints",
      "TEXCOORD_0",
      "THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.",
      "createElement",
      "MIRRORED_REPEAT",
      "applyTextureTransform",
      "offset",
      "metallicFactor",
      "KHR_materials_unlit",
      "constructor",
      "ValueBufferType",
      "unsigned byte normalized",
      "keys",
      "apply",
      "setPlugins",
      "ELEMENT_ARRAY_BUFFER",
      "SCALAR",
      "width",
      "KHR_mesh_quantization",
      "trs",
      "transmissionMap",
      "times",
      "image/jpeg",
      "isMesh",
      "#00ffff",
      "isArray",
      "elements",
      "then",
      "emissiveTexture",
      "join",
      "children",
      "getContext",
      "baseColorTexture",
      "WEIGHTS_0",
      "getW",
      "isMeshBasicMaterial",
      "buildMetalRoughTexture",
      "processMaterial",
      "evaluate",
      "lights",
      "POINTS",
      "_invokeAll",
      "bones",
      "byteLength",
      "encode",
      "convertToBlob",
      "iridescenceIor",
      "mergeMorphTargetTracks",
      "setAttribute",
      "MASK",
      "parseTrackName",
      "pow",
      "translate",
      "includes",
      "KHR_materials_clearcoat",
      "mimeType",
      "isNormalizedNormalAttribute",
      "thicknessMap",
      "getUID",
      "VEC4",
      "maxTextureSize",
      "isMeshPhysicalMaterial",
      "toDataURL",
      "processSkin",
      "onlyVisible",
      "aoMapIntensity",
      "specularColorMap",
      "multiply",
      "transmissionTexture",
      "fillRect",
      "point",
      "clearcoatTexture",
      "flipY",
      "max",
      "4MjOgUG",
      "thickness",
      "22aHwusP",
      "isMeshStandardMaterial",
      "byte normalized",
      "slice",
      "502062bFrRtE",
      "buffer",
      "processBufferView",
      "spot",
      "indices",
      "450480ZxtDYx",
      "STEP",
      "normalTexture",
      "sheenRoughnessTexture",
      "near",
      "processAccessor",
      "targets",
      "2450hqVnRV",
      "findNode",
      "processBuffer",
      "options",
      "name",
      "specularIntensityMap",
      "target",
      "writeMaterial",
      "processImage",
      "POSITIVE_INFINITY",
      "register",
      "normalized",
      "getInterpolation",
      "skeleton",
      "stringify",
      "createInterpolant",
      "textures",
      "morphTargetsRelative",
      "splice",
      "toArray",
      "processTexture",
      "detectMeshQuantization",
      "image",
      "updateMatrix",
      "normalMap",
      "THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ",
      "size",
      "image/png",
      "iridescenceThicknessMap",
      "emissiveFactor",
      "anisotropyStrength",
      "has",
      "GLTFExporter: Image size is bigger than maxTextureSize",
      "application/octet-stream",
      "channel",
      "afterParse",
      "height",
      "unsigned short normalized",
      "fill",
      "processInput",
      "intensity",
      "uid",
      "CLAMP_TO_EDGE",
      "iridescenceThicknessRange",
      "iridescenceMap",
      "parse",
      "onloadend",
      "anisotropyMap",
      "write",
      "fromBufferAttribute",
      "repeat",
      "gltfExtensions",
      "roughnessFactor",
      "isLineLoop",
      "uri",
      "LINE_STRIP",
      "split",
      "weights",
      "get",
      "image/webp",
      "INT",
      "translation",
      "specularColorFactor",
      "search",
      "iridescenceThicknessMaximum",
      "colorSpace",
      "cameras",
      "morph",
      "THREE.GLTFExporter: Morph target name not found: ",
      "index",
      "COLOR_0",
      "bufferViews",
      "THREE.GLTFExporter",
      "BLEND",
      "penumbra",
      "specularColorTexture",
      "byteStride",
      "nodes",
      "putImageData",
      "min",
      "KHR_texture_transform",
      "orthographic",
      "attenuationDistance",
      "setX",
      "unregister",
      "parent",
      "catch",
      "getX",
      "anisotropyTexture",
      "normal",
      "readAsDataURL",
      "thicknessTexture",
      "normalize",
      "angle",
      "rotation",
      "equals",
      "GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.",
      "short normalized",
      "KHR_lights_punctual",
      "test",
      "side",
      "roughnessMap",
      "iridescence",
      "doubleSided",
      "ior",
      "alphaCutoff",
      " normalized",
      "specularIntensity",
      "sheenRoughnessFactor",
      "buffers",
      "isInterpolantFactoryMethodGLTFCubicSpline",
      "KHR_materials_specular",
      "short",
      "quaternion",
      "clearcoatMap",
      "THREE.GLTFExporter: Light direction may be lost. For best results, ",
      "byte",
      "fillStyle",
      "images",
      "sheenColorMap",
      "getValueSize",
      "skins",
      "set",
      "SHORT",
      "writeTexture",
      "clearcoatFactor",
      "processCamera",
      "setInt8",
      "clearcoatNormalMap",
      'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.',
      "2501440lPZeIL",
      "processObjects",
      "extras",
      "map",
      "objectName",
      "visible",
      "THREE.GLTFExporter: No valid image data found. Unable to process texture.",
      "assign",
      "isLight",
      "bufferView",
      "scene",
      "all",
      "isOrthographicCamera",
      "top",
      "BYTE",
      "data",
      "scale",
      "NEAREST_MIPMAP_NEAREST",
      "setY",
      "attenuationColor",
      "JOINTS_0",
      "THREE.GLTFExporter: Only directional, point, and spot lights are supported.",
      "count",
      "getZ",
      "push",
      "wrapT",
      "type",
      "format",
      "alphaTest",
      "iridescenceIOR",
      "degToRad",
      "getImageData",
      "FLOAT",
      "wrapS",
      "KHR_materials_iridescence",
      "Utils",
      "range",
      "meshes",
      "MAT3",
      "setXYZ",
      "ARRAY_BUFFER",
      "array",
      "metalnessMap",
      "innerConeAngle",
      "THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.",
      "objectIndex",
      "scenes",
      "emissiveMap",
      "sheenColor",
      "alphaMode",
      "camera",
      "KHR_materials_volume",
      "transmission",
      "attributes",
      "toString",
      "clip_",
      "accessors",
      "perspective",
      "clearcoatRoughnessMap",
      "isSpotLight",
      "processScene",
      "values",
      'THREE.GLTFExporter: Could not export animation track "%s".',
      "abs",
      "InterpolantFactoryMethodDiscrete",
      "iridescenceFactor",
      "clearcoatRoughnessFactor",
      "itemSize",
      "result",
      "writer",
      "pbrMetallicRoughness",
      "uuid",
      "uids",
      "readAsArrayBuffer",
      "distance",
      "clone",
      "warn",
      "anisotropyRotation",
      "writeMesh",
      "plugins",
      "propertyIndex",
      "binary",
      "unsigned byte",
      "make light.target a child of the light with position 0,0,-1.",
      "far",
      "clearcoatRoughnessTexture",
      "morphAttributes",
      "cache",
      "422416osoccO",
      "animations",
      "TEXCOORD_1",
      "anisotropy",
      "emissiveIntensity",
      "LINES",
      "attributesNormalized",
      "targetNames",
      "UNSIGNED_BYTE",
      "69630zbHroY",
      "undefined",
      "specularColor",
      "THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.",
      "samplers",
      "thicknessFactor",
      "isSkinnedMesh",
      "THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.",
      "material",
      "materials",
      "wireframe",
      "extensions",
      "decay",
      "specularTexture",
      "isLine",
      "position",
      "propertyName",
      "unsigned short",
      "opacity",
      "includeCustomExtensions",
      "byteOffset",
      "KHR_materials_anisotropy",
      "transmissionFactor",
      "GLTFExporter: THREE.ShaderMaterial not supported.",
      "getY",
      "pending",
      "NEAREST",
      "sheenRoughnessMap",
      "aoMap",
      ":flipY/",
      "tracks",
      "specularFactor",
      "TimeBufferType",
      "3732SYfARz",
      "processMesh",
      "matrix",
      "normalScale",
      "REPEAT",
      "won't be serialized because of JSON.stringify error - ",
      "userData",
      "writeNode",
      "beforeParse",
      "9hcUKbe",
      "metalness",
      "nodeName",
      "toUpperCase",
      "setUint32",
      "VEC3",
      "boneInverses",
      "(((.+)+)+)+$",
      "every",
      "magFilter",
      "setZ",
      "createNormalizedNormalAttribute",
      "setInterpolation",
      "processSampler",
      "KHR_materials_sheen",
      "groups",
      "extensionsRequired",
      "isDirectionalLight",
      "2.0",
      "isPointLight",
      "KHR_materials_ior",
      "color",
      "UNSIGNED_INT",
      "extensionsUsed",
      "source",
      "sheenRoughness",
      "morphTargetDictionary",
      "morphTargetInfluences",
      "sheenColorTexture",
      "start",
      "processNode",
      "getBoneByName",
      "json",
      "nodeMap",
      "serializeUserData",
      "CUBICSPLINE",
      "and expects light.decay=2.",
      "indexOf",
      "UNSIGNED_SHORT",
      "length",
      "bindMatrix",
      "parseAsync",
      "pluginCallbacks",
      "1359352ZqWXQU",
      "THREE.GLTFExporter: userData of '",
      "AuxScene",
    ];
    return (Ff = function () {
      return t;
    })();
  }
  class Bf {
    constructor(t) {
      const e = hf;
      (this[e(168)] = t), (this[e(384)] = "KHR_materials_emissive_strength");
    }
    [hf(387)](t, e) {
      const n = hf;
      if (!t[n(365)] || 1 === t.emissiveIntensity) return;
      const i = this[n(168)].extensionsUsed,
        r = {};
      (r.emissiveStrength = t[n(191)]),
        (e.extensions = e.extensions || {}),
        (e[n(207)][this[n(384)]] = r),
        (i[this[n(384)]] = !0);
    }
  }
  ff.Utils = {
    insertKeyframe: function (t, e) {
      const n = hf,
        i = 0.001,
        r = t[n(500)](),
        s = new t[n(228)](t.times[n(277)] + 1),
        a = new t[n(298)](t[n(571)][n(277)] + r),
        o = t[n(395)](new t[n(298)](r));
      let l;
      if (0 === t[n(309)][n(277)]) {
        s[0] = e;
        for (let t = 0; t < r; t++) a[t] = 0;
        l = 0;
      } else if (e < t[n(309)][0]) {
        if (Math[n(573)](t[n(309)][0] - e) < i) return 0;
        (s[0] = e),
          s.set(t[n(309)], 1),
          a[n(502)](o[n(326)](e), 0),
          a.set(t[n(571)], r),
          (l = 0);
      } else if (e > t[n(309)][t[n(309)][n(277)] - 1]) {
        if (Math[n(573)](t[n(309)][t[n(309)][n(277)] - 1] - e) < i)
          return t[n(309)][n(277)] - 1;
        (s[s[n(277)] - 1] = e),
          s[n(502)](t.times, 0),
          a[n(502)](t[n(571)], 0),
          a[n(502)](o[n(326)](e), t[n(571)][n(277)]),
          (l = s[n(277)] - 1);
      } else
        for (let c = 0; c < t[n(309)].length; c++) {
          if (Math[n(573)](t.times[c] - e) < i) return c;
          if (t[n(309)][c] < e && t[n(309)][c + 1] > e) {
            s[n(502)](t[n(309)][n(367)](0, c + 1), 0),
              (s[c + 1] = e),
              s.set(t.times[n(367)](c + 1), c + 2),
              a[n(502)](t.values[n(367)](0, (c + 1) * r), 0),
              a.set(o[n(326)](e), (c + 1) * r),
              a[n(502)](t[n(571)].slice((c + 1) * r), (c + 2) * r),
              (l = c + 1);
            break;
          }
        }
      return (t[n(309)] = s), (t[n(571)] = a), l;
    },
    mergeMorphTargetTracks: function (t, e) {
      const n = hf,
        i = [],
        r = {},
        s = t[n(226)];
      for (let a = 0; a < s[n(277)]; ++a) {
        let t = s[a];
        const o = ld[n(338)](t[n(384)]),
          l = ld[n(381)](e, o[n(240)]);
        if (o[n(212)] !== n(265) || void 0 === o[n(179)]) {
          i.push(t);
          continue;
        }
        if (
          t[n(395)] !== t[n(163)] &&
          t[n(395)] !== t.InterpolantFactoryMethodLinear
        ) {
          if (t[n(395)].isInterpolantFactoryMethodGLTFCubicSpline)
            throw new Error(n(199));
          console[n(175)](n(290)), (t = t[n(174)]()), t[n(250)](Te);
        }
        const c = l.morphTargetInfluences.length,
          h = l.morphTargetDictionary[o.propertyIndex];
        if (void 0 === h) throw new Error(n(448) + o.propertyIndex);
        let u;
        if (void 0 === r[l.uuid]) {
          u = t[n(174)]();
          const e = new u.ValueBufferType(c * u[n(309)][n(277)]);
          for (let t = 0; t < u[n(309)][n(277)]; t++)
            e[t * c + h] = u[n(571)][t];
          (u[n(384)] = (o[n(240)] || "") + ".morphTargetInfluences"),
            (u[n(571)] = e),
            (r[l.uuid] = u),
            i[n(534)](u);
          continue;
        }
        const d = t[n(395)](new t[n(298)](1));
        u = r[l[n(170)]];
        for (let e = 0; e < u.times[n(277)]; e++)
          u[n(571)][e * c + h] = d[n(326)](u[n(309)][e]);
        for (let e = 0; e < t[n(309)][n(277)]; e++) {
          const i = this.insertKeyframe(u, t[n(309)][e]);
          u.values[i * c + h] = t[n(571)][e];
        }
      }
      return (t[n(226)] = i), t;
    },
  };
  var zf = Wf;
  function kf() {
    var t = [
      "round",
      "190ChEKDY",
      "1058164HwkIoY",
      "top",
      "appendChild",
      "6zyBhTc",
      "770133DOQAWA",
      "fillStyle",
      "Panel",
      "bold ",
      "8agFLUU",
      "1386783yRhWfp",
      "#002",
      "1601594XnscaT",
      "devicePixelRatio",
      "performance",
      "preventDefault",
      "max",
      "min",
      "none",
      "globalAlpha",
      "height",
      "update",
      "now",
      "fillRect",
      "#201",
      "constructor",
      "#0ff",
      "textBaseline",
      "#020",
      "7669837yffipQ",
      "FPS",
      "toString",
      "block",
      "apply",
      "style",
      "canvas",
      "fillText",
      "end",
      "jsHeapSizeLimit",
      "length",
      "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",
      "memory",
      "width",
      "dom",
      "children",
      "(((.+)+)+)+$",
      "font",
      "getContext",
      "#0f0",
      "px Helvetica,Arial,sans-serif",
      "1650285JevApm",
      "search",
      "createElement",
      "139835qIifyN",
    ];
    return (kf = function () {
      return t;
    })();
  }
  !(function (t, e) {
    for (var n = Wf, i = t(); ; )
      try {
        if (
          574553 ===
          -parseInt(n(157)) / 1 +
            -parseInt(n(164)) / 2 +
            parseInt(n(147)) / 3 +
            -parseInt(n(153)) / 4 +
            (-parseInt(n(150)) / 5) * (-parseInt(n(156)) / 6) +
            (-parseInt(n(181)) / 7) * (parseInt(n(161)) / 8) +
            (-parseInt(n(162)) / 9) * (-parseInt(n(152)) / 10)
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(kf);
  var Hf,
    Gf =
      ((Hf = !0),
      function (t, e) {
        var n = Hf
          ? function () {
              if (e) {
                var n = e[Wf(185)](t, arguments);
                return (e = null), n;
              }
            }
          : function () {};
        return (Hf = !1), n;
      }),
    Vf = Gf(globalThis, function () {
      var t = Wf;
      return Vf.toString().search(t(197))[t(183)]()[t(177)](Vf)[t(148)](t(197));
    });
  function Wf(t, e) {
    var n = kf();
    return (Wf = function (t, e) {
      return n[(t -= 145)];
    })(t, e);
  }
  Vf();
  var jf = function () {
    var t = Wf,
      e = 0,
      n = document[t(149)]("div");
    function i(e) {
      var i = t;
      return n[i(155)](e[i(195)]), e;
    }
    function r(i) {
      for (var r = t, s = 0; s < n.children[r(191)]; s++)
        n[r(196)][s][r(186)].display = r(s === i ? 184 : 170);
      e = i;
    }
    (n[t(186)].cssText = t(192)),
      n.addEventListener(
        "click",
        function (i) {
          i[t(167)](), r(++e % n.children.length);
        },
        !1,
      );
    var s = (performance || Date).now(),
      a = s,
      o = 0,
      l = i(new jf[t(159)](t(182), t(178), t(163))),
      c = i(new jf.Panel("MS", t(145), t(180)));
    if (self[t(166)] && self[t(166)].memory)
      var h = i(new jf[t(159)]("MB", "#f08", t(176)));
    return (
      r(0),
      {
        REVISION: 16,
        dom: n,
        addPanel: i,
        showPanel: r,
        begin: function () {
          s = (performance || Date)[t(174)]();
        },
        end: function () {
          var e = t;
          o++;
          var n = (performance || Date)[e(174)]();
          if (
            (c[e(173)](n - s, 200),
            n >= a + 1e3 &&
              (l.update((1e3 * o) / (n - a), 100), (a = n), (o = 0), h))
          ) {
            var i = performance[e(193)];
            h.update(i.usedJSHeapSize / 1048576, i[e(190)] / 1048576);
          }
          return n;
        },
        update: function () {
          s = this[t(189)]();
        },
        domElement: n,
        setMode: r,
      }
    );
  };
  jf[zf(159)] = function (t, e, n) {
    var i = zf,
      r = 1 / 0,
      s = 0,
      a = Math[i(151)],
      o = a(window[i(165)] || 1),
      l = 80 * o,
      c = 48 * o,
      h = 3 * o,
      u = 2 * o,
      d = 3 * o,
      p = 15 * o,
      f = 74 * o,
      m = 30 * o,
      g = document.createElement(i(187));
    (g[i(194)] = l),
      (g[i(172)] = c),
      (g.style.cssText = "width:80px;height:48px");
    var v = g[i(199)]("2d");
    return (
      (v[i(198)] = i(160) + 9 * o + i(146)),
      (v[i(179)] = i(154)),
      (v[i(158)] = n),
      v[i(175)](0, 0, l, c),
      (v[i(158)] = e),
      v[i(188)](t, h, u),
      v[i(175)](d, p, f, m),
      (v[i(158)] = n),
      (v.globalAlpha = 0.9),
      v[i(175)](d, p, f, m),
      {
        dom: g,
        update: function (c, _) {
          var y = i;
          (r = Math[y(169)](r, c)),
            (s = Math[y(168)](s, c)),
            (v[y(158)] = n),
            (v[y(171)] = 1),
            v[y(175)](0, 0, l, p),
            (v.fillStyle = e),
            v[y(188)](a(c) + " " + t + " (" + a(r) + "-" + a(s) + ")", h, u),
            v.drawImage(g, d + o, p, f - o, m, d, p, f - o, m),
            v[y(175)](d + f - o, p, o, m),
            (v[y(158)] = n),
            (v.globalAlpha = 0.9),
            v[y(175)](d + f - o, p, o, a((1 - c / _) * m));
        },
      }
    );
  };
  const Xf = qf;
  function qf(t, e) {
    const n = Zf();
    return (qf = function (t, e) {
      return n[(t -= 188)];
    })(t, e);
  }
  !(function (t, e) {
    const n = qf,
      i = t();
    for (;;)
      try {
        if (
          897278 ===
          (-parseInt(n(251)) / 1) * (-parseInt(n(405)) / 2) +
            -parseInt(n(340)) / 3 +
            (-parseInt(n(259)) / 4) * (-parseInt(n(476)) / 5) +
            (parseInt(n(328)) / 6) * (parseInt(n(424)) / 7) +
            -parseInt(n(430)) / 8 +
            (-parseInt(n(336)) / 9) * (-parseInt(n(324)) / 10) +
            -parseInt(n(226)) / 11
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(Zf);
  const Yf = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n[qf(188)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    Kf = Yf(globalThis, function () {
      const t = qf;
      return Kf.toString()
        [t(189)](t(313))
        .toString()
        .constructor(Kf)
        .search("(((.+)+)+)+$");
    });
  function Zf() {
    const t = [
      "getCenter",
      "parseAsync",
      "shadow_light",
      "InterpolateLinear",
      "featArr",
      "eyeWideLeft",
      "eyeLookDownRight",
      "specularMap",
      "none",
      "remove",
      "requestAnimationFrame",
      "array",
      "jawLeft",
      "mouthRollUpper",
      "name",
      "actionArr",
      "cheekSquintRight",
      "eyeLookOutLeft",
      "appendChild",
      "actionEnd",
      "keys",
      "mixer",
      "setTimeout",
      "quaternion",
      "texture",
      "eventMap",
      "pushTTSData",
      "start",
      "isArray",
      "isInteger",
      "assign",
      "Vector3",
      "modelOption",
      "maxDistance",
      "updateProjectionMatrix",
      "width",
      "dom",
      "LinearToneMapping",
      "over",
      "get glb error:",
      "initTTSFace",
      "addEventListener",
      "DirectionalLight",
      "AnimationMixer",
      "values",
      "toneMappingExposure",
      "type",
      "setLoop",
      "mouthSmileLeft",
      "noseSneerLeft",
      "eyeBlinkRight",
      "showShadow",
      "KeyframeTrack",
      "actionLoad",
      "random",
      "17466UlwNYi",
      "children",
      "isMesh",
      "_actions",
      "glb2json",
      "loadAsync",
      "eyePlay",
      "number",
      "_clip",
      "visibility",
      "eyeSquintLeft",
      "setFromObject",
      "Mesh",
      "DoubleSide",
      "cheekPuff",
      "eyeWideRight",
      "isStart",
      "center",
      "==idx==",
      "210HMIJKH",
      "findIndex",
      "cheekSquintLeft",
      "visible",
      "TextureLoader",
      "eyeObj",
      "1779408SdORnZ",
      "error",
      "outputColorSpace",
      "mainLightColor",
      "eyeBlinkLeft",
      "setPixelRatio",
      "resetMorphObj",
      "prase mode error:",
      "skinMap",
      "mouthPressLeft",
      "eyeArr",
      "application/octet-stream",
      "QuaternionKeyframeTrack",
      "eyeLookDownLeft",
      "mouthStretchLeft",
      "finished",
      "material",
      "add",
      "mouthDimpleRight",
      "action",
      "WebGLRenderer",
      "mouthPucker",
      "ShadowMaterial",
      "castShadow",
      "stats",
      "style",
      "mouthClose",
      "jawForward",
      "data",
      "mixerArr",
      "showStats",
      "faceKeyArr",
      "push",
      "maxPolarAngle",
      "framePlay",
      "find",
      "dispose",
      "controls",
      "stopTTSPlay",
      "PCFSoftShadowMap",
      "curSeqNo",
      "forEach",
      "isRaf",
      "stopAllAction",
      "setPolarAngle",
      "toJSON",
      "1165NKTMjY",
      "mouthFrownLeft",
      "seqNoArr",
      "getSize",
      "num",
      "delimiter",
      "position",
      "browInnerUp",
      "apply",
      "search",
      "enablePan",
      "皮肤的节点无效",
      "camera",
      "frameStart",
      "3003",
      "traverse",
      "mouthRollLower",
      "playAction",
      "getError",
      "SkinnedMesh",
      "getGlbBlob",
      "originVal",
      "isExistAction",
      "unshift",
      "fov",
      "setSize",
      "extraBS",
      "PerspectiveCamera",
      "dictionary",
      "ambientLightIntensity",
      "bsTrackMap",
      "lightMap",
      "browOuterUpLeft",
      "getObjectByName",
      "val",
      "jawOpen",
      "block",
      "LoopOnce",
      "getDistance",
      "clock",
      "main_light",
      "status",
      "reskinEnd",
      "modelInit",
      "indexOf",
      "3004",
      "11288926nNJqbt",
      "vector",
      "sign",
      "receiveShadow",
      "AmbientLight",
      "resetDistance",
      "height",
      "clipAction",
      "documentElement",
      "crossFadeTo",
      "renderFrame",
      "morphTargetInfluences",
      "jawRight",
      "every",
      "render",
      "max",
      "update",
      "皮肤的纹理缺失",
      "getSkinData",
      "featDim",
      "mouthLowerDownRight",
      "concat",
      "screenshot",
      "defaultActionName",
      "all",
      "7JGtFCT",
      "eyeLookUpRight",
      "destory",
      "ignoreArr",
      "stop",
      "some",
      "background",
      "parse",
      "1376SvqneN",
      "actionData",
      "split",
      "clockArr",
      "mouthLowerDownLeft",
      "mouthShrugUpper",
      "morphObj",
      "filter",
      "Box3",
      "encoding",
      "location",
      "normalMap",
      "3002",
      "shadow",
      "VectorKeyframeTrack",
      "minPolarAngle",
      "shadowMap",
      "updateMatrixWorld",
      "envMap",
      "loadAnimation",
      "length",
      "skeleton",
      "map",
      "Color",
      "animations",
      "mapSize",
      "sentenceObj",
      "bumpMap",
      "resetPositionInfo",
      "eyeLookInLeft",
      "getDelta",
      "getBSData",
      "side",
      "getBoundingClientRect",
      "uncacheAction",
      "mouthFrownRight",
      "componentObj",
      "set",
      "InterpolateSmooth",
      "scene",
      "isShowStats",
      "curKey",
      "floor",
      "Clock",
      "3001",
      "times",
      "devicePixelRatio",
      "duration",
      "interval",
      "mouthLeft",
      "url",
      "display",
      "rootElt",
      "target",
      "(((.+)+)+)+$",
      "has",
      "pos",
      "object",
      "now",
      "renderer",
      "curAnimation",
      "isLoaded",
      "#ffffff",
      "far",
      "AnimationClip",
      "9050gTqxss",
      "distance",
      "mouthUpperUpRight",
      "hidden",
      "291432SLapEv",
      "mouthSmileRight",
      "eyeLookOutRight",
      "faceIdxArr",
      "get",
      "scenes",
      "sentence",
      "modelObj",
      "17469FpBHRP",
      "pow",
      "enabled",
      "innerHTML",
      "3627234dUrNNf",
      "getMorphTarget",
      "near",
      "featLenArr",
      "morphTargetDictionary",
      "noseSneerRight",
      "PlaneGeometry",
      "mode",
      "polarAngle",
      "domElement",
    ];
    return (Zf = function () {
      return t;
    })();
  }
  Kf();
  class Jf {
    constructor(t) {
      const e = qf;
      (this[e(298)] = null),
        (this.camera = null),
        (this[e(318)] = null),
        (this.controls = null),
        (this[e(219)] = new Bd[e(302)]()),
        (this[e(371)] = null),
        (this[e(335)] = null),
        (this[e(311)] = null),
        (this.eventMap = new Map()),
        (this[e(454)] = null),
        (this.isShowStats = !1),
        (this.faceKeyArr = [
          e(246),
          e(196),
          e(366),
          "mouthStretchRight",
          e(398),
          e(448),
          e(345),
          e(215),
          e(451),
          "mouthFunnel",
          e(444),
          e(426),
          "mouthPressRight",
          "mouthDimpleLeft",
          e(419),
          e(456),
          e(439),
          e(238),
          "mouthUpperUpLeft",
          e(263),
          e(308),
          e(264),
          e(477),
          e(294),
          "mouthRight",
          e(399),
          "mouthShrugLower",
          e(326),
          e(363),
          e(457),
          e(362),
          e(329),
          "eyeSquintRight",
          "browOuterUpRight",
          e(252),
          e(420),
          e(443),
          e(483),
          e(330),
          "browDownLeft",
          "eyeLookUpLeft",
          "browDownRight",
          e(434),
          e(288),
          e(367),
          e(415),
          "tongueOut",
          e(400),
          e(212),
          e(356),
          e(355),
          "eyeLookInRight",
        ]),
        (this[e(331)] = []),
        (this.featDim = 0),
        (this[e(354)] = []),
        (this[e(285)] = {
          featLenArr: [],
          seqNoArr: [],
          curSeqNo: -1,
          status: "",
        }),
        (this[e(365)] = []),
        (this[e(193)] = 0),
        (this.curAnimation = {
          action: null,
          name: "",
          frameStart: 0,
          ignoreArr: [],
        }),
        (this.eyeObj = null),
        (this[e(438)] = null),
        (this.morphObj = null),
        (this.delimiter = e(423)),
        (this[e(210)] = {}),
        (this[e(382)] = {
          exposure: 0.3,
          ambientLightColor: e(321),
          ambientLightIntensity: 1.5,
          mainLightColor: e(321),
          mainLightIntensity: 1.3,
          fov: 27,
          mode: [],
          position: null,
          polarAngle: 90,
          resetDistance: 0,
          showShadow: null,
        }),
        (this.isRaf = !0),
        (this[e(295)] = { curKey: "", map: {} }),
        (this[e(422)] = null),
        (this.skinMap = t[e(438)]),
        t[e(382)] &&
          ((this[e(382)] = Object[e(380)](this[e(382)], t[e(382)])),
          (this[e(382)][e(204)] < 5 || this.modelOption[e(204)] > 85) &&
            (this[e(382)][e(204)] = 27));
    }
    [Xf(236)]() {
      const t = Xf;
      if (this.isRaf) {
        if (
          (this[t(371)] && this[t(371)].update(this.clock[t(289)]()),
          this.componentObj[t(300)])
        ) {
          const e = this[t(295)][t(300)];
          this[t(295)].map[e][t(459)][t(471)]((n, i) => {
            const r = t;
            n[r(242)](this[r(295)][r(281)][e][r(262)][i][r(289)]());
          });
        }
        if (
          (this.renderer[t(240)](this[t(298)], this[t(192)]),
          this[t(464)](),
          this[t(319)][t(193)] > 0 &&
            Object[t(370)](this[t(210)])[t(224)](this[t(319)].name) > -1)
        ) {
          const e = this[t(210)][this.curAnimation[t(364)]][t(458)][0],
            n = e.name[t(261)](".")[0];
          if (
            this[t(265)][t(206)][n] &&
            Object[t(370)](this.morphObj[t(206)][n])[t(279)]
          ) {
            const i = e[t(304)].findIndex((e) => {
              const n = t;
              return Date.now() - this[n(319)][n(193)] < 1e3 * e;
            });
            if (i > -1) {
              const r = Math[t(301)](e[t(394)][t(279)] / e.times.length),
                s = this[t(265)][t(206)][n];
              s &&
                Object[t(370)](s).forEach((a) => {
                  const o = t,
                    l = +s[a];
                  this[o(265)][o(208)][n][o(237)][l] = e[o(394)][i * r + l];
                });
            }
          }
        }
        this[t(299)] && this[t(454)][t(242)](),
          window[t(360)](() => {
            this[t(236)]();
          });
      }
    }
    [Xf(278)](t, e) {
      const n = Xf;
      let { defaultActionIdx: i, isNew: r, actionData: s } = e;
      const a = [];
      return (
        Array.isArray(s) &&
          s[n(279)] &&
          (null == i && (i = 0),
          s[n(471)]((e, s) => {
            const o = n,
              l = r && s === i ? m.defaultActionName : e[o(364)],
              c = e[o(458)][o(361)]
                [o(266)]((t) => {
                  const e = o;
                  return (
                    t[e(396)] !== e(412) ||
                    (!this[e(210)][l] && (this[e(210)][l] = { data: [] }),
                    this[e(265)][e(208)] &&
                      !this.morphObj.dictionary[t[e(364)][e(261)](".")[0]] &&
                      this[e(375)][e(314)]("error") &&
                      this[e(375)].get("error")({
                        code: 3004,
                        message: m[e(198)](e(225)) + ": " + l,
                      }),
                    this[e(210)][l].data[e(462)](t),
                    !1)
                  );
                })
                [o(281)]((t) => {
                  const e = o;
                  return t[e(396)] === e(227)
                    ? new Bd[e(273)](t.name, t[e(304)], t[e(394)], Bd[e(297)])
                    : t[e(396)] === e(373)
                    ? new Bd[e(442)](t[e(364)], t[e(304)], t.values, Bd[e(353)])
                    : new Bd[e(402)](
                        t[e(364)],
                        t[e(304)],
                        t[e(394)],
                        Bd[e(297)],
                      );
                }),
              h = new eu(l, -1, c);
            l === m[o(249)] ? t.animations[o(203)](h) : t[o(283)][o(462)](h),
              a.push(l);
          })),
        a
      );
    }
    [Xf(341)](t, e = null) {
      const n = Xf;
      return (
        null === e && (e = { dictionary: {}, eyeArr: [] }),
        t[n(406)] &&
          t[n(406)].forEach((t) => {
            const i = n;
            if (t[i(344)] && t.morphTargetInfluences) {
              const n = {};
              Object[i(370)](t.morphTargetDictionary)[i(471)]((e) => {
                const r = i,
                  s = e[r(261)](".");
                n[s[r(279)] > 1 ? s[1] : s[0]] = t[r(344)][e];
              }),
                (e.dictionary[t.name] = {
                  morphTargetDictionary: n,
                  morphTargetInfluences: t[i(237)],
                  originVal: t[i(237)][i(281)]((t) => t),
                });
            } else t[i(406)] && t[i(406)][i(279)] && (e = this[i(341)](t, e));
          }),
        e
      );
    }
    [Xf(390)](t) {
      const e = Xf;
      if (((this[e(265)] = this.getMorphTarget(t)), this[e(265)])) {
        this.morphObj[e(206)] = {};
        let t = Object[e(370)](this[e(265)][e(208)]);
        const n = {};
        t[e(471)]((t) => {
          const i = e;
          let r = Object[i(370)](this.morphObj[i(208)][t][i(344)]);
          r[i(471)]((e) => {
            const r = i;
            n[e] ? delete this[r(265)][r(208)][t][r(344)][e] : (n[e] = 1);
          }),
            (r = Object[i(370)](this.morphObj.dictionary[t][i(344)])),
            !r[i(279)] && delete this[i(265)][i(208)][t];
        }),
          (t = Object[e(370)](this.morphObj[e(208)])),
          this[e(461)][e(471)]((n, i) => {
            const r = e;
            t[r(471)]((t) => {
              const e = r;
              !this[e(265)][e(206)][t] &&
                (this[e(265)].extraBS[t] = l(
                  {},
                  this[e(265)][e(208)][t].morphTargetDictionary,
                ));
              Object[e(370)](this.morphObj[e(208)][t][e(344)])[e(471)]((r) => {
                const s = e,
                  a = this.morphObj[s(208)][t].morphTargetDictionary[r];
                r == n &&
                  ((this[s(331)][i] = "" + t + this.delimiter + a),
                  [s(400), "eyeBlinkLeft"].indexOf(n) > -1 &&
                    this[s(265)].eyeArr[s(462)]("" + t + this.delimiter + a),
                  delete this.morphObj[s(206)][t][r]);
              });
            });
          });
      }
      this.eyeObj = {
        val: 0,
        sign: 1,
        ts: Date[e(317)](),
        interval: 4e3 + 2e3 * Math[e(404)](),
        num: 0.086,
        isStart: !1,
      };
    }
    [Xf(464)](t = !1) {
      var e;
      const n = Xf;
      if (t)
        return (
          this[n(285)][n(343)][n(279)] &&
            this[n(375)][n(314)](n(334)) &&
            "over" !== this[n(285)][n(221)] &&
            this[n(375)][n(332)]("sentence")({
              code: 0,
              data: { seqNo: this[n(285)][n(470)], status: n(388) },
            }),
          (this.frameStart = 0),
          (this[n(354)] = []),
          (this[n(365)] = []),
          (this.sentenceObj = {
            featLenArr: [],
            seqNoArr: [],
            curSeqNo: -1,
            status: "",
          }),
          this[n(436)](),
          void this[n(197)]()
        );
      const i = this.featDim > 0 ? this[n(245)] : this[n(461)][n(279)];
      if (
        this[n(365)][n(279)] &&
        Date[n(317)]() - this.frameStart >= this.actionArr[0].start / 1e4
      ) {
        const t = this[n(365)].shift()[n(315)];
        this.playAction(t);
      }
      const r = this[n(354)].length / i,
        s = Math.floor((Date.now() - this.frameStart) / 40),
        a = s < r;
      if (this[n(375)].has(n(334)))
        if (a) {
          this[n(285)][n(470)] > 0 &&
            this[n(285)][n(221)] !== n(377) &&
            (this.eventMap[n(332)]("sentence")({
              code: 0,
              data: { seqNo: this[n(285)][n(470)], status: "start" },
            }),
            (this[n(285)].status = n(377)));
          const t = this[n(285)].featLenArr[n(425)](
            (t) => t > s * this[n(245)],
          );
          t > -1 &&
            this.sentenceObj[n(470)] !== this[n(285)][n(478)][t] &&
            (this.sentenceObj[n(221)] === n(377) &&
              this[n(375)].get(n(334))({
                code: 0,
                data: { seqNo: this[n(285)][n(470)], status: n(388) },
              }),
            (this[n(285)].status = n(388)),
            (this[n(285)][n(470)] = this[n(285)][n(478)][t]));
        } else
          this[n(285)][n(221)] === n(377) &&
            this[n(375)][n(332)](n(334))({
              code: 0,
              data: { seqNo: this[n(285)].curSeqNo, status: n(388) },
            }),
            (this[n(285)][n(221)] = "over");
      for (let o = 0; o < this[n(461)][n(279)]; o++)
        if (this[n(331)][o]) {
          let [t, r] = this[n(331)][o][n(261)](this.delimiter);
          r = +r;
          let l = this.morphObj[n(208)][t][n(201)][r];
          const c = this[n(265)][n(208)][t].morphTargetInfluences[n(279)];
          if (this.curAnimation.frameStart > 0) {
            const i =
              null == (e = this[n(210)][this[n(319)][n(364)]])
                ? void 0
                : e[n(458)];
            i &&
              i.forEach((e) => {
                const i = n,
                  s = e[i(364)][i(261)](".");
                if (t === s[0]) {
                  const t = e[i(304)][i(425)]((t) => {
                    const e = i;
                    return Date.now() - this[e(319)].frameStart < 1e3 * t;
                  });
                  t > -1 && (l += e.values[t * c + r]);
                }
              });
          }
          a && o < i && (l = Math[n(241)](l, this[n(354)][s * i + o])),
            l > 1 && (l = 1),
            (this.morphObj[n(208)][t][n(237)][r] = l);
        }
      r > 0 &&
        s >= r &&
        ((this.featArr = []),
        (this.actionArr = []),
        (this[n(285)] = {
          featLenArr: [],
          seqNoArr: [],
          curSeqNo: -1,
          status: "",
        }));
    }
    [Xf(436)]() {
      const t = Xf;
      this.faceIdxArr[t(471)]((e) => {
        const n = t;
        let [i, r] = e.split(this[n(481)]);
        (r = +r),
          (this[n(265)][n(208)][i][n(237)][r] =
            this[n(265)].dictionary[i].originVal[r]);
      });
    }
    [Xf(411)]() {
      const t = Xf;
      !Array.isArray(this[t(265)][t(440)]) ||
        this.curAnimation[t(193)] > 0 ||
        (Date[t(317)]() - this.eyeObj.ts >= this[t(429)][t(307)] &&
          (this[t(429)].isStart = !0),
        this[t(429)].isStart &&
          ((this.eyeObj.val += this[t(429)][t(480)] * this[t(429)].sign),
          this[t(265)][t(440)].forEach((e) => {
            const n = t,
              [i, r] = e[n(261)](this[n(481)]);
            this[n(265)][n(208)][i][n(237)][r] = this[n(429)].val;
          }),
          this[t(429)][t(214)] >= 1 && (this[t(429)][t(228)] = -1),
          this[t(429)][t(214)] <= 0 &&
            ((this.eyeObj[t(421)] = !1),
            (this.eyeObj[t(228)] = 1),
            (this[t(429)][t(214)] = 0),
            (this[t(429)][t(307)] = 4e3 + 2e3 * Math[t(404)]()),
            (this[t(429)].ts = Date[t(317)]()))));
    }
    getSkinData(t) {
      return c(this, null, function* () {
        const e = Xf;
        if (!this.skinMap) return null;
        try {
          const n = new Bd[e(428)]();
          if (null == t) {
            const t = Object[e(370)](this[e(438)]);
            for (let i = 0; i < t[e(279)]; i++) {
              const r = this.skinMap[t[i]];
              (yield Promise[e(250)](
                r[e(458)][e(281)]((t) => n[e(410)]("" + t[e(309)])),
              ))[e(471)]((t, n) => {
                const i = e;
                r[i(458)][n][i(374)] = t;
              }),
                (r[e(320)] = !0);
            }
            return (
              this[e(438)][""]
                ? this.reskin("")
                : ((this.skinMap[""] = { isLoaded: !0, data: [] }),
                  this[e(438)][t[0]][e(458)][e(471)]((t) => {
                    const n = e,
                      i = this.modelObj[n(213)](t[n(364)]);
                    if (null == i ? void 0 : i[n(446)]) {
                      let e;
                      (e = Array[n(378)](i[n(446)])
                        ? i.material[0][n(281)]
                        : i[n(446)][n(281)]),
                        this[n(438)][""][n(458)][n(462)]({
                          name: t.name,
                          texture: e,
                        });
                    }
                  })),
              null
            );
          }
          {
            const i = this.skinMap[t];
            if (i) {
              if (!i[e(320)]) {
                (yield Promise.all(
                  i[e(458)][e(281)]((t) => n[e(410)]("" + t[e(309)])),
                ))[e(471)]((t, n) => {
                  const r = e;
                  i[r(458)][n][r(374)] = t;
                }),
                  (i[e(320)] = !0);
              }
              return i[e(458)].map((t) => {
                const n = e;
                return { name: t[n(364)], texture: t[n(374)] };
              });
            }
            return null;
          }
        } catch (n) {
          return (
            this[e(375)][e(314)](e(431)) &&
            this.eventMap[e(332)](e(431))({
              code: 3003,
              message: m[e(198)](e(194)),
            })
          );
        }
      });
    }
    on(t, e) {
      const n = Xf;
      switch (t) {
        case n(223):
        case "actionLoad":
        case n(369):
        case n(222):
        case n(334):
        case n(431):
          this[n(375)][n(296)](t, e);
      }
    }
    modelInit(t) {
      return c(this, null, function* () {
        const e = Xf,
          {
            rootElt: n,
            modelData: i,
            actionData: r,
            defaultActionIdx: s,
            openingActionIdx: a,
          } = t;
        (this[e(311)] = n),
          (this[e(311)][e(455)][e(414)] = e(327)),
          (this[e(311)][e(339)] = "");
        const o = this[e(311)][e(292)]();
        if (0 === o[e(385)] || 0 === o.height)
          return (
            this[e(375)][e(314)]("error") &&
            this[e(375)].get(e(431))({ code: 3001, message: m[e(198)](e(303)) })
          );
        (this[e(298)] = new jo()),
          (this[e(298)].environment = null),
          (this[e(298)][e(257)] = null),
          (this.camera = new Bd[e(207)](
            this.modelOption.fov,
            o[e(385)] / o[e(232)],
            0.01,
            1e3,
          )),
          this[e(298)].add(this[e(192)]),
          (this[e(318)] = new Bd[e(450)]({
            antialias: !0,
            alpha: !0,
            preserveDrawingBuffer: !!(
              Array.isArray(this[e(382)][e(347)]) &&
              this[e(382)][e(347)][e(224)](e(248)) > -1
            ),
          })),
          this[e(318)][e(205)](o[e(385)], o[e(232)]),
          this.renderer[e(435)](window[e(305)]),
          (this[e(318)][e(275)][e(338)] = !0),
          (this[e(318)].shadowMap[e(396)] = Bd[e(469)]),
          this[e(311)][e(368)](this[e(318)][e(349)]),
          (this.renderer.toneMapping = Bd[e(387)]),
          (this[e(318)][e(395)] = Math[e(337)](2, +this[e(382)].exposure)),
          (this.renderer[e(432)] = Ne);
        const l = new Bd[e(230)](
          new Bd[e(282)](this[e(382)].ambientLightColor),
          +this[e(382)][e(209)],
        );
        (l.name = "ambient_light"), this[e(192)][e(447)](l);
        const c = new Bd[e(392)](
          new tr(this[e(382)][e(433)]),
          +this[e(382)].mainLightIntensity,
        );
        c.position[e(296)](0.5, 0, 0.866),
          (c.name = e(220)),
          this[e(192)].add(c),
          (this[e(467)] = new Zd(this[e(192)], this[e(318)].domElement)),
          this.controls.target[e(296)](0, 0, 0),
          (this.controls[e(190)] = !!(
            Array.isArray(this[e(382)][e(347)]) &&
            this[e(382)][e(347)][e(224)](e(482)) > -1
          ));
        let h = this[e(382)][e(348)];
        (h < 0 || h > 180) && (h = 90),
          (this.controls[e(274)] = (Math.PI / 180) * h),
          (this.controls[e(463)] = (Math.PI / 180) * h);
        const u = new ap();
        try {
          const t = yield u.parseAsync(i);
          this.modelObj = t[e(298)] || t[e(333)][0];
        } catch (v) {
          console.error(e(437), v), (this[e(335)] = null);
        }
        if (!this.modelObj)
          return (
            this[e(375)][e(314)](e(431)) &&
            this.eventMap[e(332)](e(431))({
              code: 3002,
              message: m.getError(e(271)),
            })
          );
        this.modelObj[e(276)]();
        const d = new Bd[e(267)]()[e(416)](this.modelObj),
          p = d[e(479)](new Nn())[e(279)]();
        (this[e(422)] = d[e(350)](new Bd[e(381)]())),
          (this[e(335)].position.x += this.modelObj[e(482)].x - this.center.x),
          (this[e(335)][e(482)].y += this[e(335)][e(482)].y - this[e(422)].y),
          (this.modelObj[e(482)].z += this.modelObj[e(482)].z - this[e(422)].z),
          (this[e(192)][e(342)] = p / 100),
          (this.camera[e(322)] = 100 * p),
          this.camera[e(384)]();
        let f = 27 / this[e(382)][e(204)];
        if (
          Array[e(378)](this.modelOption[e(347)]) &&
          this[e(382)][e(347)][e(224)](e(482)) > -1
        )
          this[e(467)][e(316)].position.z = 2.5 * p * f;
        else {
          const t = 2.5 * p * f;
          (this[e(467)][e(383)] = t),
            (this[e(467)].minDistance = t),
            (this[e(382)][e(231)] = t);
        }
        if (
          (this[e(467)][e(242)](),
          this[e(467)].saveState(),
          this[e(382)].showShadow)
        ) {
          const t = this.modelOption[e(401)],
            n = new Bd[e(392)](new Bd[e(282)]("#ffffff"), 1);
          Array[e(378)](t[e(482)]) &&
          t[e(482)][e(239)]((t) => typeof t === e(412))
            ? n[e(482)][e(296)](t[e(482)][0], t[e(482)][1], t[e(482)][2])
            : n[e(482)][e(296)](0, 1.5, 0),
            (n[e(364)] = e(352)),
            (n[e(453)] = !0),
            (n[e(272)][e(284)].width = Number[e(379)](t[e(385)])
              ? t[e(385)]
              : 512),
            (n[e(272)].mapSize[e(232)] = Number.isInteger(t.height)
              ? t[e(385)]
              : 512),
            (n[e(272)][e(192)].near = 0.5),
            (n[e(272)][e(192)][e(322)] = 100),
            t[e(269)] == e(192)
              ? this[e(192)][e(447)](n)
              : this[e(298)][e(447)](n);
          const i = new Bd[e(417)](
            new Bd[e(346)](100, 100),
            new Bd[e(452)]({ opacity: 0.5 }),
          );
          (i.rotation.x = -Math.PI / 2),
            (i[e(229)] = !0),
            (i[e(482)].y = (46 * -p) / 100),
            this.scene[e(447)](i);
        }
        if (this[e(382)][e(482)]) {
          const t = this[e(382)][e(482)];
          this[e(467)] &&
            ((this[e(467)][e(316)][e(482)].x = t.x),
            (this[e(467)][e(316)][e(482)].y = t.y),
            (this[e(467)][e(316)][e(482)].z = t.z),
            (this.controls[e(312)].x = t[e(312)].x),
            (this[e(467)][e(312)].y = t[e(312)].y),
            (this[e(467)].target.z = t[e(312)].z),
            (!Array[e(378)](this[e(382)][e(347)]) ||
              -1 === this[e(382)][e(347)][e(224)]("position")) &&
              ((this.controls[e(383)] = t[e(325)]),
              (this[e(467)].minDistance = t[e(325)])),
            this[e(467)][e(242)]());
        }
        this[e(390)](this.modelObj);
        const g = this.loadAnimation(this[e(335)], {
          isNew: !0,
          actionData: r,
          defaultActionIdx: s,
        });
        this.eventMap[e(314)]("actionLoad") &&
          this[e(375)][e(332)](e(403))({ code: 0, actionArray: g }),
          this[e(244)](null),
          (this.mixer = new ud(this[e(335)])),
          this.mixer[e(391)](e(445), (t) => {
            const n = e,
              i = t[n(449)][n(413)].name;
            let r = [];
            if ((t[n(449)][n(255)](), this.componentObj[n(281)][i])) {
              this[n(295)].curKey = "";
              const {
                modelObjArr: t,
                mixerArr: e,
                clockArr: r,
              } = this[n(295)][n(281)][i];
              t[n(471)]((t, i) => {
                const s = n;
                e[i][s(233)](t[s(283)][0]).stop(), (r[i] = new Wu());
              });
            }
            this[n(319)].name === i &&
              ((r = this.curAnimation[n(254)]),
              Object[n(380)](this.curAnimation, {
                name: "",
                frameStart: 0,
                ignoreArr: [],
              })),
              i !== m[n(249)] &&
                this.eventMap.has(n(369)) &&
                this[n(375)][n(332)](n(369))({
                  code: 0,
                  action: i,
                  ignoreArr: r,
                }),
              this.playAction();
          }),
          this[e(335)][e(195)]((t) => {
            const n = e;
            t[n(407)] &&
              (this[n(382)].showShadow &&
                ((t.castShadow = !0), (t[n(229)] = !0)),
              Array[n(378)](t.material)
                ? t.material[n(471)]((t) => {
                    const e = n;
                    t[e(291)] = Bd[e(418)];
                  })
                : (t[n(446)][n(291)] = Bd[n(418)]));
          }),
          this.scene[e(447)](this.modelObj),
          this[e(236)](),
          this[e(375)].has(e(223)) &&
            this[e(375)][e(332)]("modelInit")({ code: 0 }),
          window[e(372)](() => {
            const t = e;
            this[t(311)][t(455)].visibility = t(427);
            let n = "";
            null != a && a != s && g[a] && (n = g[a]), this[t(197)](n);
          }, 50);
      });
    }
    [Xf(403)](t) {
      const e = Xf;
      if (this[e(335)]) {
        const n = this[e(278)](this.modelObj, t);
        this[e(375)][e(314)](e(403)) &&
          this[e(375)][e(332)](e(403))({ code: 0, actionArray: n });
      } else this[e(375)][e(314)](e(431)) && this[e(375)][e(332)]("error")({ code: 3002, message: m.getError(e(271)) });
    }
    componentLoad(t) {
      return c(this, null, function* () {
        const e = Xf;
        if (this[e(335)]) {
          const n = new ap(),
            i = Object[e(370)](t);
          for (let r = 0; r < i[e(279)]; r++) {
            const s = t[i[r]][e(260)],
              a = t[i[r]][e(281)];
            this.actionLoad({
              defaultActionIdx: -1,
              isNew: !1,
              actionData: [{ name: i[r], data: s }],
            }),
              (this.componentObj[e(281)][i[r]] = {
                modelObjArr: [],
                mixerArr: [],
                clockArr: [],
              });
            const o = Object.keys(a);
            for (let t = 0; t < o.length; t++) {
              const { modelData: s, actionData: l } = a[o[t]],
                c = yield n[e(351)](s),
                h = c[e(298)] || c[e(333)][0];
              h.traverse((t) => {
                const n = e;
                t.isMesh &&
                  this[n(382)].showShadow &&
                  ((t[n(453)] = !0), (t[n(229)] = !0));
              }),
                this.scene[e(447)](h),
                (h.position.x += h[e(482)].x - this[e(422)].x),
                (h[e(482)].y += h[e(482)].y - this.center.y),
                (h[e(482)].z += h[e(482)].z - this.center.z);
              const u = l[e(361)][e(281)]((t) => {
                  const n = e;
                  return t[n(396)] === n(227)
                    ? new Bd[n(273)](
                        t[n(364)],
                        t[n(304)],
                        t[n(394)],
                        Bd[n(297)],
                      )
                    : t.type === n(373)
                    ? new $h(t[n(364)], t[n(304)], t[n(394)], Bd[n(353)])
                    : new Bd[n(402)](t[n(364)], t.times, t[n(394)], Bd[n(297)]);
                }),
                d = new ud(h);
              h.animations[e(462)](new Bd[e(323)](o[t], -1, u));
              const {
                modelObjArr: p,
                mixerArr: f,
                clockArr: m,
              } = this[e(295)].map[i[r]];
              p[e(462)](h), f[e(462)](d), m[e(462)](new Bd[e(302)]());
            }
          }
        } else this.eventMap[e(314)](e(431)) && this[e(375)][e(332)](e(431))({ code: 3002, message: m[e(198)](e(271)) });
      });
    }
    [Xf(460)](t) {
      const e = Xf;
      !this[e(454)] &&
        ((this[e(454)] = new jf()),
        document[e(234)].appendChild(this[e(454)][e(386)])),
        (this[e(454)][e(386)][e(455)][e(310)] = e(t ? 216 : 358)),
        (this[e(299)] = t);
    }
    playAction(t = "") {
      const e = Xf;
      let n = null;
      if (t && t !== m[e(249)]) {
        const i = this[e(335)].animations[e(465)]((n) => n[e(364)] === t);
        i && (n = this[e(371)].clipAction(i));
      }
      if (n)
        this[e(319)][e(364)] &&
          this[e(319)][e(364)] !== m[e(249)] &&
          (this[e(319)][e(254)][e(462)](n[e(413)][e(364)]), (n = null));
      else {
        const t = this[e(335)][e(283)].find((t) => {
          const n = e;
          return t[n(364)] === m[n(249)];
        });
        t
          ? !this.curAnimation[e(364)] && (n = this.mixer[e(233)](t))
          : this[e(436)]();
      }
      if (
        n &&
        ((n[e(338)] = !0),
        n[e(397)](Se),
        (n.clampWhenFinished = !0),
        this[e(319)][e(449)] && this[e(319)][e(449)][e(235)](n, 0.3, !1),
        n.play(),
        (this[e(319)] = {
          action: n,
          name: n[e(413)][e(364)],
          frameStart: Date[e(317)](),
          ignoreArr: [],
        }),
        this[e(295)].map[t])
      ) {
        this.componentObj[e(300)] = t;
        const { modelObjArr: n, mixerArr: i } = this[e(295)].map[t];
        n[e(471)]((t, n) => {
          const r = e,
            s = i[n].clipAction(t[r(283)][0]);
          (s[r(338)] = !0), s.setLoop(Bd[r(217)]), s.play();
        });
      }
    }
    [Xf(376)](t) {
      const e = Xf,
        { featArr: n, actionArr: i, featDim: r, featFinal: s, seqNo: a } = t;
      0 === this[e(354)].length && (this[e(193)] = Date[e(317)]()),
        r && (this[e(245)] = r),
        (this.featArr = this.featArr[e(247)](n)),
        (this.actionArr = this[e(365)][e(247)](i)),
        1 === a && -1 === this[e(285)].curSeqNo && (this[e(285)].curSeqNo = a),
        s &&
          (this[e(285)][e(343)][e(462)](this[e(354)].length),
          this[e(285)].seqNoArr[e(462)](a));
    }
    [Xf(468)]() {
      this[Xf(464)](!0);
    }
    reskin(t) {
      return c(this, null, function* () {
        const e = Xf,
          n = t;
        if (this[e(335)]) {
          const t = yield this[e(244)](n);
          if (Array[e(378)](t) && t[e(279)]) {
            let i = 0;
            t[e(471)]((t) => {
              const n = e,
                r = this.modelObj[n(213)](t[n(364)]);
              (null == r ? void 0 : r[n(446)]) &&
                (Array.isArray(r.material)
                  ? ((t[n(374)].encoding = r[n(446)][0][n(281)].encoding),
                    (r[n(446)][0][n(281)] = t[n(374)]))
                  : ((t.texture[n(268)] = r.material[n(281)][n(268)]),
                    (r[n(446)][n(281)] = t[n(374)])),
                i++);
            }),
              i === t[e(279)]
                ? this[e(375)][e(314)](e(222)) &&
                  this[e(375)][e(332)](e(222))({ code: 0, skinName: n })
                : this[e(375)].has(e(222)) &&
                  this[e(375)][e(332)](e(222))({
                    code: -1,
                    message: n + e(191),
                  });
          } else
            this[e(375)][e(314)]("reskinEnd") &&
              this[e(375)].get(e(222))({ code: -1, message: n + e(243) });
        }
      });
    }
    [Xf(287)]() {
      var t;
      const e = Xf;
      null == (t = this[e(467)]) || t.reset(),
        (!Array[e(378)](this[e(382)][e(347)]) ||
          -1 === this[e(382)].mode[e(224)](e(482))) &&
          ((this[e(467)][e(383)] = this[e(382)].resetDistance),
          (this[e(467)].minDistance = this.modelOption[e(231)])),
        this.controls.update();
    }
    static [Xf(409)](t) {
      return c(this, null, function* () {
        const e = Xf;
        try {
          const n = new ap(),
            i = yield n[e(351)](t),
            r = new Bd[e(393)](i);
          if (!i[e(283)].length) return null;
          const s = { array: [], duration: i[e(283)][0][e(306)] };
          return (
            i[e(283)][e(471)]((t) => {
              const n = e;
              s[n(361)] = s[n(361)][n(247)](
                Bd[n(323)][n(475)](r[n(233)](t).getClip()).tracks,
              );
            }),
            s
          );
        } catch (n) {
          return null;
        }
      });
    }
    setFov(t) {
      const e = Xf;
      this[e(467)] && 5 <= t && t <= 85 && (this[e(382)][e(204)] = t);
    }
    [Xf(474)](t) {
      const e = Xf;
      this[e(467)] &&
        0 <= t &&
        t <= 180 &&
        ((this[e(382)][e(348)] = t),
        (this.controls[e(274)] = (Math.PI / 180) * t),
        (this[e(467)][e(463)] = (Math.PI / 180) * t),
        this.controls[e(242)]());
    }
    getConfig() {
      const t = Xf;
      if (this[t(335)]) {
        const e = {
          fov: +this[t(382)].fov,
          polarAngle: +this.modelOption[t(348)],
        };
        return (
          Array.isArray(this[t(382)][t(347)]) &&
            this.modelOption.mode.indexOf(t(482)) > -1 &&
            (e[t(482)] = {
              x: this[t(467)][t(316)][t(482)].x,
              y: this[t(467)][t(316)][t(482)].y,
              z: this.controls[t(316)].position.z,
              distance: this[t(467)][t(218)](),
              target: {
                x: this[t(467)][t(312)].x,
                y: this[t(467)][t(312)].y,
                z: this[t(467)][t(312)].z,
              },
            }),
          e
        );
      }
      return {};
    }
    [Xf(202)](t) {
      var e;
      const n = Xf;
      return null == (e = this.modelObj)
        ? void 0
        : e.animations[n(256)]((e) => e[n(364)] === t);
    }
    [Xf(200)]() {
      return c(this, null, function* () {
        return new Promise((t) => {
          const e = qf;
          if (this.modelObj) {
            new ff()[e(258)](
              this[e(335)],
              function (n) {
                const i = new Blob([n], { type: e(441) });
                return t(i);
              },
              (n) => {
                const i = e;
                return console[i(431)](i(389), n), t(null);
              },
              { binary: !0, animations: this[e(335)][e(283)] },
            );
          }
        });
      });
    }
    [Xf(290)]() {
      const t = Xf;
      return (
        (i = l({}, this[t(265)])),
        (r = { actionMap: l({}, this[t(210)]) }),
        e(i, n(r))
      );
      var i, r;
    }
    [Xf(253)]() {
      var t, e, n;
      const i = Xf;
      function r(t, e) {
        const n = qf;
        null == e || e[n(473)]();
        for (let i = 0; i < (null == e ? void 0 : e[n(408)][n(279)]); i++)
          e[n(293)](e[n(408)][i]);
        (e = null),
          t[n(195)](function (t) {
            const e = n;
            (t instanceof Bd[e(417)] || t instanceof Bd[e(199)]) &&
              (t[e(446)] &&
                (t[e(446)][e(281)] && t[e(446)][e(281)].dispose(),
                t.material[e(211)] && t[e(446)].lightMap[e(466)](),
                t[e(446)].bumpMap && t[e(446)][e(286)][e(466)](),
                t.material[e(270)] && t.material.normalMap.dispose(),
                t[e(446)][e(357)] && t[e(446)][e(357)][e(466)](),
                t[e(446)][e(277)] && t[e(446)][e(277)].dispose(),
                t[e(446)][e(466)]()),
              t.geometry && t.geometry[e(466)]()),
              t instanceof Bd[e(199)] && t[e(280)] && t.skeleton.dispose();
          }),
          (t = null);
      }
      const s = Object[i(370)](this.componentObj[i(281)]);
      for (
        s[i(279)] &&
          (s.forEach((t) => {
            const e = i,
              { modelObjArr: n, mixerArr: s } = this.componentObj[e(281)][t];
            for (let i = 0; i < n.length; i++) r(n[i], s[i]);
          }),
          (this.componentObj = { curKey: "", map: {} })),
          r(this.modelObj, this[i(371)]),
          this[i(472)] = !1;
        (null == (t = this[i(192)]) ? void 0 : t[i(406)][i(279)]) > 0;

      )
        this[i(192)][i(359)](this[i(192)][i(406)][0]);
      for (; (null == (e = this[i(298)]) ? void 0 : e[i(406)][i(279)]) > 0; )
        this[i(298)].remove(this[i(298)].children[0]);
      (this[i(192)] = null),
        (this[i(298)] = null),
        null == (n = this[i(318)]) || n.dispose(),
        (this[i(318)] = null),
        (this[i(311)][i(339)] = ""),
        (this.controls = null);
    }
  }
  const $f = em;
  !(function (t, e) {
    const n = em,
      i = t();
    for (;;)
      try {
        if (
          405774 ===
          (-parseInt(n(361)) / 1) * (-parseInt(n(304)) / 2) +
            (-parseInt(n(261)) / 3) * (parseInt(n(289)) / 4) +
            (-parseInt(n(324)) / 5) * (parseInt(n(303)) / 6) +
            (-parseInt(n(358)) / 7) * (parseInt(n(253)) / 8) +
            -parseInt(n(288)) / 9 +
            parseInt(n(365)) / 10 +
            parseInt(n(374)) / 11
        )
          break;
        i.push(i.shift());
      } catch (r) {
        i.push(i.shift());
      }
  })(nm);
  const Qf = (function () {
      let t = !0;
      return function (e, n) {
        const i = t
          ? function () {
              if (n) {
                const t = n[em(275)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = !1), i;
      };
    })(),
    tm = Qf(globalThis, function () {
      const t = em;
      return tm[t(227)]()[t(321)](t(340))[t(227)]()[t(213)](tm).search(t(340));
    });
  function em(t, e) {
    const n = nm();
    return (em = function (t, e) {
      return n[(t -= 211)];
    })(t, e);
  }
  function nm() {
    const t = [
      "unzip",
      "unzip_wasm.js",
      "initAudio",
      "keys",
      "isCanReport",
      "getBSData",
      "1005",
      "apply",
      "ttsTxt",
      "1006",
      "replace",
      "player",
      "unzipWorker",
      "getError",
      "getGlbBlob",
      "position",
      "actionLoad",
      "loadComponent",
      "isExistAction",
      "toLocaleLowerCase",
      "1128213MiFYIN",
      "8GZgGtd",
      "initUnzip",
      "actionArray",
      "start-audio",
      "then",
      "glb2json",
      "stopTTSPlay",
      "isChat",
      " - model",
      "concat",
      "1014",
      "actionData",
      "getConfig",
      "json",
      "7638PopfCS",
      "15366siDLcf",
      "1013",
      "eventMap",
      "showStats",
      "setEndFunc",
      "ondataavailable",
      "tts_audio",
      "end",
      ": model",
      "captureStream",
      "streamId",
      "chunks",
      "volume",
      "length",
      "inited",
      "playStatus",
      "setVolume",
      "search",
      "setStartFunc",
      "terminate",
      "2170rlYHbN",
      "obj",
      "1002",
      "httpOrigin",
      "isTextEnd",
      "defaultActionName",
      "video/webm",
      "all",
      "data",
      "href",
      "stopRecordTimeout",
      "getActionConfig",
      "onmessage",
      "pcmOption",
      "isPureAction",
      "setIntl",
      "(((.+)+)+)+$",
      "setPolarAngle",
      "mediaRecorder",
      "error",
      "actionList",
      "push",
      "start",
      "stop",
      "path error",
      "isNew",
      "postMessage",
      "report",
      "pushTTSData",
      "code",
      "isNumber",
      "1016",
      "action ",
      "test",
      "7NQwKhw",
      "now",
      "startRecord",
      "101luyypS",
      "isStream",
      "nlp",
      "reskinEnd",
      "2579100XCJMLY",
      "lastIndexOf",
      "componentLoad",
      "smartActionEnabled",
      "modelDownload",
      "stopRecord",
      "distance",
      "isArray",
      "nodeType",
      "9911231OPlltB",
      "init",
      "onerror",
      ": action",
      "setPrivatization",
      "addTrack",
      "split",
      "play",
      "shift",
      "seqNo",
      "playerVolume",
      "sentence",
      "1012",
      "reskin",
      "name",
      " - action",
      "constructor",
      "modelData",
      "destory",
      "object",
      "onstop",
      "playEndFunc",
      "action",
      "resetPositionInfo",
      "map",
      "version",
      "has",
      "floor",
      "fov",
      "rootElt",
      "toString",
      "modelSize",
      "substring",
      "arrayBuffer",
      "ignoreArr",
      "tts",
      "isUnzip",
      "userId",
      "1007",
      "recording timeout",
      "actionEnd",
      "querySelector",
      "1010",
      "forEach",
      "filter",
      "model",
      "parse",
      "isRecord",
      "assign",
      "unzip_worker.js",
      "1011",
      "pop",
      "catch",
      "isValidURL",
      "1009",
      "trim",
      "352312usTBfX",
      "get",
      "modelInit",
      "setFov",
      "1004",
      "playAction",
      "privatizationOpt",
      "target",
      "1210893dQgmED",
      "exec",
      "getAudioTracks",
      "component ",
      "decode",
      "openingActionName",
      "record",
    ];
    return (nm = function () {
      return t;
    })();
  }
  tm();
  class im {
    constructor() {
      const t = em;
      (this.eventMap = new Map()),
        (this[t(384)] = 1),
        (this[t(319)] = t(311)),
        (this[t(259)] = null),
        (this.pcmOption = { channels: 1, sampleRate: 24e3, flushTime: 200 }),
        (this.obj = {
          isRecord: !1,
          isPureAction: !1,
          rootElt: null,
          mediaRecorder: null,
          chunks: [],
          isTextEnd: !1,
          actionList: [],
          stopRecordTimeout: -1,
        }),
        (this.unzipWorker = null);
    }
    startRecord() {
      const t = em,
        e = this[t(325)].rootElt[t(238)]("canvas")[t(313)](),
        n = this[t(279)].getRecordAudioStream();
      e[t(379)](n[t(263)]()[0]);
      const i = new MediaRecorder(e, { mimeType: "video/webm; codecs=vp9" });
      (this[t(325)][t(315)] = []),
        (i[t(309)] = (e) => {
          const n = t;
          e[n(332)].size > 0 && this.obj[n(315)][n(345)](e.data);
        }),
        (i[t(217)] = () => {
          const e = t,
            n = new Blob(this[e(325)][e(315)], { type: e(330) });
          this[e(306)][e(223)](e(267)) &&
            this[e(306)][e(254)](e(267))({ code: 0, data: n });
        }),
        i[t(346)](),
        (this[t(325)].mediaRecorder = i);
    }
    stopRecord() {
      const t = em;
      this[t(325)][t(244)] &&
        this[t(325)][t(342)] &&
        (clearTimeout(this[t(325)][t(334)]),
        (this[t(325)].isRecord = !1),
        this[t(325)][t(342)].stop(),
        (this.obj[t(342)] = null));
    }
    isValidURL(t) {
      try {
        return new URL(t), !0;
      } catch (e) {
        return !1;
      }
    }
    unzip(t) {
      return c(this, null, function* () {
        return new Promise((e) => {
          var n;
          const i = em;
          if (!(null == (n = this[i(280)]) ? void 0 : n[i(318)]))
            return e(null);
          if (!this.isValidURL(t)) {
            const e = location.href.lastIndexOf("/") + 1;
            t = new URL(location[i(333)][i(229)](0, e) + t)[i(333)];
          }
          (this[i(280)][i(336)] = (t) => {
            const n = i,
              { cmd: r, value: s } = t.data;
            if (r === n(268)) {
              if (s) {
                const t = s[n(241)]((t) => {
                  const e = n;
                  return (
                    /\.(?:glb|json)$/i[e(357)](t[e(211)]) &&
                    !/^__MACOSX\/.*\._/i.test(t[e(211)])
                  );
                })[n(221)]((t) => {
                  const e = n;
                  return (t[e(211)] = t[e(211)][e(278)](/^.*\//, "")), t;
                });
                e(t);
              } else e(null);
              this[n(280)][n(336)] = null;
            }
          }),
            this.unzipWorker[i(350)]({ cmd: i(268), value: t });
        });
      });
    }
    [$f(375)](t) {
      return c(this, null, function* () {
        const e = $f;
        let n,
          {
            element: i,
            sign: r,
            virtualmanKey: s,
            virtualmanProjectId: a,
            skinMap: o,
            modelPath: l,
            modelData: c,
            actionPath: h,
            actionData: u,
            defaultActionIdx: d,
            openingActionIdx: p,
            modelOption: f,
            confPath: g,
            confData: v,
            configPath: _,
            configData: y,
            isIntl: x,
          } = t;
        if (
          (!_ && g && (_ = g),
          !y && v && ((y = v), (v = null)),
          (n =
            typeof i === e(216) && 1 === i[e(373)]
              ? i
              : document.querySelector(i)),
          !n)
        )
          return (
            this[e(306)].has("error") &&
            this[e(306)][e(254)]("error")({
              code: 1001,
              message: m.getError("1001"),
            })
          );
        if (
          ((this.obj[e(226)] = n),
          a && a[e(252)]() && (s = a),
          !s || "" === s[e(252)]())
        )
          return (
            this[e(306)][e(223)]("error") &&
            this[e(306)][e(254)]("error")({
              code: 1008,
              message: m[e(281)]("1008"),
            })
          );
        if (!(this[e(259)] || (r && "" !== r[e(252)]())))
          return (
            this.eventMap[e(223)](e(343)) &&
            this[e(306)][e(254)](e(343))({
              code: 1002,
              message: m[e(281)](e(326)),
            })
          );
        if (!l && !c)
          return (
            this.eventMap[e(223)](e(343)) &&
            this[e(306)][e(254)]("error")({
              code: 1003,
              message: m.getError("1003"),
            })
          );
        if (!h && !u)
          return (
            this[e(306)][e(223)](e(343)) &&
            this[e(306)][e(254)](e(343))({
              code: 1004,
              message: m[e(281)](e(257)),
            })
          );
        m[e(339)](x),
          (this.ws = new X({ sign: r, virtualmanKey: s })),
          this.privatizationOpt && this.ws.setPrivatization(this[e(259)]),
          this.ws.on("error", (t) => {
            const n = e;
            this[n(306)].has(n(343)) && this[n(306)].get(n(343))(t);
          }),
          this.ws.on("nlp", (t) => {
            const n = e;
            0 === t.code &&
              this.eventMap[n(223)](n(363)) &&
              this[n(306)][n(254)](n(363))(t);
          }),
          this.ws.on("tts_bs", (t) => {
            const n = e;
            0 === t[n(353)] && this[n(242)][n(352)](t.data);
          }),
          this.ws.on(e(310), (t) => {
            const n = e;
            if (0 !== t[n(353)] || !this[n(279)]) return;
            const { audioData: i, final: r } = t.data;
            this[n(279)].feed(i, r),
              this[n(319)] != n(292) &&
                null == i &&
                r &&
                this[n(279)][n(218)]();
          });
        const S = {
          virtualmanKey: s,
          eventCode: e(242),
          modelInit: -1,
          modelDownload: -1,
          modelSize: -1,
          isUnzip: !1,
        };
        if (!y && _)
          try {
            y = yield fetch(_)[e(293)]((t) => t.json());
          } catch (T) {
            return (
              console[e(343)](T),
              this[e(306)][e(223)](e(343)) &&
                this[e(306)][e(254)](e(343))({
                  code: 1010,
                  message: m[e(281)](e(239)),
                })
            );
          }
        if (y && typeof y === e(216) && !Array[e(372)](y)) {
          if (
            (!m[e(354)](y[e(225)]) && delete y[e(225)],
            !m[e(354)](y.polarAngle) && delete y.polarAngle,
            y.position)
          ) {
            const t = y[e(283)],
              n = t[e(260)];
            (m[e(354)](t.x) &&
              m[e(354)](t.y) &&
              m[e(354)](t.z) &&
              m[e(354)](t[e(371)]) &&
              m[e(354)](null == n ? void 0 : n.x) &&
              m[e(354)](null == n ? void 0 : n.y) &&
              m[e(354)](null == n ? void 0 : n.z)) ||
              delete y[e(283)];
          }
          f = Object[e(245)](f || {}, y);
        }
        this.model && (this[e(242)][e(215)](), (this[e(242)] = null)),
          (this[e(242)] = new Jf({ skinMap: o, modelOption: f })),
          this[e(242)].on(e(343), (t) => {
            const n = e;
            this[n(306)][n(223)](n(343)) && this[n(306)].get(n(343))(t);
          }),
          this[e(242)].on(e(255), (t) => {
            const n = e;
            (S[n(255)] = Date.now() - S[n(255)]),
              M[n(351)](S),
              this[n(306)][n(223)]("init") &&
                this[n(306)][n(254)](n(375))({ code: 0 }),
              (c = null),
              (y = null);
          }),
          this[e(242)].on(e(284), (t) => {
            const n = e;
            this.eventMap[n(223)](n(284)) &&
              this[n(306)][n(254)](n(284))({ code: 0, actionArray: t[n(291)] }),
              (u = null);
          }),
          this[e(242)].on(e(237), (t) => {
            var n;
            const i = e;
            if (
              (this.eventMap[i(223)](i(237)) && this[i(306)][i(254)](i(237))(t),
              this[i(325)][i(344)][i(317)] &&
                t[i(219)] === this[i(325)][i(344)][0])
            ) {
              this[i(325)][i(344)][i(382)]();
              for (
                let e = 0;
                e < (null == (n = t[i(231)]) ? void 0 : n[i(317)]);
                e++
              )
                t[i(231)][e] === this[i(325)][i(344)][0] &&
                  this.obj[i(344)][i(382)]();
            }
            this[i(325)][i(244)] &&
              (this[i(325)][i(338)]
                ? this.stopRecord()
                : this[i(325)].isTextEnd &&
                  !this.obj[i(344)].length &&
                  this[i(370)]()),
              this[i(325)][i(338)] &&
                this.eventMap.has("play") &&
                this[i(306)][i(254)]("play")({ code: 0, text: "" });
          }),
          this[e(242)].on(e(364), (t) => {
            const n = e;
            this[n(306)][n(223)](n(364)) && this[n(306)][n(254)](n(364))(t);
          }),
          this[e(242)].on(e(385), (t) => {
            const n = e;
            this[n(306)][n(223)](n(385)) &&
              this.eventMap[n(254)]("sentence")(t);
          });
        let b = [];
        if (!c)
          if (/\.zip$/i[e(357)](l)) {
            (S.modelDownload = Date.now()), (S[e(233)] = !0);
            let t = yield this[e(268)](l);
            if (!t)
              return (
                this[e(306)][e(223)]("error") &&
                this[e(306)].get(e(343))({
                  code: 1013,
                  message: m[e(281)](e(305)) + e(312),
                })
              );
            (c = t[0][e(332)].buffer),
              (t = null),
              (S[e(369)] = Date.now() - S.modelDownload);
          } else
            b[e(345)](fetch(l).then((t) => t[e(230)]())),
              (S[e(369)] = Date.now());
        if (!u)
          if (((u = []), /\.zip$/i.test(h[0]))) {
            const t = yield this[e(268)](h[0]);
            if (!t)
              return (
                this[e(306)][e(223)](e(343)) &&
                this[e(306)].get(e(343))({
                  code: 1013,
                  message: m[e(281)](e(305)) + e(377),
                })
              );
            (d = -1),
              (p = -1),
              t[e(240)]((t, n) => {
                const i = e,
                  r = new TextDecoder()[i(265)](t[i(332)]),
                  s = t[i(211)].split(".")[0];
                u.push({ data: JSON[i(243)](r), name: s }),
                  s === m.defaultActionName
                    ? (d = n)
                    : s === m[i(266)] && (p = n);
              });
          } else
            null == d && (d = 0),
              (b = b[e(298)](
                h.map((t) => {
                  const n = e;
                  return fetch(t)
                    [n(293)]((t) => t[n(302)]())
                    [n(249)]((t) => {
                      const e = n;
                      return (
                        this[e(306)][e(223)](e(343)) &&
                          this[e(306)][e(254)]("error")({
                            code: 1006,
                            message: m[e(281)]("1006"),
                          }),
                        null
                      );
                    });
                }),
              ));
        b.length &&
          (yield Promise[e(331)](b)[e(293)]((t) => {
            const n = e;
            !c && ((c = t[n(382)]()), (S[n(369)] = Date.now() - S[n(369)])),
              t[n(241)]((t) => null != t)[n(240)]((t, e) => {
                const i = n;
                u[e] = {
                  data: t,
                  name: h[e][i(380)]("/")[i(248)]()[i(380)](".")[0],
                };
              });
          }));
        for (let t = 0; t < u[e(317)]; t++) {
          const n = u[t][e(211)];
          if (n === m[e(329)] && d != t)
            return (
              this[e(306)][e(223)](e(343)) &&
              this[e(306)][e(254)]("error")({
                code: 1015,
                message: m[e(281)]("1015"),
              })
            );
          if (n === m.openingActionName && p != t) {
            if (null != p)
              return (
                this[e(306)][e(223)](e(343)) &&
                this[e(306)][e(254)](e(343))({
                  code: 1016,
                  message: m[e(281)](e(355)),
                })
              );
            p = t;
          }
        }
        (S[e(228)] = Math[e(224)](c.byteLength / 1024 / 1024)),
          (S.modelInit = Date[e(359)]()),
          this[e(242)].modelInit({
            rootElt: n,
            modelData: c,
            actionData: u,
            defaultActionIdx: d,
            openingActionIdx: p,
          });
      });
    }
    on(t, e) {
      const n = $f;
      if (e)
        switch (t) {
          case n(375):
          case n(284):
          case n(237):
          case n(364):
          case n(363):
          case n(381):
          case "sentence":
          case n(267):
          case n(343):
            this[n(306)].set(t, (...t) => {
              try {
                e(...t);
              } catch (n) {}
            });
        }
    }
    [$f(320)](t = 1) {
      var e;
      const n = $f;
      (this[n(384)] = t), null == (e = this[n(279)]) || e[n(316)](t);
    }
    loadAction(t) {
      return c(this, null, function* () {
        const e = $f;
        try {
          let { actionPath: n, actionData: i } = t;
          if (!n && !i)
            return (
              this.eventMap.has("error") &&
              this[e(306)][e(254)]("error")({
                code: 1004,
                message: m[e(281)](e(257)),
              })
            );
          let r = [];
          if (!i)
            if (((i = []), /\.zip$/i.test(n[0]))) {
              const t = yield this.unzip(n[0]);
              if (!t)
                return (
                  this.eventMap[e(223)](e(343)) &&
                  this[e(306)][e(254)](e(343))({
                    code: 1013,
                    message: m[e(281)](e(305)) + e(377),
                  })
                );
              t.forEach((t, n) => {
                const r = e,
                  s = new TextDecoder()[r(265)](t[r(332)]),
                  a = t[r(211)].split(".")[0];
                i.push({ data: JSON[r(243)](s), name: a });
              });
            } else
              (r = r[e(298)](
                n.map((t) => {
                  const n = e;
                  return fetch(t)
                    [n(293)]((t) => t[n(302)]())
                    [n(249)]((t) => {
                      const e = n;
                      return (
                        this[e(306)].has(e(343)) &&
                          this.eventMap.get(e(343))({
                            code: 1006,
                            message: m[e(281)](e(277)),
                          }),
                        null
                      );
                    });
                }),
              )),
                yield Promise[e(331)](r)[e(293)]((t) => {
                  const r = e;
                  t.filter((t) => null != t)[r(240)]((t, e) => {
                    const s = r;
                    i[e] = {
                      data: t,
                      name: n[e][s(380)]("/").pop()[s(380)](".")[0],
                    };
                  });
                });
          this[e(242)].actionLoad({ actionData: i });
        } catch (n) {
          return (
            this[e(306)][e(223)](e(343)) &&
            this.eventMap[e(254)](e(343))({
              code: 1006,
              message: m[e(281)](e(277)),
            })
          );
        }
      });
    }
    [$f(285)](t) {
      return c(this, null, function* () {
        const e = $f;
        try {
          let { zipPath: n } = t;
          if (!n || !n.trim() || !/\.zip$/i[e(357)](n)) throw new Error(e(348));
          const i = (yield this[e(268)](n)).map((t) => {
            const n = e;
            return (t[n(211)] = t[n(211)][n(287)]()), t;
          });
          let r = {};
          for (; i[e(317)]; ) {
            const t = i.shift(),
              n = t[e(211)][e(380)](/_daoju_|\./),
              s = n[0];
            !r[s] && (r[s] = { map: {} });
            const a = 3 === n[e(317)],
              o = n[n[e(317)] - 1] === e(302);
            if (a) {
              const i = n[1];
              !r[s][e(221)][i] && (r[s][e(221)][i] = {}),
                o
                  ? (r[s].map[i][e(300)] = JSON[e(243)](
                      new TextDecoder()[e(265)](t[e(332)]),
                    ))
                  : (r[s][e(221)][i][e(214)] = t[e(332)].buffer);
            } else
              r[s][e(300)] = JSON[e(243)](new TextDecoder()[e(265)](t[e(332)]));
          }
          Object[e(271)](r)[e(240)]((t) => {
            const n = e,
              i = r[t];
            if (!i.actionData) throw new Error(n(356) + t);
            const s = Object[n(271)](i[n(221)]);
            if (!s[n(317)]) throw new Error(n(264) + t);
            s[n(240)]((e) => {
              const r = n,
                s = i[r(221)][e];
              if (!s[r(214)]) throw new Error(r(264) + t + r(297));
              if (!s[r(300)]) throw new Error(r(264) + t + r(212));
            });
          }),
            yield this.model[e(367)](r),
            (r = null);
        } catch (n) {
          return (
            this[e(306)][e(223)]("error") &&
            this.eventMap[e(254)](e(343))({
              code: 1014,
              message: m.getError(e(299)) + ": " + n[e(227)](),
            })
          );
        }
      });
    }
    [$f(270)]() {
      const t = $f;
      this.playStatus === t(311) &&
        ((this[t(279)] = new Q(this[t(337)])),
        this[t(279)][t(316)](this[t(384)]));
    }
    stop() {
      var t, e;
      const n = $f;
      this[n(279)] && (this[n(279)].destroy(), (this[n(279)] = null)),
        null == (t = this.ws) || t[n(347)](),
        null == (e = this.model) || e[n(295)](),
        (this.playStatus = "end");
    }
    [$f(381)](t, e) {
      var n;
      const i = $f;
      if (!this.ws)
        return (
          this.eventMap.has(i(343)) &&
          this.eventMap.get(i(343))({ code: 1011, message: m[i(281)](i(247)) })
        );
      let r = /^(?:<insert\-action type="([^"]+)"\/>)+$/i,
        s = r[i(262)](t);
      if (s) {
        this.obj[i(338)] = !0;
        const t = s[1];
        return this.model[i(286)](t)
          ? this[i(242)][i(258)](s[1])
          : this[i(306)][i(223)]("play") &&
              this.eventMap[i(254)](i(381))({ code: -1, text: "" });
      }
      for (
        this.obj.isPureAction = !1, r = /<insert\-action type="([^"]+)"\/>/gi;
        (s = r.exec(t));

      ) {
        const t = s[1];
        (null == (n = this[i(242)]) ? void 0 : n.isExistAction(t)) &&
          this[i(325)].actionList[i(345)](t);
      }
      if (!this[i(279)])
        return (
          this.eventMap[i(223)]("error") &&
          this[i(306)][i(254)](i(343))({
            code: 1005,
            message: m[i(281)](i(274)),
          })
        );
      if ("end" !== this[i(319)]) {
        if (
          !(null == e ? void 0 : e[i(362)]) ||
          ((null == e ? void 0 : e.isStream) &&
            1 === (null == e ? void 0 : e.seqNo)) ||
          ((null == e ? void 0 : e[i(362)]) &&
            (null == e ? void 0 : e[i(314)]) !== this.playStatus)
        )
          return (
            this[i(306)][i(223)]("error") &&
            this[i(306)][i(254)](i(343))({
              code: 1007,
              message: m[i(281)](i(235)),
            })
          );
      }
      if (
        (null == e ? void 0 : e[i(362)]) &&
        !(null == e ? void 0 : e.streamId)
      )
        return (
          this.eventMap.has(i(343)) &&
          this.eventMap.get(i(343))({ code: 1009, message: m[i(281)](i(251)) })
        );
      (null == e ? void 0 : e[i(362)])
        ? 1 === (null == e ? void 0 : e[i(383)]) &&
          (this[i(319)] = null == e ? void 0 : e.streamId)
        : (this[i(319)] = i(346)),
        this[i(279)][i(322)](() => {
          const t = i;
          this[t(319)] = t(292);
        }),
        this.player[i(308)](() => {
          const t = i;
          (this[t(319)] = t(311)),
            this[t(306)][t(223)](t(381)) &&
              this.eventMap[t(254)]("play")({ code: 0, text: this.ws[t(276)] }),
            this[t(325)][t(344)][t(317)]
              ? ((this.obj[t(328)] = !0),
                (this[t(325)][t(334)] = setTimeout(() => {
                  const e = t;
                  this.obj[e(342)] && (this[e(325)][e(342)][e(217)] = null),
                    this[e(306)].has(e(267)) &&
                      this[e(306)].get(e(267))({ code: -1, message: e(236) }),
                    this[e(370)]();
                }, 2e4)))
              : this[t(370)]();
        }),
        (null == e ? void 0 : e[i(296)])
          ? this.ws[i(363)](t, {
              isNew: null == e ? void 0 : e[i(349)],
              userId: null == e ? void 0 : e[i(234)],
              smartActionEnabled: null == e ? void 0 : e[i(368)],
            })
          : this.ws[i(232)](t, {
              isStream: null == e ? void 0 : e[i(362)],
              seqNo: null == e ? void 0 : e[i(383)],
              isFinal: null == e ? void 0 : e.isFinal,
              streamId: null == e ? void 0 : e[i(314)],
              smartActionEnabled: null == e ? void 0 : e.smartActionEnabled,
            });
    }
    [$f(267)](t, e) {
      const n = $f;
      this.playStatus === n(311) &&
        ((this.player = new Q(Object[n(245)](this[n(337)], { isRecord: !0 }))),
        this[n(279)][n(316)](this.playerVolume),
        (this[n(325)][n(244)] = !0),
        (this[n(325)][n(328)] = !1),
        (this[n(325)][n(344)] = []),
        this[n(360)](),
        this.play(t, e));
    }
    [$f(387)](t) {
      const e = $f;
      this[e(242)] && this[e(242)][e(387)](t);
    }
    [$f(378)](t = { appKey: "", accessToken: "" }) {
      const e = $f,
        { appKey: n, accessToken: i, httpOrigin: r, wsOrigin: s } = t;
      return (
        !!(n && i && n.trim() && i[e(252)]()) &&
        ((this[e(259)] = {
          appKey: n,
          accessToken: i,
          httpOrigin: r,
          wsOrigin: s,
        }),
        (r && r[e(252)]() !== m[e(327)]) || (s && s.trim() !== m.wsOrigin)
          ? (m[e(272)] = !1)
          : (m[e(272)] = !0),
        !0)
      );
    }
    [$f(335)](t) {
      return c(this, null, function* () {
        const e = $f;
        return yield this.ws[e(335)](t);
      });
    }
    [$f(307)](t) {
      const e = $f;
      this[e(242)] && this.model[e(307)](t);
    }
    [$f(301)]() {
      const t = $f;
      return this[t(242)] ? this[t(242)][t(301)]() : null;
    }
    [$f(220)]() {
      var t;
      const e = $f;
      null == (t = this.model) || t[e(220)]();
    }
    [$f(294)](t) {
      return c(this, null, function* () {
        return yield Jf.glb2json(t);
      });
    }
    [$f(256)](t) {
      var e;
      const n = $f;
      null == (e = this[n(242)]) || e[n(256)](t);
    }
    [$f(341)](t) {
      var e;
      const n = $f;
      null == (e = this[n(242)]) || e[n(341)](t);
    }
    getGlbBlob() {
      return c(this, null, function* () {
        var t;
        const e = $f;
        return yield null == (t = this[e(242)]) ? void 0 : t[e(282)]();
      });
    }
    [$f(273)]() {
      var t;
      const e = $f;
      return null == (t = this.model) ? void 0 : t[e(273)]();
    }
    [$f(215)]() {
      const t = $f;
      this[t(242)] &&
        this.ws &&
        (this[t(347)](),
        this[t(242)].destory(),
        (this.model = null),
        (this.ws = null),
        this.unzipWorker &&
          (this.unzipWorker[t(323)](), (this.unzipWorker = null)));
    }
    [$f(290)](t) {
      return c(this, null, function* () {
        var e;
        const n = $f;
        return (null == (e = this.unzipWorker) ? void 0 : e[n(318)])
          ? this[n(280)][n(318)]
          : new Promise((e) => {
              const i = n;
              let { path: r } = t;
              if (!this[i(250)](r)) {
                const t = location[i(333)][i(366)]("/") + 1;
                r = new URL(
                  location[i(333)][i(229)](0, t) +
                    r +
                    ("/" !== r[r[i(317)] - 1] ? "/" : ""),
                ).href;
              }
              (this[i(280)] = new Worker(r + i(246))),
                this[i(280)][i(350)]({
                  cmd: i(375),
                  value: { wasm: r + "unzip_wasm_bg.wasm", js: r + i(269) },
                }),
                (this[i(280)].onmessage = (t) => {
                  const n = i,
                    { cmd: r, value: s } = t[n(332)];
                  if (r === n(375)) return (this[n(280)][n(318)] = s), e(s);
                }),
                (this[i(280)][i(376)] = (t) => {
                  const n = i;
                  return (
                    console.error("Worker error:", t),
                    this.eventMap[n(223)](n(343)) &&
                      this[n(306)][n(254)](n(343))({
                        code: 1012,
                        message: m[n(281)](n(386)),
                      }),
                    e(!1)
                  );
                });
            });
      });
    }
  }
  const rm = new im(),
    sm = {
      on(t, e) {
        rm.on(t, e);
      },
      init(t) {
        rm[$f(375)](t);
      },
      loadAction(t) {
        rm.loadAction(t);
      },
      loadComponent(t) {
        rm[$f(285)](t);
      },
      initAudio() {
        rm[$f(270)]();
      },
      setVolume() {
        rm[$f(320)](arguments[0]);
      },
      play(t, e) {
        rm[$f(381)](t, e);
      },
      record(t, e) {
        rm.record(t, e);
      },
      stop() {
        rm.stop();
      },
      reskin(t) {
        rm[$f(387)](t);
      },
      info: () => ({ version: m[$f(222)] }),
      setPrivatization: (t) => rm[$f(378)](t),
      getActionConfig: (t) => rm[$f(335)](t),
      showStats(t) {
        rm[$f(307)](t);
      },
      getConf: () => rm[$f(301)](),
      getConfig: () => rm[$f(301)](),
      resetPositionInfo() {
        rm[$f(220)]();
      },
      glb2json: (t) => rm[$f(294)](t),
      setFov(t) {
        rm.setFov(t);
      },
      setPolarAngle(t) {
        rm[$f(341)](t);
      },
      getGlbBlob: () => rm[$f(282)](),
      getBSData: () => rm[$f(273)](),
      destroy() {
        rm[$f(215)]();
      },
      initUnzip: (t) => rm[$f(290)](t),
    };
  return sm;
});
